<link rel="import" href="esis-extractor.html">

<polymer-element name="esis-parser">
	<template></template>
	<script>
		Polymer('esis-parser',{
			extractor : null,

			ready : function() {
				this.extractor = document.querySelector('esis-extractor');
			},

			parse : function(file, callback) {
				var arr = [];
				var info = file.info;
				var contents = file.contents;

				if( info.ext == 'xlsx' ) {
					try {

						var ref = this;
						function onXlsxComplete(wb){
							var count = 0;

							var list = wb.SheetNames;
							for( i = 0; i < list.length; i++ ) {
								var sheetName = list[i];
								var worksheet = wb.Sheets[sheetName];
								
								var data = ref.sheet_to_array(wb.Sheets[sheetName]);
								if( !data ) data = [[]];

								var resp = ref.extractor.run(file.defaultDataType, data);
								count++;
								resp.sheetName = sheetName;
								resp.array = data;
								ref.onComplete(null, resp, info, count, wb.SheetNames.length, arr, callback);
							};
						}

						var worker = new Worker('components/js-xlsx/xlsxworker.js');
						worker.onmessage = function(e) {
							switch(e.data.t) {
								case 'ready': break;
								case 'e': console.error(e.data.d); break;
								case 'xlsx': onXlsxComplete(JSON.parse(e.data.d)); break;
							}
						};
						worker.postMessage({d:contents,b:true});

					} catch(e) {
						debugger;
						this.onComplete(e, null, info, 1, 1, arr, callback);
					}
				} else if( info.ext == 'xls' ) {
					try {
						

						var ref = this;
						function onXlsComplete(wb){
							//wb = XLS.read(contents, {type: 'binary'});

							var count = 0;
							var list = wb.SheetNames;
							for( i = 0; i < list.length; i++ ) {
								var sheetName = list[i];
								var worksheet = wb.Sheets[sheetName];
								
								var data = ref.sheet_to_array(wb.Sheets[sheetName]);
								if( !data ) data = [[]];

								var resp = ref.extractor.run(file.defaultDataType, data);
								count++;
								resp.sheetName = sheetName;
								resp.array = data;
								ref.onComplete(null, resp, info, count, wb.SheetNames.length, arr, callback);
							};
						}

						function fixdata(data) {
							var o = "", l = 0, w = 10240;
							for(; l<data.byteLength/w; ++l) o+=String.fromCharCode.apply(null,new Uint8Array(data.slice(l*w,l*w+w)));
							o+=String.fromCharCode.apply(null, new Uint8Array(data.slice(o.length)));
							return o;
						}

						var worker = new Worker('components/js-xls/xlsworker.js');
						worker.onmessage = function(e) {
							switch(e.data.t) {
								case 'ready': break;
								case 'e': console.error(e.data.d); break;
								case 'xls': onXlsComplete(JSON.parse(e.data.d)); break;
							}
						};

						contents = btoa(fixdata(contents));
						//debugger;
						worker.postMessage({d:contents, b:false});

					} catch(e) {
						debugger;
						this.onComplete(e, null, info, 1, 1, arr, callback);
					}
				} else if ( info.hasData ) {
					//try {
						var options = {};
						if( info.parser == 'csv-tab' ) options.separator = '\t';
						if( info.parser == 'csv-4spaces' ) options.separator = '    ';
						if( info.parser == 'csv-2spaces' ) options.separator = '  ';

						$.csv.toArrays(contents, options, function(err, data){
							if( err ) return onComplete(err, null, info, 1, 1, arr, callback);

							var resp = this.extractor.run(file.defaultDataType, data);
							resp.array = data;
							this.onComplete(null, resp, info, 1, 1, arr, callback);

						}.bind(this));
					//} catch(e) {
					//	debugger;
					//	this.onComplete(e, null, info, 1, 1, arr, callback);
					//}
				} else {
					this.onComplete(null, null, info, 1, 1, arr, callback);
				}
			},

			/**
			 * err - was there an error parsing the data
			 * data - response from esis-extractor
			 * info - general information about the file the datasheet came from
			 * index - current datasheet index we just parsed
			 * total - total number of datasheets in this file
			 * arr - the response array of resources we will send back when everything is done
			 * callback - function to call when all datasheets have been parsed for this file
			 **/
			onComplete : function(err, data, info, index, total, arr, callback) {
				if( err ) {
					data = {
						error : err
					}
				} else if( !data ) {
					data = {
						error : 'Unknown parse error'
					}
				} else if( data.measurements.length == 0 && 
					Object.keys(data.metadata).length == 0 &&
					!data.joindata ) {
					data.warning = 'No metadata or measurements found';
				}

				data.name = info.name;
				if( total > 1 ) {
					if( !data.sheetName ) data.sheetName = index;
				}

				data.info = {};
				for( key in info ) data.info[key] = info[key];

				// don't want to add datasheets as resources
				data.info.type = 'data';

				arr.push(data);

				if( index == total ) callback(arr);
			},

			sheet_to_array : function(sheet) {
				var out = [], txt = "";
				if(sheet == null || sheet["!ref"] == null) return "";
				var r = this.safe_decode_range(sheet["!ref"]);
				var row = [], rr = "", cols = [];
				var i = 0, cc = 0, val;
				var R = 0, C = 0;
				for(C = r.s.c; C <= r.e.c; ++C) cols[C] = XLSX.utils.encode_col(C);
				for(R = r.s.r; R <= r.e.r; ++R) {
					row = [];
					rr = XLSX.utils.encode_row(R);
					for(C = r.s.c; C <= r.e.c; ++C) {
						val = sheet[cols[C] + rr];
						txt = val !== undefined ? ''+XLSX.utils.format_cell(val) : "";
						row.push(txt);
					}
					out.push(row);
				}
				return out;
			},

			// from XLSX utils...
			safe_decode_range : function(range) {
				var o = {s:{c:0,r:0},e:{c:0,r:0}};
				var idx = 0, i = 0, cc = 0;
				var len = range.length;
				for(idx = 0; i < len; ++i) {
					if((cc=range.charCodeAt(i)-64) < 1 || cc > 26) break;
					idx = 26*idx + cc;
				}
				o.s.c = --idx;

				for(idx = 0; i < len; ++i) {
					if((cc=range.charCodeAt(i)-48) < 0 || cc > 9) break;
					idx = 10*idx + cc;
				}
				o.s.r = --idx;

				if(i === len || range.charCodeAt(++i) === 58) { o.e.c=o.s.c; o.e.r=o.s.r; return o; }

				for(idx = 0; i != len; ++i) {
					if((cc=range.charCodeAt(i)-64) < 1 || cc > 26) break;
					idx = 26*idx + cc;
				}
				o.e.c = --idx;

				for(idx = 0; i != len; ++i) {
					if((cc=range.charCodeAt(i)-48) < 0 || cc > 9) break;
					idx = 10*idx + cc;
				}
				o.e.r = --idx;
				return o;
			}
		});
	</script>
</polymer-element>