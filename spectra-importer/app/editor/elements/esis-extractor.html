<polymer-element name="esis-extractor">
    <template></template>
    <script>
        Polymer('esis-extractor', {

            ds : null,

            ready : function() {
                this.ds = document.querySelector('esis-datastore');
            },

            // type - 'spectral', 'timeseries', 'metadata'
            run : function(type, contents) {
                var resp = {
                    metadata : {},
                    measurements : [],
                    attributeTypes : {}
                }

                if( contents === null ) {
                    return resp;
                } else if ( contents.length == 0 ) {
                    return resp;
                }

                if( type == 'metadata' ) {
                    var data = this._parseAsMetadata(contents);
                    resp.joindata = data.joindata;
                    resp.attributeTypes = data.attributeTypes;
                    return resp;
                }

                // where are the horizontal ranges of data
                var hRanges = this._getHRanges(contents);

                // get vertical ranges. Only for datapoints in timeseries
                var vRanges = this._getVRanges(contents, type, hRanges); 

                resp.metadata = this._getFileMetadata(contents, hRanges);
                var data = this._getMeasurements(contents, type, hRanges, vRanges);

                // add the file level metadata to the attribute type list
                for( var key in resp.metadata ) {
                    data.attributeTypes[key] = { 
                        guess : false,
                        type : 'metadata',
                        flag : this.ds.ATTR_FLAGS.IS_FILE_METADATA
                    }
                }

                if( data.error ) {
                    resp.error = true;
                } else {
                    resp.measurements = data.measurements;
                    resp.attributeTypes = data.attributeTypes;
                }

                return resp;
            },

            _parseAsMetadata : function(contents) {
                var joindata = [];
                var attributeTypes = {};

                for( var i = 1; i < contents.length; i++ ) {
                    var md = {};
                    for( var j = 0; j < contents[0].length; j++ ) {
                        md[contents[0][j]] = contents[i][j];

                        if( i == 1 ) {
                            attributeTypes[contents[0][j]] = { 
                                guess : false,
                                type : 'metadata',
                                flag : this.ds.ATTR_FLAGS.FROM_METADATA
                            };
                        }
                    }
                    joindata.push(md);
                }

                return {
                    joindata : joindata,
                    attributeTypes : attributeTypes
                };
            },

            // returns the starting point after the break (in case there are multiple line breaks)
            _getHRanges : function(contents) {
                var ranges = [];

                var cStart = 0;
                var cStop = 0;
                var processing = true;
                var empty = false;

                for( var i = 0; i < contents.length; i++ ) {
                    empty = false;
                    if( contents[i].length == 0 ) empty = true;
                    else if( contents[i][0].length == 0 ) empty = true;

                    if( empty && processing ) {
                        processing = false;
                        ranges.push({
                            start : cStart,
                            stop  : cStop
                        });
                        continue;
                    } else if ( empty ) {
                        continue;
                    }

                    if( processing ) {
                        cStop = i;
                    } else {
                        processing = true;
                        cStart = i;
                    }
                }

                if( processing ) {
                    ranges.push({
                        start : cStart,
                        stop  : cStop
                    });
                }

                return ranges;
            },

            _getVRanges : function(contents, type, hRanges) {
                var ranges = [];

                if( type != 'timeseries' ) return ranges;
                if( hRanges.length == 0 ) return ranges;

                var startRow = 0;
                if( hRanges.length == 2 ) {
                    startRow = hRanges[1].start;
                }

                var row = contents[startRow];
                var cStart = 0;
                var cStop = 0;
                var processing = true;
                var empty = false;

                for( var i = 0; i < row.length; i++ ) {
                    empty = false;
                    if( row[i].length == 0 ) empty = true;

                    if( empty && processing ) {
                        processing = false;
                        ranges.push({
                            start : cStart,
                            stop  : cStop
                        });
                        continue;
                    } else if ( empty ) {
                        continue;
                    }

                    if( processing ) {
                        cStop = i;
                    } else {
                        processing = true;
                        cStart = i;
                    }
                }

                if( processing ) {
                    ranges.push({
                        start : cStart,
                        stop  : cStop
                    });
                }

                return ranges;
            },

            _getFileMetadata : function(contents, hRanges) {
                // if there is only one range of data, there is not file metadata
                if( hRanges.length == 1 ) return {};

                // if the first row doesn't have exactly two columns, there is a problem
                for( var i = 0; i <= hRanges[0].stop; i++ ) {
                    if( contents[i].length == 1 ) {
                        return {};
                    } else if( contents[i].length >= 3 && contents[i][2] != '' ) {
                        return {};
                    }
                }

                var fileMetadata = {};
                for( var i = 0; i <= hRanges[0].stop; i++ ) {
                    if( !contents[i][0] ) continue;
                    fileMetadata[this._cleanKey(contents[i][0])] = this._cleanValue(contents[i][1]);
                }
                return fileMetadata;
            },

            _getMeasurements : function(contents, type, hRanges, vRanges) {

                // actual measurements being parsed
                var measurements = []; 
                // what we are guessing the attributes are (data v metadata)
                var attributeTypes = {}; 

                // we are parsing as though attribute names are vertical in column A
                if( type == 'spectra' ) {

                    var dataRange = null, metadataRange = null, guess = true;

                    // there is only one range of data, it's all data and we
                    // should guess on type
                    if( hRanges.length == 1 ) {
                        dataRange = hRanges[0];

                    // there are two ranges of data
                    } else if ( hRanges.length == 2 ) {
                        // the first range is global file metadata, the second is
                        // data and we should guess on type
                        if( this._getLength(contents[0]) == 2 ) {
                            dataRange = hRanges[1];

                        // the first range is metadata and the second range is data
                        // no need to guess on type
                        } else {
                            guess = false;
                            metadataRange = hRanges[0];
                            dataRange = hRanges[1];
                        }
                    
                    // there are three ranges.  user gave use everything via format
                    } else if( hRanges.length > 2 ) {
                        guess = false;
                        metadataRange = hRanges[1];
                        dataRange = hRanges[2];
                    }

                    if( !dataRange ) return {error : true};

                    // find what rows are thought to be data (match numberic value) or metadata (doesn't)
                    var dataRows = this._findDataRows(contents, metadataRange, dataRange);

                    var len = contents[dataRange.start].length, i, j;
                    for( i = 1; i < len; i++ ) {
                        var measurement = {
                            metadata : {},
                            datapoints : []
                        };

                        // add metadata range for this column
                        if( metadataRange ) {
                            for( j = metadataRange.start; j <= metadataRange.stop; j++ ) {
                                key = contents[j][0];

                                // add wavelengths even if they are in the wrong range
                                if( dataRows[key] ) {
                                    measurement.datapoints.push({
                                        key : key,
                                        value : this._cleanValue(contents[j][i])
                                    });
                                } else {
                                    key = this._cleanKey(key);
                                    // add known metadata from metadata range
                                    measurement.metadata[key] = this._cleanValue(contents[j][i]);
                                }
                                

                                // mark the attribute type on first pass
                                if( i == 1 ) {
                                    attributeTypes[key] = { 
                                        guess : false,
                                        type : dataRows[key] ? 'data' : 'metadata',
                                        flag : dataRows[key] ? this.ds.ATTR_FLAGS.IS_WAVELENGTH :
                                                                this.ds.ATTR_FLAGS.IS_MEASUREMENT_METADATA
                                    };
                                }
                            }
                        }

                        // add datarange for this column
                        for( j = dataRange.start; j <= dataRange.stop; j++ ) {
                            var key = contents[j][0];

                            // this is data
                            if( dataRows[key] || !guess ) {
                                if( !dataRows[key] ) key = this._cleanKey(key);

                                measurement.datapoints.push({
                                    key : key,
                                    value : this._cleanValue(contents[j][i])
                                });

                                // this is a numberic or we are not guessing
                                // either way type is implied
                                if( i == 1 ) {
                                    attributeTypes[key] = { 
                                        guess : false,
                                        type : 'data',
                                        flag : dataRows[key] ? this.ds.ATTR_FLAGS.IS_WAVELENGTH :
                                                                this.ds.ATTR_FLAGS.IS_FILE_DATA
                                    };
                                }

                            // this is metadata
                            } else {                      
                                this._cleanKey(key);

                                // we are guess, by default we will say 'metadata', but check
                                // any specified values first
                                var type = 'metadata';
                                if( this.ds.attributeModifications[key] ) {
                                    type = this.ds.attributeModifications[key];
                                }

                                // set to correct type
                                if( type == 'metadata' ) {
                                    measurement.metadata[key] = this._cleanValue(contents[j][i]);
                                } else {
                                    measurement.datapoints.push({
                                        key: key,
                                        value : this._cleanValue(contents[j][i])
                                    });
                                }


                                if( i == 1 ) {
                                    attributeTypes[key] = { 
                                        guess : guess,
                                        type : type,
                                        flag : this.ds.ATTR_FLAGS.FROM_MIXED_FILE
                                    };
                                }
                            }
                        }

                        measurements.push(measurement);
                    }

                // we are parsing as though attribute names are in a row with values
                // in column below
                } else if ( type == 'timeseries' ) {
                    var startRow = 0;
                    var stopRow = 0;
                    var dataRange = null, metadataRange = null, guess = true;

                    // there is only one range of data, no global file metadata provided
                    if( hRanges.length == 1 ) {
                        startRow = hRanges[0].start;
                        stopRow = hRanges[0].stop;
                        
                    // user provided file metadata
                    } else if ( hRanges >= 2 ) {
                        startRow = hRanges[1].start;
                        stopRow = hRanges[1].stop;
                    }

                    // only one data group, guess on type 
                    if( vRanges.length == 1 ) {
                        dataRange = vRanges[0];

                    // user has specified metadata and data, no need to guess on type
                    } else if ( vRanges.length > 1 ) {
                        metadataRange = vRanges[0];
                        dataRange = vRanges[1];
                        guess = false;
                    }

                    if( !dataRange ) return {error : true};

                    var dataCols = {};
                    if( guess ) {
                        dataCols = this._findDataCols(contents, startRow);
                    }

                    var i, j, row, measurement, key;

                    // the actual 'startRow' should be the row of attribute names
                    for( i = startRow+1; i <= stopRow; i++ ) {
                        measurement = {
                            metadata : {},
                            datapoints : []
                        };
                        row = contents[i];

                        // if we have a metadata block, add the metadata
                        if( metadataRange ) {
                            for( j = metadataRange.start; j <= metadataRange.stop; j++ ) {
                                key = contents[startRow][j];
                                
                                if( dataCols[key] ) {
                                    measurement.datapoints.push({
                                        key : contents[key],
                                        value : row[j]
                                    });
                                } else {
                                    key = this._cleanKey(key);
                                    // add wavelengths even if they are in the wrong range
                                    measurement.metadata[key] = this._cleanValue(row[j]);
                                }

                                // on first pass, keep track of attribute information
                                if( i == startRow+1 ) {
                                    attributeTypes[key] = { 
                                        guess : false,
                                        type : 'metadata',
                                        flag : dataCols[key] ? this.ds.ATTR_FLAGS.IS_WAVELENGTH :
                                                                this.ds.ATTR_FLAGS.IS_MEASUREMENT_METADATA
                                    };
                                }
                            }
                        }

                        // add datarange for this column
                        for( j = dataRange.start; j <= dataRange.stop; j++ ) {
                            key = contents[startRow][j];

                            // this is data
                            if( dataCols[key] || !guess ) {
                                if( !dataCols[key] ) key = this._cleanKey(key);

                                measurement.datapoints.push({
                                    key : key,
                                    value : this._cleanValue(row[j])
                                });

                                // mark the attribute type on first pass
                                if( i == startRow+1 ) {
                                    attributeTypes[key] = { 
                                        guess : false,
                                        type : 'data',
                                        flag : dataCols[key] ? this.ds.ATTR_FLAGS.IS_WAVELENGTH :
                                                                this.ds.ATTR_FLAGS.IS_FILE_DATA
                                    };
                                }


                            // this is metadata
                            } else {
                                this._cleanKey(key);

                                // we are guess, by default we will say 'metadata', but check
                                // any specified values first
                                var type = 'metadata';
                                if( this.ds.attributeModifications[key] ) {
                                    type = this.ds.attributeModifications[key];
                                }

                                // set to correct type
                                if( type == 'metadata' ) {
                                    measurement.metadata[key] = this._cleanValue(row[j]);
                                } else {
                                    measurement.datapoints.push({
                                        key: key,
                                        value : this._cleanValue(row[j])
                                    });
                                }

                                // mark the attribute type on first pass
                                if( i == startRow+1 ) {
                                    attributeTypes[key] = { 
                                        guess : guess,
                                        type : type,
                                        flag : this.ds.ATTR_FLAGS.FROM_MIXED_FILE
                                    };
                                }
                            }
                        }

                        measurements.push(measurement);
                    }
                }

                return {
                    measurements : measurements,
                    attributeTypes : attributeTypes
                }
            },


            // attempt to sniff out data columns.
            _findDataCols : function(content, startRow) {
                var data = {};

                for( var i = 0; i < content[startRow].length; i++ ) {
                    var key = content[startRow][i];
            
                    if( key.match(/^-?\d+\.?\d*$/) || key.match(/^-?\d*\.\d+$/) ) {
                        data[key] = true;
                    } else {
                        data[key] = false;
                    }
                    
                }

                return data;
            },

            // any attribute name that matches a numberic value will be assumed wavelength and
            // marked as data, otherwise it will be assumed as metadata.  This is for when
            // the user doesn't add the second break to their file
            _findDataRows : function(content, metadataRange, dataRange) {
                var data = {};
                var re1 = /^-?\d+\.?\d*$/;
                var re2 = /^-?\d*\.\d+$/;

                if( metadataRange ) {
                    for( var i = metadataRange.start; i <= metadataRange.stop; i++ ) {
                        var key = content[i][0];

                        if( re1.exec(key) || re2.exec(key) ) {
                            data[key] = true;
                        } else {
                            data[key] = false;
                        }
                    }
                }


                for( var i = dataRange.start; i <= dataRange.stop; i++ ) {
                    var key = content[i][0];

                    if( re1.exec(key) || re2.exec(key) ) {
                        data[key] = true;
                    } else {
                        data[key] = false;
                    }
                    
                }

                return data;
            },

            regex : {
                key1 : /\./g,
                key2 : /\n/g,
                val : /\r/g
            },

            // clean a key so it can be added into mongo
            _cleanKey : function(key) {
                if( !key ) return '';
                return key.replace(this.regex.key1,'').replace(this.regex.key2,'');
            },

            _cleanValue : function(val) {
                if( !val ) return '';
                return val.replace(this.regex.key2,' ').replace(this.regex.val,'');
            },

            // get the number of cells until the rest are empty
            _getLength : function(arr) {
                if( !arr ) return 0;
                if( arr[arr.length-1] && arr[arr.length-1] != '' ) return arr.length;

                var i = 0; len = arr.length;
                for( var i = len-1; i >= 0; i-- ) {
                    if( arr[i] != '' ) return i+1;
                }
                return 0;
            }
        });
    </script>
</polymer-element>