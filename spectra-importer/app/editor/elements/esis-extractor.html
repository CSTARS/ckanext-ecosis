<polymer-element name="esis-extractor">
    <template></template>
    <script>
        Polymer('esis-extractor', {

            ds : null,

            ready : function() {
                this.ds = document.querySelector('esis-datastore');
            },

            // type - 'spectral', 'timeseries', 'metadata'
            run : function(type, contents) {

                var resp = {
                    metadata : {},
                    measurements : [],
                    attributeTypes : {}
                }

                if( contents === null ) {
                    return resp;
                } else if ( contents.length == 0 ) {
                    return resp;
                }

                if( type == 'metadata' ) {
                    var data = this._parseAsMetadata(contents);
                    resp.joindata = data.joindata;
                    resp.attributeTypes = data.attributeTypes;
                    return resp;
                }

                // where are the horizontal ranges of data
                var hRanges = this._getHRanges(contents);

                // get vertical ranges. Only for datapoints in timeseries
                var vRanges = this._getVRanges(contents, type, hRanges); 

                
                var data = this._getMeasurements(contents, type, hRanges, vRanges);
                resp.metadata = this._getFileMetadata(contents, hRanges, data.attributeTypes);

                // if there are more than 500 attribute types found that are not wavelengths, assume wrong data format selected.  Don't parse.
                var c = 0;
                for( var key in data.attributeTypes ) {
                    if( data.attributeTypes[key].flag != this.ds.ATTR_FLAGS.IS_WAVELENGTH ) c++;
                }
                if( c > 500 ) {
                    resp.error = c+' different attribute types where found.  Recommend switching the data format.';
                    return resp;
                }

                console.log(data.attributeTypes);

                if( data.error ) {
                    resp.error = data.error;
                } else {

                    resp.measurements = data.measurements;
                    resp.attributeTypes = data.attributeTypes;
                }

                return resp;
            },

            _parseAsMetadata : function(contents) {
                var joindata = [];
                var attributeTypes = {};

                var attrInfo = this._parseAttributeKeyByCols(contents, 0);
                var key, keyInfo;

                for( var i = 1; i < contents.length; i++ ) {
                    var md = {};
                    for( var j = 0; j < contents[0].length; j++ ) {
                        key = contents[0][j];
                        keyInfo = attrInfo[key];

                        md[keyInfo.key] = contents[i][j];

                        if( i == 1 ) {
                            attributeTypes[contents[0][j]] = { 
                                guess : false,
                                type : 'metadata',
                                flag : this.ds.ATTR_FLAGS.FROM_METADATA
                            };
                            this._addUnitOrLabel(keyInfo, attributeTypes[keyInfo.key]);
                        }
                    }
                    joindata.push(md);
                }

                return {
                    joindata : joindata,
                    attributeTypes : attributeTypes
                };
            },

            // returns the starting point after the break (in case there are multiple line breaks)
            _getHRanges : function(contents) {
                var ranges = [];

                var cStart = 0;
                var cStop = 0;
                var processing = true;
                var empty = false;

                // first make sure there are no extra rows at top
                for( cStart = 0; cStart < contents.length; cStart++ ) {
                    empty = false;
                    if( contents[cStart].length == 0 ) empty = true;
                    else if( contents[cStart][0].length == 0 ) empty = true;
                    if( !empty ) break;
                }
                cStop = cStart;

                for( var i = cStart; i < contents.length; i++ ) {
                    empty = false;
                    if( contents[i].length == 0 ) empty = true;
                    else if( contents[i][0].length == 0 ) empty = true;

                    if( empty && processing ) {
                        processing = false;
                        ranges.push({
                            start : cStart,
                            stop  : cStop
                        });
                        continue;
                    } else if ( empty ) {
                        continue;
                    }

                    if( processing ) {
                        cStop = i;
                    } else {
                        processing = true;
                        cStart = i;
                    }
                }

                if( processing ) {
                    ranges.push({
                        start : cStart,
                        stop  : cStop
                    });
                }

                return ranges;
            },

            _getVRanges : function(contents, type, hRanges) {
                var ranges = [];

                if( type != 'timeseries' ) return ranges;
                if( hRanges.length == 0 ) return ranges;

                var startRow = 0;
                if( hRanges.length == 2 ) {
                    startRow = hRanges[1].start;
                } else if( hRanges.length == 1 ) {
                    startRow = hRanges[0].start;
                }

                var row = contents[startRow];
                var cStart = 0;
                var cStop = 0;
                var processing = true;
                var empty = false;

                for( var i = 0; i < row.length; i++ ) {
                    empty = false;
                    if( row[i].length == 0 ) empty = true;

                    if( empty && processing ) {
                        processing = false;
                        ranges.push({
                            start : cStart,
                            stop  : cStop
                        });
                        continue;
                    } else if ( empty ) {
                        continue;
                    }

                    if( processing ) {
                        cStop = i;
                    } else {
                        processing = true;
                        cStart = i;
                    }
                }

                if( processing ) {
                    ranges.push({
                        start : cStart,
                        stop  : cStop
                    });
                }

                return ranges;
            },

            _getFileMetadata : function(contents, hRanges, attributeTypes) {
                // if there is only one range of data, there is not file metadata
                if( hRanges.length == 1 ) return {};

                // if the first row doesn't have exactly two columns, there is a problem
                for( var i = 0; i <= hRanges[0].stop; i++ ) {
                    if( contents[i].length == 1 ) {
                        return {};
                    } else if( contents[i].length >= 3 && contents[i][2] != '' ) {
                        return {};
                    }
                }

                var fileMetadata = {}, keyInfo;
                for( var i = 0; i <= hRanges[0].stop; i++ ) {
                    if( !contents[i][0] ) continue;

                    keyInfo = this._parseAttributeKey(key);
                    fileMetadata[keyInfo.key] = this._cleanValue(contents[i][1]);

                    attributeTypes[keyInfo.key] = { 
                        guess : false,
                        type : 'metadata',
                        flag : this.ds.ATTR_FLAGS.IS_FILE_METADATA
                    }
                    this._addUnitOrLabel(keyInfo, attributeTypes[keyInfo.key]);
                }
                return fileMetadata;
            },

            _getMeasurements : function(contents, type, hRanges, vRanges) {

                // actual measurements being parsed
                var measurements = []; 
                // what we are guessing the attributes are (data v metadata)
                var attributeTypes = {}; 

                // we are parsing as though attribute names are vertical in column A
                if( type == 'spectra' ) {

                    var dataRange = null, metadataRange = null, guess = true, keyInfo;

                    // there is only one range of data, it's all data and we
                    // should guess on type
                    if( hRanges.length == 1 ) {
                        dataRange = hRanges[0];

                    // there are two ranges of data
                    } else if ( hRanges.length == 2 ) {
                        // the first range is global file metadata, the second is
                        // data and we should guess on type
                        if( this._getLength(contents[0]) == 2 ) {
                            dataRange = hRanges[1];

                        // the first range is metadata and the second range is data
                        // no need to guess on type
                        } else {
                            guess = false;
                            metadataRange = hRanges[0];
                            dataRange = hRanges[1];
                        }
                    
                    // there are three ranges.  user gave use everything via format
                    } else if( hRanges.length > 2 ) {
                        guess = false;
                        metadataRange = hRanges[1];
                        dataRange = hRanges[2];
                    }

                    if( !dataRange ) return {error : true};

                    // find what rows are thought to be data (match numberic value) or metadata (doesn't)
                    var attrInfo = this._parseAttributeKeyByRows(contents, metadataRange, dataRange);

                    var len = contents[dataRange.start].length, i, j;
                    for( i = 1; i < len; i++ ) {
                        var measurement = {
                            metadata : {},
                            datapoints : []
                        };

                        // add metadata range for this column
                        if( metadataRange ) {
                            for( j = metadataRange.start; j <= metadataRange.stop; j++ ) {
                                key = contents[j][0];
                                keyInfo = attrInfo[key];

                                // add wavelengths even if they are in the wrong range
                                if( keyInfo.wavelength ) {
                                    measurement.datapoints.push({
                                        key : keyInfo.key,
                                        value : this._cleanValue(contents[j][i])
                                    });
                                } else {
                                    // add known metadata from metadata range
                                    measurement.metadata[keyInfo.key] = this._cleanValue(contents[j][i]);
                                }
                                

                                // mark the attribute type on first pass
                                if( i == 1 ) {
                                    attributeTypes[keyInfo.key] = { 
                                        guess : false,
                                        type : keyInfo.wavelength ? 'data' : 'metadata',
                                        flag : keyInfo.wavelength ? this.ds.ATTR_FLAGS.IS_WAVELENGTH :
                                                                this.ds.ATTR_FLAGS.IS_MEASUREMENT_METADATA
                                    };
                                    this._addUnitOrLabel(keyInfo, attributeTypes[keyInfo.key]);
                                }
                            }
                        }

                        // add datarange for this column
                        for( j = dataRange.start; j <= dataRange.stop; j++ ) {
                            var key = contents[j][0];
                            keyInfo = attrInfo[key];

                            // this is data
                            if( keyInfo.wavelength || !guess ) {
                                measurement.datapoints.push({
                                    key : keyInfo.key,
                                    value : this._cleanValue(contents[j][i])
                                });

                                // this is a numberic or we are not guessing
                                // either way type is implied
                                if( i == 1 ) {
                                    attributeTypes[keyInfo.key] = { 
                                        guess : false,
                                        type : 'data',
                                        flag : key.wavelength ? this.ds.ATTR_FLAGS.IS_WAVELENGTH :
                                                                this.ds.ATTR_FLAGS.IS_FILE_DATA
                                    };
                                    this._addUnitOrLabel(keyInfo, attributeTypes[keyInfo.key]);
                                }

                            // this is metadata
                            } else {                      
                                // we are guess, by default we will say 'metadata', but check
                                // any specified values first
                                var type = 'metadata';
                                if( this.ds.attributeModifications[keyInfo.key] ) {
                                    type = this.ds.attributeModifications[keyInfo.key];
                                }

                                // set to correct type
                                if( type == 'metadata' ) {
                                    measurement.metadata[keyInfo.key] = this._cleanValue(contents[j][i]);
                                } else {
                                    measurement.datapoints.push({
                                        key: keyInfo.key,
                                        value : this._cleanValue(contents[j][i])
                                    });
                                }


                                if( i == 1 ) {
                                    attributeTypes[keyInfo.key] = { 
                                        guess : guess,
                                        type : type,
                                        flag : this.ds.ATTR_FLAGS.FROM_MIXED_FILE
                                    };
                                    this._addUnitOrLabel(keyInfo, attributeTypes[keyInfo.key]);
                                }
                            }
                        }

                        measurements.push(measurement);
                    }

                // we are parsing as though attribute names are in a row with values
                // in column below
                } else if ( type == 'timeseries' ) {
                    var startRow = 0;
                    var stopRow = 0;
                    var dataRange = null, metadataRange = null, guess = true;

                    // there is only one range of data, no global file metadata provided
                    if( hRanges.length == 1 ) {
                        startRow = hRanges[0].start;
                        stopRow = hRanges[0].stop;
                        
                    // user provided file metadata
                    } else if ( hRanges >= 2 ) {
                        startRow = hRanges[1].start;
                        stopRow = hRanges[1].stop;
                    }

                    // only one data group, guess on type 
                    if( vRanges.length == 1 ) {
                        dataRange = vRanges[0];

                    // user has specified metadata and data, no need to guess on type
                    } else if ( vRanges.length > 1 ) {
                        metadataRange = vRanges[0];
                        dataRange = vRanges[1];
                        guess = false;
                    }

                    if( !dataRange ) return {error : true};

                    // map of 'attr (unit)' to attr information
                    // info has 'wavelength', 'key' and 'label'
                    // if not a wavelength, key has been cleaned
                    var attrInfo = this._parseAttributeKeyByCols(contents, startRow);

                    var i, j, row, measurement, key, keyInfo;

                    // the actual 'startRow' should be the row of attribute names
                    for( i = startRow+1; i <= stopRow; i++ ) {
                        measurement = {
                            metadata : {},
                            datapoints : []
                        };
                        row = contents[i];

                        // if we have a metadata block, add the metadata
                        if( metadataRange ) {
                            for( j = metadataRange.start; j <= metadataRange.stop; j++ ) {
                                key = contents[startRow][j];
                                keyInfo = attrInfo[key];

                                // on first pass, keep track of attribute information
                                if( i == startRow+1 ) {
                                    attributeTypes[keyInfo.key] = { 
                                        guess : false,
                                        type : keyInfo.wavelength ? 'data' : 'metadata',
                                        flag : keyInfo.wavelength ? this.ds.ATTR_FLAGS.IS_WAVELENGTH :
                                                                    this.ds.ATTR_FLAGS.IS_MEASUREMENT_METADATA
                                    };

                                    // set units or label
                                    this._addUnitOrLabel(keyInfo, attributeTypes[keyInfo.key]);
                                }
                                
                                if( keyInfo.wavelength ) {
                                    measurement.datapoints.push({
                                        key : attrInfo[key].key,
                                        value : row[j]
                                    });
                                } else {
                                    // add wavelengths even if they are in the wrong range
                                    measurement.metadata[attrInfo[key].key] = this._cleanValue(row[j]);
                                }
                            }
                        }

                        // add datarange for this column
                        for( j = dataRange.start; j <= dataRange.stop; j++ ) {
                            key = contents[startRow][j];
                            keyInfo = attrInfo[key];

                            // this is data
                            if( keyInfo.wavelength || !guess ) {

                                measurement.datapoints.push({
                                    key : keyInfo.key,
                                    value : this._cleanValue(row[j])
                                });

                                // mark the attribute type on first pass
                                if( i == startRow+1 ) {
                                    attributeTypes[keyInfo.key] = { 
                                        guess : false,
                                        type : 'data',
                                        flag : keyInfo.wavelength ? this.ds.ATTR_FLAGS.IS_WAVELENGTH :
                                                                    this.ds.ATTR_FLAGS.IS_FILE_DATA
                                    };
                                    this._addUnitOrLabel(keyInfo, attributeTypes[keyInfo.key]);
                                }


                            // this is metadata
                            } else {

                                // we are guess, by default we will say 'metadata', but check
                                // any specified values first
                                var type = 'metadata';
                                if( this.ds.attributeModifications[keyInfo.key] ) {
                                    type = this.ds.attributeModifications[keyInfo.key];
                                }

                                // set to correct type
                                if( type == 'metadata' ) {
                                    measurement.metadata[keyInfo.key] = this._cleanValue(row[j]);
                                } else {
                                    measurement.datapoints.push({
                                        key: keyInfo.key,
                                        value : this._cleanValue(row[j])
                                    });
                                }

                                // mark the attribute type on first pass
                                if( i == startRow+1 ) {
                                    attributeTypes[keyInfo.key] = { 
                                        guess : guess,
                                        type : type,
                                        flag : this.ds.ATTR_FLAGS.FROM_MIXED_FILE
                                    };
                                    this._addUnitOrLabel(keyInfo, attributeTypes[keyInfo.key]);
                                }
                            }
                        }

                        measurements.push(measurement);
                    }
                }

                return {
                    measurements : measurements,
                    attributeTypes : attributeTypes
                }
            },

            _addUnitOrLabel : function(keyInfo, attr) {
                if( keyInfo.label ) {
                    if( keyInfo.wavelength ) {
                        attr.label = keyInfo.label;
                    } else {
                        attr.units = keyInfo.label;
                    }
                }
            },


            // attempt to sniff out attribute information by column columns.
            _parseAttributeKeyByCols : function(content, startRow) {
                var attrs = {}, key;

                for( var i = 0; i < content[startRow].length; i++ ) {
                    key = content[startRow][i];
                    attrs[key] = this._parseAttributeKey(key);
                }

                return attrs;
            },

            // any attribute name that matches a numberic value will be assumed wavelength and
            // marked as data, otherwise it will be assumed as metadata.  This is for when
            // the user doesn't add the second break to their file
             _parseAttributeKeyByRows : function(content, metadataRange, dataRange) {
                var attrs = {};
                var re1 = /^-?\d+\.?\d*/;
                var re2 = /^-?\d*\.\d+/;

                if( metadataRange ) {
                    for( var i = metadataRange.start; i <= metadataRange.stop; i++ ) {
                        var key = content[i][0];
                        attrs[key] = this._parseAttributeKey(key);
                    }
                }

                for( var i = dataRange.start; i <= dataRange.stop; i++ ) {
                    var key = content[i][0];
                    attrs[key] = this._parseAttributeKey(key);
                }

                return attrs;
            },

            regex : {
                key1 : /\./g,
                key2 : /\n/g,
                trim1 : /^\s*/,
                trim2 : /\s*$/,
                val : /\r/g
            },

            // clean a key so it can be added into mongo
            _cleanKey : function(key) {
                if( !key ) return '';
                return key.replace(this.regex.key1,'').replace(this.regex.key2,'');
            },

            _cleanValue : function(val) {
                if( !val ) return '';
                return val.replace(this.regex.key2,' ').replace(this.regex.val,'').replace(this.regex.trim1,'').replace(this.regex.trim2,'');
            },

            // get the number of cells until the rest are empty
            _getLength : function(arr) {
                if( !arr ) return 0;
                if( arr[arr.length-1] && arr[arr.length-1] != '' ) return arr.length;

                var i = 0; len = arr.length;
                for( var i = len-1; i >= 0; i-- ) {
                    if( arr[i] != '' ) return i+1;
                }
                return 0;
            },

            _parseAttributeUnits : function(attributeTypes) {
                var key, key2, parts, val, attr, regex = /.+\(.*\)\s*/;
                for( key in attributeTypes ) {
                    if( !regex.test(key) ) continue;

                    try {
                        attr = attributeTypes[key];

                        // split out the unit/label and the new key
                        parts = key.split('(');
                        key2 = parts[0].replace(/\s*$/,'');
                        val = parts[1].replace(/^\s*/,'').replace(/\)\s*$/,'');

                        if( attr.flag == this.ds.ATTR_FLAGS.IS_WAVELENGTH ) {
                            attr.label = val;
                        } else {
                            attr.units = val;
                        }

                        // replace the old key with the new key
                        delete attributeTypes[key];
                        attributeTypes[key2] = attr;
                    } catch(e) {}
                }
            },

            _parseAttributeKey : function(key) {
                var parts, attr;

                var re1Wave = /^-?\d+\.?\d*/;
                var re2Wave = /^-?\d*\.\d+/; 
                var reLabel = /.+\(.*\)\s*/;

                var resp = {
                    key : '',
                    wavelength : (re1Wave.test(key) || re2Wave.test(key)) ? true : false
                }


                // do we have a label to parse out?
                if( !reLabel.test(key) ) {
                    if( !resp.wavelength ) resp.key = this._cleanKey(key);
                    else resp.key = key;

                    return resp;
                }

                try {
                    // split out the unit/label and the new key
                    parts = key.split('(');

                    resp.key = parts[0].replace(/\s*$/,'');
                    if( !resp.wavelength ) resp.key = this._cleanKey(resp.key);
                    
                    resp.label = parts[1].replace(/^\s*/,'').replace(/\)\s*$/,'');
                } catch(e) {
                    debugger;
                }
                return resp;
            }

        });
    </script>
</polymer-element>