<polymer-element name="esis-extractor">
    <template></template>
    <script>
        Polymer('esis-extractor', {

            // type - 'spectral', 'timeseries', 'metadata'
            run : function(type, contents) {
                var resp = {
                    metadata : {},
                    measurements : []
                }

                if( type == 'metadata' ) {
                    resp.joindata = this._parseAsMetadata(contents);
                    return resp;
                }

                // how many horizontal breaks.  Stops checking after two
                var hBreaks = this._getHBreaks(contents);

                // get vertical break.  Only for datapoints in timeseries
                var vBreak = this._getVBreak(contents, type, hBreaks); 

                resp.metadata = this._getFileMetadata(contents, hBreaks);
                resp.measurements = this._getMeasurements(contents, type, hBreaks, vBreak);

                return resp;
            },

            _parseAsMetadata : function(contents) {
                var joindata = [];
                for( var i = 1; i < contents.length; i++ ) {
                    var md = {};
                    for( var j = 0; j < contents[0].length; j++ ) {
                        md[contents[0][j]] = md[contents[i][j]];
                    }
                    joindata.push(md);
                }
                return md;
            },

            _getHBreaks : function(contents) {
                var breaks = [];
                for( var i = 0; i < contents.length; i++ ) {
                    if( contents[i].length == 0 ) {
                        breaks.push(i);
                    } else if ( contents[i][0].length == 0 ) {
                        breaks.push(i);
                    }

                    if( breaks.length == 2 ) return breaks;
                }
                return breaks;
            },

            _getVBreak : function(contents, type, hBreaks) {
                if( type != 'timeseries' ) return -1;
                if( hBreaks.length == 0 ) return -1;

                var row = contents[hBreaks[0]+1];
                for( var i = 0; i < row.length; i++ ) {
                    if( row[i].length == 0 ) return i;
                }
                return -1;
            },

            _getFileMetadata : function(contents, hBreaks) {
                if( hBreaks.length == 0 ) return {};
                if( contents[0].length != 2 ) return {};

                var fileMetadata = {};
                for( var i = 0; i < hBreaks[0]; i++ ) {
                    fileMetadata[contents[i][0]] = contents[i][1];
                }
                return fileMetadata;
            },

            _getMeasurements : function(contents, type, hBreaks, vBreak) {
                
                if( type == 'spectra' ) {
                    var start = 0, end = 0, hasMetadata = false;

                    if( hBreaks.length == 1 && contents[0].length > 2 ) {
                        start = 0;
                        end = hBreaks[0];
                        hasMetadata = true;
                    } else if( hBreaks.length == 2 ) {
                        start = hBreaks[0]+1;
                        end = hBreaks[1];
                        hasMetadata = true;
                    }

                    var measurements = [];
                    for( var i = 1; i < contents[start].length; i++ ) {
                        var measurement = {
                            metadata : {},
                            datapoints : []
                        };

                        var metadataRows = {};
                        if( hasMetadata ) {
                            for( var j = start; j < end; j++ ) {
                                measurement.metadata[contents[j][0]] = contents[j][i];
                            }
                        } else {
                            metadataRows = this._findMetadataRows(contents, start);
                        }

                        for( var j = end; j < contents.length; j++ ) {
                            var key = contents[j][0];

                            if( metadataRows[key] ) {
                                measurement.metadata[key] = contents[j][i];
                            } else {
                                measurement.datapoints.push({
                                    key : contents[j][0],
                                    value : contents[j][i]
                                });
                            }
                        }

                        measurements.push(measurement);
                    }

                    return measurements;

                } else if ( type == 'timeseries' ) {

                    var start = 0, 
                        end = contents.length, 
                        hasMetadata = false
                        metadataEnd = vBreak;


                    if( hBreaks.length > 0 ) start = hBreaks[0];
                    if( vBreak != -1 ) hasMetadata = true;

                    var measurements = [];
                    for( var i = start+1; i < contents.length; i++ ) {
                        var measurement = {
                            metadata : {},
                            datapoints : []
                        };

                        var row = contents[i];

                        if( hasMetadata ) {

                            for( var j = 0; j < metadataEnd; j++ ) {
                                measurement.metadata[contents[start][j]] = row[j];
                            }

                            for( var j = metadataEnd+1; j < row.length; j++ ) {
                                measurement.datapoints.push({
                                    key : contents[start][j],
                                    value : row[j]
                                });
                            }

                        } else { // guess on metadata

                            var metadataCols = this._findMetadataCols(contents, start);

                            for( var j = 0; j < row.length; j++ ) {
                                var key = contents[start][j];
                                if( metadataCols[key] ) {
                                    measurement.metadata[key] = row[j];
                                } else {
                                    measurement.datapoints.push({
                                        key : key,
                                        value : row[j]
                                    });
                                }
                            }

                        }

                        measurements.push(measurement);
                    }

                    return measurements;

                }

                return [];
            },

            // attempt to sniff out metadata columns.
            _findMetadataCols : function(content, startRow) {
                var metadata = {};

                for( var i = 0; i < content[startRow].length; i++ ) {
                    var key = content[startRow][i];
                    var value = content[startRow+1][i];

                    if( value.match(/^-?\d+\.?\d*$/) || value.match(/^-?\d*\.\d+$/) ) {
                        metadata[key] = false;
                    } else {
                        metadata[key] = true;
                    }
                    
                }

                return metadata;
            },

            _findMetadataRows : function(content, startRow) {
                var metadata = {};

                for( var i = 0; i < content[startRow].length; i++ ) {
                    var key = content[i][0];
                    var value = content[i][1];

                    if( value.match(/^-?\d+\.?\d*$/) || value.match(/^-?\d*\.\d+$/) ) {
                        metadata[key] = false;
                    } else {
                        metadata[key] = true;
                    }
                    
                }

                return metadata;
            }


        });
    </script>
</polymer-element>