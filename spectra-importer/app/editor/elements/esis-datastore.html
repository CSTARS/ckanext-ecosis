<link rel="import" href="structures/esis-file.html">
<link rel="import" href="structures/esis-datasheet.html">
<link rel="import" href="structures/esis-resource.html">

<polymer-element name="esis-datastore" attributes="files">
	<script>
		Polymer('esis-datastore', {
			// is this an existing dataset
			editMode : false,

			existing : {
				resources : [],
				dataset   : {}
			},

			data : {
				title : '',
				name : '',
				notes : '',
				author : '',
				author_email : '',
				license_id : '',
				license_title : '',
				maintainer : '',
				maintainer_email : '',
				version : '',
				owner_org : '',
				tags : [],
				private : false
			},
			owner_org_name : '',

			group : {
				by : '',
				sort_on : '',
				description : '',
			},

			// field that should be used to create uids for measurements
			measurementDisambiguator : '',

			// list of all new files
			files : [],
			// list of all datasheets
			datasheets : [],
			// list of all new resources
			resources  : [],

			// list of current attribute map
			attributeMap : {},
			inverseAttributeMap : {},

			// list of currently known attributes for this dataset
			//   - this is a list of objects.  each object has the structure
			//       |- name : attribute name
			//       |- type : (data | metadata)
			//       \- flag : (1, 2) 
			knownAttributes : [],

			ATTR_FLAGS : {
				// the attribute is from a joined metadata file, always metadata
				FROM_METADATA : 1,
				// the attribute type could be data or metadata
				FROM_MIXED_FILE : 2,
				// the attribute name is numberic and is there for a wavelength
				IS_WAVELENGTH : 3,
				// the attribute is from global metadata
				IS_FILE_METADATA : 4,
				// the attribute is measurement level metadata
				IS_MEASUREMENT_METADATA : 5
			},

			// the key is the attribute name, the value is 
			attributes : {},

			// list of resources that are scheduled to be deleted
			deleted : [],

			observe : {
				attributeMap : '_onAttributeMapUpdate'
			},

			ready : function() {
				if( this.data.title == '' ) window.location.hash = '#basic-fields';
			},

			addFile : function(raw, parseZip, defaultDataType) {
				var ele = document.createElement('esis-file');
				ele.raw = raw;
				ele.parseZip = parseZip;
				ele.defaultDataType = defaultDataType;
				this.files.push(ele);
				return ele;
			},

			removeFile : function(file) {
				var index = this.files.indexOf(file);
				if( index > -1 ) {
					this.files.splice(index, 1);

					// remove anything from the datasheet or resource list
					for( var i = 0; i < file.datasheets.length; i++ ) {
						index = this.datasheets.indexOf(file.datasheets[i]);
						if( index > -1 ) this.datasheets.splice(index, 1);
					}

					for( var i = 0; i < file.resources.length; i++ ) {
						index = this.resources.indexOf(file.resources[i]);
						if( index > -1 ) this.resources.splice(index, 1);
					}
				}
			},

			addDatasheet : function(contents) {
				var ele = document.createElement('esis-datasheet');

				// attach listener for when attributes have been aggregated
				// add to known list when done
				ele.addEventListener('measurement-updated', function(e){
					this._addKnownAttributes(e.detail);
					this.datasheetJoin(ele);
				}.bind(this));

				ele.contents = contents;

				// move attributeTypes to first class citizen 
				if( ele.contents.attributeTypes ) {
					ele.attributeTypes = ele.contents.attributeTypes;
					delete ele.contents.attributeTypes;
				}

				this.datasheets.push(ele);
				
				return ele;
			},

			addResource : function(resource, datasheets) {
				var ele = document.createElement('esis-resource');
				ele.filename = resource.name || resource.info.name;
				ele.mimetype = resource.file ? resource.file.type : resource.info.mime;
				ele.ext = resource.info.ext;
				ele.datasheets = datasheets;
				this.resources.push(ele);
				return ele;
			},

			removeResource : function(id) {
				// remove resource
				for( var i = 0; i < this.existing.resources.length; i++ ) {
					if( this.existing.resources[i].id == id ) {
						this.existing.resources.splice(i,1);
						break;
					}
				}

				// remove any measurements associated with this resource
				for( var i = this.existing.dataset.data.length-1; i >= 0; i-- ) {
					if( this.existing.dataset.data[i].resource_id == id ) {
						this.existing.dataset.data.splice(i,1);
					}
				}

				// remove any metadata associated with this resource
				for( var i = this.existing.dataset.join.length-1; i >= 0; i-- ) {
					if( this.existing.dataset.join[i].resource_id == id ) {
						this.existing.dataset.join.splice(i, 1);
					}
				}

				this.deleted.push(id);
			},

			// when a datasheet is first added, make sure all metadata is properly joined in
			datasheetJoin : function(datasheet) {
				if( datasheet.isMetadata ) return;

				// make sure currently joined (new) metadata is joined
				for( var i = 0; i < this.datasheets.length; i++ ) {
					if( !this.datasheets[i].isMetadata ) continue;

					var count = 0;
					for( var j = 0; j < datasheet.spectra.length; j++ ) {
						if( this.datasheets[i].metadata.join(datasheet.spectra[j]) ) count++;
					}
					this.datasheets[i].metadata.matchCount += count;
				}
			},


			join : function(metadata) {
				var count = 0;
				
				// join on new measurements
				for( var i = 0; i < this.datasheets.length; i++ ) {
					if( this.datasheets[i].isMetadata ) continue;

					for( var j = 0; j < this.datasheets[i].spectra.length; j++ ) {
						if( metadata.join(this.datasheets[i].spectra[j]) ) count++;
					}
				}

				// join on existing measurements
				if( this.existing.dataset.data ) {
					for( var i = 0; i < this.existing.dataset.data.length; i++ ) {
						if( metadata.join(this.existing.dataset.data[i]) ) count++;
					}
				}

				metadata.matchCount = count;

				// make sure to add new metadata attribute to known list
				var attrs = metadata.joinAttributes();
				for( var i = 0; i < attrs.length; i++ ) {
					var index = this._hasAttribute(attrs[i]);

					if( index == -1 ) {
						this.knownAttributes.push({
							name : attrs[i],
							type : 'metadata',
							flag : ATTR_FLAGS.FROM_METADATA
						});
					} else {
						var item = this.knownAttributes[index];
						item.type = 'metadata';
						item.flag = ATTR_FLAGS.FROM_METADATA;
					}
				}
			},

			_updateKnownAttributes : function() {
				//for( var i = 0; i < )

				for( var i = 0; i < attrList.length; i++ ) {
					if( this.attributes[attrList[i]] ) continue;

					this.knownAttributes.push(attrList[i]);
					this.attributes[attrList[i]] = {}
				}
			},

			// acts like index of for known attributes array of objects
			_hasAttribute : function(name) {
				for( var i = 0; i < this.knownAttributes.length; i++ ) {
					if( this.knownAttributes[i].name == name ) return i;
				}
				return -1;
			},

			_onAttributeMapUpdate : function(oldMap, newMap) {
				this.inverseAttributeMap = {};
				for( var key in newMap ) {
					if( newMap[key] != '' ) this.inverseAttributeMap[newMap[key]] = key;
				}
			}
		});
	</script>
</polymer-element>