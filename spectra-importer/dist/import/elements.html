<html><head><script>(function () {
function resolve() {
document.body.removeAttribute('unresolved');
}
if (window.WebComponents) {
addEventListener('WebComponentsReady', resolve);
} else {
resolve();
}
}());

Polymer = {
Settings: function () {
var user = window.Polymer || {};
location.search.slice(1).split('&').forEach(function (o) {
o = o.split('=');
o[0] && (user[o[0]] = o[1] || true);
});
var wantShadow = user.dom === 'shadow';
var hasShadow = Boolean(Element.prototype.createShadowRoot);
var nativeShadow = hasShadow && !window.ShadowDOMPolyfill;
var useShadow = wantShadow && hasShadow;
var hasNativeImports = Boolean('import' in document.createElement('link'));
var useNativeImports = hasNativeImports;
var useNativeCustomElements = !window.CustomElements || window.CustomElements.useNative;
return {
wantShadow: wantShadow,
hasShadow: hasShadow,
nativeShadow: nativeShadow,
useShadow: useShadow,
useNativeShadow: useShadow && nativeShadow,
useNativeImports: useNativeImports,
useNativeCustomElements: useNativeCustomElements
};
}()
};

(function () {
var userPolymer = window.Polymer;
window.Polymer = function (prototype) {
var ctor = desugar(prototype);
prototype = ctor.prototype;
var options = { prototype: prototype };
if (prototype.extends) {
options.extends = prototype.extends;
}
Polymer.telemetry._registrate(prototype);
document.registerElement(prototype.is, options);
return ctor;
};
var desugar = function (prototype) {
prototype = Polymer.Base.chainObject(prototype, Polymer.Base);
prototype.registerCallback();
return prototype.constructor;
};
window.Polymer = Polymer;
if (userPolymer) {
for (var i in userPolymer) {
Polymer[i] = userPolymer[i];
}
}
Polymer.Class = desugar;
}());
Polymer.telemetry = {
registrations: [],
_regLog: function (prototype) {
console.log('[' + prototype.is + ']: registered');
},
_registrate: function (prototype) {
this.registrations.push(prototype);
Polymer.log && this._regLog(prototype);
},
dumpRegistrations: function () {
this.registrations.forEach(this._regLog);
}
};

Object.defineProperty(window, 'currentImport', {
enumerable: true,
configurable: true,
get: function () {
return (document._currentScript || document.currentScript).ownerDocument;
}
});

Polymer.Base = {
_addFeature: function (feature) {
this.extend(this, feature);
},
registerCallback: function () {
this._registerFeatures();
this._doBehavior('registered');
},
createdCallback: function () {
Polymer.telemetry.instanceCount++;
this.root = this;
this._doBehavior('created');
this._initFeatures();
},
attachedCallback: function () {
this.isAttached = true;
this._doBehavior('attached');
},
detachedCallback: function () {
this.isAttached = false;
this._doBehavior('detached');
},
attributeChangedCallback: function (name) {
this.setAttributeToProperty(this, name);
this._doBehavior('attributeChanged', arguments);
},
extend: function (prototype, api) {
if (prototype && api) {
Object.getOwnPropertyNames(api).forEach(function (n) {
this.copyOwnProperty(n, api, prototype);
}, this);
}
return prototype || api;
},
copyOwnProperty: function (name, source, target) {
var pd = Object.getOwnPropertyDescriptor(source, name);
if (pd) {
Object.defineProperty(target, name, pd);
}
},
_log: console.log.apply.bind(console.log, console),
_warn: console.warn.apply.bind(console.warn, console),
_error: console.error.apply.bind(console.error, console),
_logf: function () {
return this._logPrefix.concat([this.is]).concat(Array.prototype.slice.call(arguments, 0));
}
};
Polymer.Base._logPrefix = function () {
var color = window.chrome || /firefox/i.test(navigator.userAgent);
return color ? [
'%c[%s::%s]:',
'font-weight: bold; background-color:#EEEE00;'
] : ['[%s::%s]:'];
}();
Polymer.Base.chainObject = function (object, inherited) {
if (object && inherited && object !== inherited) {
if (!Object.__proto__) {
object = Polymer.Base.extend(Object.create(inherited), object);
}
object.__proto__ = inherited;
}
return object;
};
Polymer.Base = Polymer.Base.chainObject(Polymer.Base, HTMLElement.prototype);
Polymer.telemetry.instanceCount = 0;

(function () {
var modules = {};
var DomModule = function () {
return document.createElement('dom-module');
};
DomModule.prototype = Object.create(HTMLElement.prototype);
DomModule.prototype.constructor = DomModule;
DomModule.prototype.createdCallback = function () {
var id = this.id || this.getAttribute('name') || this.getAttribute('is');
if (id) {
this.id = id;
modules[id] = this;
}
};
DomModule.prototype.import = function (id, slctr) {
var m = modules[id];
if (!m) {
forceDocumentUpgrade();
m = modules[id];
}
if (m && slctr) {
m = m.querySelector(slctr);
}
return m;
};
var cePolyfill = window.CustomElements && !CustomElements.useNative;
if (cePolyfill) {
var ready = CustomElements.ready;
CustomElements.ready = true;
}
document.registerElement('dom-module', DomModule);
if (cePolyfill) {
CustomElements.ready = ready;
}
function forceDocumentUpgrade() {
if (cePolyfill) {
var script = document._currentScript || document.currentScript;
if (script) {
CustomElements.upgradeAll(script.ownerDocument);
}
}
}
}());

Polymer.Base._addFeature({
_prepIs: function () {
if (!this.is) {
var module = (document._currentScript || document.currentScript).parentNode;
if (module.localName === 'dom-module') {
var id = module.id || module.getAttribute('name') || module.getAttribute('is');
this.is = id;
}
}
}
});

Polymer.Base._addFeature({
behaviors: [],
_prepBehaviors: function () {
if (this.behaviors.length) {
this.behaviors = this._flattenBehaviorsList(this.behaviors);
}
this._prepAllBehaviors(this.behaviors);
},
_flattenBehaviorsList: function (behaviors) {
var flat = [];
behaviors.forEach(function (b) {
if (b instanceof Array) {
flat = flat.concat(this._flattenBehaviorsList(b));
} else if (b) {
flat.push(b);
} else {
this._warn(this._logf('_flattenBehaviorsList', 'behavior is null, check for missing or 404 import'));
}
}, this);
return flat;
},
_prepAllBehaviors: function (behaviors) {
for (var i = behaviors.length - 1; i >= 0; i--) {
this._mixinBehavior(behaviors[i]);
}
for (var i = 0, l = behaviors.length; i < l; i++) {
this._prepBehavior(behaviors[i]);
}
this._prepBehavior(this);
},
_mixinBehavior: function (b) {
Object.getOwnPropertyNames(b).forEach(function (n) {
switch (n) {
case 'hostAttributes':
case 'registered':
case 'properties':
case 'observers':
case 'listeners':
case 'created':
case 'attached':
case 'detached':
case 'attributeChanged':
case 'configure':
case 'ready':
break;
default:
if (!this.hasOwnProperty(n)) {
this.copyOwnProperty(n, b, this);
}
break;
}
}, this);
},
_doBehavior: function (name, args) {
this.behaviors.forEach(function (b) {
this._invokeBehavior(b, name, args);
}, this);
this._invokeBehavior(this, name, args);
},
_invokeBehavior: function (b, name, args) {
var fn = b[name];
if (fn) {
fn.apply(this, args || Polymer.nar);
}
},
_marshalBehaviors: function () {
this.behaviors.forEach(function (b) {
this._marshalBehavior(b);
}, this);
this._marshalBehavior(this);
}
});

Polymer.Base._addFeature({
_prepExtends: function () {
if (this.extends) {
this.__proto__ = this._getExtendedPrototype(this.extends);
}
},
_getExtendedPrototype: function (tag) {
return this._getExtendedNativePrototype(tag);
},
_nativePrototypes: {},
_getExtendedNativePrototype: function (tag) {
var p = this._nativePrototypes[tag];
if (!p) {
var np = this.getNativePrototype(tag);
p = this.extend(Object.create(np), Polymer.Base);
this._nativePrototypes[tag] = p;
}
return p;
},
getNativePrototype: function (tag) {
return Object.getPrototypeOf(document.createElement(tag));
}
});

Polymer.Base._addFeature({
_prepConstructor: function () {
this._factoryArgs = this.extends ? [
this.extends,
this.is
] : [this.is];
var ctor = function () {
return this._factory(arguments);
};
if (this.hasOwnProperty('extends')) {
ctor.extends = this.extends;
}
Object.defineProperty(this, 'constructor', {
value: ctor,
writable: true,
configurable: true
});
ctor.prototype = this;
},
_factory: function (args) {
var elt = document.createElement.apply(document, this._factoryArgs);
if (this.factoryImpl) {
this.factoryImpl.apply(elt, args);
}
return elt;
}
});

Polymer.nob = Object.create(null);
Polymer.Base._addFeature({
properties: {},
getPropertyInfo: function (property) {
var info = this._getPropertyInfo(property, this.properties);
if (!info) {
this.behaviors.some(function (b) {
return info = this._getPropertyInfo(property, b.properties);
}, this);
}
return info || Polymer.nob;
},
_getPropertyInfo: function (property, properties) {
var p = properties && properties[property];
if (typeof p === 'function') {
p = properties[property] = { type: p };
}
if (p) {
p.defined = true;
}
return p;
}
});

Polymer.CaseMap = {
_caseMap: {},
dashToCamelCase: function (dash) {
var mapped = Polymer.CaseMap._caseMap[dash];
if (mapped) {
return mapped;
}
if (dash.indexOf('-') < 0) {
return Polymer.CaseMap._caseMap[dash] = dash;
}
return Polymer.CaseMap._caseMap[dash] = dash.replace(/-([a-z])/g, function (m) {
return m[1].toUpperCase();
});
},
camelToDashCase: function (camel) {
var mapped = Polymer.CaseMap._caseMap[camel];
if (mapped) {
return mapped;
}
return Polymer.CaseMap._caseMap[camel] = camel.replace(/([a-z][A-Z])/g, function (g) {
return g[0] + '-' + g[1].toLowerCase();
});
}
};

Polymer.Base._addFeature({
_prepAttributes: function () {
this._aggregatedAttributes = {};
},
_addHostAttributes: function (attributes) {
if (attributes) {
this.mixin(this._aggregatedAttributes, attributes);
}
},
_marshalHostAttributes: function () {
this._applyAttributes(this, this._aggregatedAttributes);
},
_applyAttributes: function (node, attr$) {
for (var n in attr$) {
if (!this.hasAttribute(n) && n !== 'class') {
this.serializeValueToAttribute(attr$[n], n, this);
}
}
},
_marshalAttributes: function () {
this._takeAttributesToModel(this);
},
_takeAttributesToModel: function (model) {
for (var i = 0, l = this.attributes.length; i < l; i++) {
this.setAttributeToProperty(model, this.attributes[i].name);
}
},
setAttributeToProperty: function (model, attrName) {
if (!this._serializing) {
var propName = Polymer.CaseMap.dashToCamelCase(attrName);
var info = this.getPropertyInfo(propName);
if (info.defined || this._propertyEffects && this._propertyEffects[propName]) {
var val = this.getAttribute(attrName);
model[propName] = this.deserialize(val, info.type);
}
}
},
_serializing: false,
reflectPropertyToAttribute: function (name) {
this._serializing = true;
this.serializeValueToAttribute(this[name], Polymer.CaseMap.camelToDashCase(name));
this._serializing = false;
},
serializeValueToAttribute: function (value, attribute, node) {
var str = this.serialize(value);
(node || this)[str === undefined ? 'removeAttribute' : 'setAttribute'](attribute, str);
},
deserialize: function (value, type) {
switch (type) {
case Number:
value = Number(value);
break;
case Boolean:
value = value !== null;
break;
case Object:
try {
value = JSON.parse(value);
} catch (x) {
}
break;
case Array:
try {
value = JSON.parse(value);
} catch (x) {
value = null;
console.warn('Polymer::Attributes: couldn`t decode Array as JSON');
}
break;
case Date:
value = new Date(value);
break;
case String:
default:
break;
}
return value;
},
serialize: function (value) {
switch (typeof value) {
case 'boolean':
return value ? '' : undefined;
case 'object':
if (value instanceof Date) {
return value;
} else if (value) {
try {
return JSON.stringify(value);
} catch (x) {
return '';
}
}
default:
return value != null ? value : undefined;
}
}
});

Polymer.Base._addFeature({
_setupDebouncers: function () {
this._debouncers = {};
},
debounce: function (jobName, callback, wait) {
this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);
},
isDebouncerActive: function (jobName) {
var debouncer = this._debouncers[jobName];
return debouncer && debouncer.finish;
},
flushDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.complete();
}
},
cancelDebouncer: function (jobName) {
var debouncer = this._debouncers[jobName];
if (debouncer) {
debouncer.stop();
}
}
});

Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepExtends();
this._prepConstructor();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_marshalBehavior: function (b) {
},
_initFeatures: function () {
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
}
});</script>

<script>Polymer.Base._addFeature({
_prepTemplate: function () {
this._template = this._template || Polymer.DomModule.import(this.is, 'template');
if (!this._template) {
var script = document._currentScript || document.currentScript;
var prev = script && script.previousElementSibling;
if (prev && prev.localName === 'template') {
this._template = prev;
}
}
},
_stampTemplate: function () {
if (this._template) {
this.root = this.instanceTemplate(this._template);
}
},
instanceTemplate: function (template) {
var dom = document.importNode(template._content || template.content, true);
return dom;
}
});

(function () {
var baseAttachedCallback = Polymer.Base.attachedCallback;
Polymer.Base._addFeature({
_hostStack: [],
ready: function () {
},
_pushHost: function (host) {
this.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];
if (host && host._clients) {
host._clients.push(this);
}
this._beginHost();
},
_beginHost: function () {
Polymer.Base._hostStack.push(this);
if (!this._clients) {
this._clients = [];
}
},
_popHost: function () {
Polymer.Base._hostStack.pop();
},
_tryReady: function () {
if (this._canReady()) {
this._ready();
}
},
_canReady: function () {
return !this.dataHost || this.dataHost._clientsReadied;
},
_ready: function () {
this._beforeClientsReady();
this._setupRoot();
this._readyClients();
this._afterClientsReady();
this._readySelf();
},
_readyClients: function () {
this._beginDistribute();
var c$ = this._clients;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._ready();
}
this._finishDistribute();
this._clientsReadied = true;
this._clients = null;
},
_readySelf: function () {
this._doBehavior('ready');
this._readied = true;
if (this._attachedPending) {
this._attachedPending = false;
this.attachedCallback();
}
},
_beforeClientsReady: function () {
},
_afterClientsReady: function () {
},
_beforeAttached: function () {
},
attachedCallback: function () {
if (this._readied) {
this._beforeAttached();
baseAttachedCallback.call(this);
} else {
this._attachedPending = true;
}
}
});
}());

Polymer.ArraySplice = function () {
function newSplice(index, removed, addedCount) {
return {
index: index,
removed: removed,
addedCount: addedCount
};
}
var EDIT_LEAVE = 0;
var EDIT_UPDATE = 1;
var EDIT_ADD = 2;
var EDIT_DELETE = 3;
function ArraySplice() {
}
ArraySplice.prototype = {
calcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var rowCount = oldEnd - oldStart + 1;
var columnCount = currentEnd - currentStart + 1;
var distances = new Array(rowCount);
for (var i = 0; i < rowCount; i++) {
distances[i] = new Array(columnCount);
distances[i][0] = i;
}
for (var j = 0; j < columnCount; j++)
distances[0][j] = j;
for (var i = 1; i < rowCount; i++) {
for (var j = 1; j < columnCount; j++) {
if (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))
distances[i][j] = distances[i - 1][j - 1];
else {
var north = distances[i - 1][j] + 1;
var west = distances[i][j - 1] + 1;
distances[i][j] = north < west ? north : west;
}
}
}
return distances;
},
spliceOperationsFromEditDistances: function (distances) {
var i = distances.length - 1;
var j = distances[0].length - 1;
var current = distances[i][j];
var edits = [];
while (i > 0 || j > 0) {
if (i == 0) {
edits.push(EDIT_ADD);
j--;
continue;
}
if (j == 0) {
edits.push(EDIT_DELETE);
i--;
continue;
}
var northWest = distances[i - 1][j - 1];
var west = distances[i - 1][j];
var north = distances[i][j - 1];
var min;
if (west < north)
min = west < northWest ? west : northWest;
else
min = north < northWest ? north : northWest;
if (min == northWest) {
if (northWest == current) {
edits.push(EDIT_LEAVE);
} else {
edits.push(EDIT_UPDATE);
current = northWest;
}
i--;
j--;
} else if (min == west) {
edits.push(EDIT_DELETE);
i--;
current = west;
} else {
edits.push(EDIT_ADD);
j--;
current = north;
}
}
edits.reverse();
return edits;
},
calcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {
var prefixCount = 0;
var suffixCount = 0;
var minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
if (currentStart == 0 && oldStart == 0)
prefixCount = this.sharedPrefix(current, old, minLength);
if (currentEnd == current.length && oldEnd == old.length)
suffixCount = this.sharedSuffix(current, old, minLength - prefixCount);
currentStart += prefixCount;
oldStart += prefixCount;
currentEnd -= suffixCount;
oldEnd -= suffixCount;
if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
return [];
if (currentStart == currentEnd) {
var splice = newSplice(currentStart, [], 0);
while (oldStart < oldEnd)
splice.removed.push(old[oldStart++]);
return [splice];
} else if (oldStart == oldEnd)
return [newSplice(currentStart, [], currentEnd - currentStart)];
var ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
var splice = undefined;
var splices = [];
var index = currentStart;
var oldIndex = oldStart;
for (var i = 0; i < ops.length; i++) {
switch (ops[i]) {
case EDIT_LEAVE:
if (splice) {
splices.push(splice);
splice = undefined;
}
index++;
oldIndex++;
break;
case EDIT_UPDATE:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
case EDIT_ADD:
if (!splice)
splice = newSplice(index, [], 0);
splice.addedCount++;
index++;
break;
case EDIT_DELETE:
if (!splice)
splice = newSplice(index, [], 0);
splice.removed.push(old[oldIndex]);
oldIndex++;
break;
}
}
if (splice) {
splices.push(splice);
}
return splices;
},
sharedPrefix: function (current, old, searchLength) {
for (var i = 0; i < searchLength; i++)
if (!this.equals(current[i], old[i]))
return i;
return searchLength;
},
sharedSuffix: function (current, old, searchLength) {
var index1 = current.length;
var index2 = old.length;
var count = 0;
while (count < searchLength && this.equals(current[--index1], old[--index2]))
count++;
return count;
},
calculateSplices: function (current, previous) {
return this.calcSplices(current, 0, current.length, previous, 0, previous.length);
},
equals: function (currentValue, previousValue) {
return currentValue === previousValue;
}
};
return new ArraySplice();
}();

Polymer.EventApi = function () {
var Settings = Polymer.Settings;
var EventApi = function (event) {
this.event = event;
};
if (Settings.useShadow) {
EventApi.prototype = {
get rootTarget() {
return this.event.path[0];
},
get localTarget() {
return this.event.target;
},
get path() {
return this.event.path;
}
};
} else {
EventApi.prototype = {
get rootTarget() {
return this.event.target;
},
get localTarget() {
var current = this.event.currentTarget;
var currentRoot = current && Polymer.dom(current).getOwnerRoot();
var p$ = this.path;
for (var i = 0; i < p$.length; i++) {
if (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {
return p$[i];
}
}
},
get path() {
if (!this.event._path) {
var path = [];
var o = this.rootTarget;
while (o) {
path.push(o);
o = Polymer.dom(o).parentNode || o.host;
}
path.push(window);
this.event._path = path;
}
return this.event._path;
}
};
}
var factory = function (event) {
if (!event.__eventApi) {
event.__eventApi = new EventApi(event);
}
return event.__eventApi;
};
return { factory: factory };
}();

Polymer.domInnerHTML = function () {
var escapeAttrRegExp = /[&\u00A0"]/g;
var escapeDataRegExp = /[&\u00A0<>]/g;
function escapeReplace(c) {
switch (c) {
case '&':
return '&amp;';
case '<':
return '&lt;';
case '>':
return '&gt;';
case '"':
return '&quot;';
case '\xA0':
return '&nbsp;';
}
}
function escapeAttr(s) {
return s.replace(escapeAttrRegExp, escapeReplace);
}
function escapeData(s) {
return s.replace(escapeDataRegExp, escapeReplace);
}
function makeSet(arr) {
var set = {};
for (var i = 0; i < arr.length; i++) {
set[arr[i]] = true;
}
return set;
}
var voidElements = makeSet([
'area',
'base',
'br',
'col',
'command',
'embed',
'hr',
'img',
'input',
'keygen',
'link',
'meta',
'param',
'source',
'track',
'wbr'
]);
var plaintextParents = makeSet([
'style',
'script',
'xmp',
'iframe',
'noembed',
'noframes',
'plaintext',
'noscript'
]);
function getOuterHTML(node, parentNode, composed) {
switch (node.nodeType) {
case Node.ELEMENT_NODE:
var tagName = node.localName;
var s = '<' + tagName;
var attrs = node.attributes;
for (var i = 0, attr; attr = attrs[i]; i++) {
s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
}
s += '>';
if (voidElements[tagName]) {
return s;
}
return s + getInnerHTML(node, composed) + '</' + tagName + '>';
case Node.TEXT_NODE:
var data = node.data;
if (parentNode && plaintextParents[parentNode.localName]) {
return data;
}
return escapeData(data);
case Node.COMMENT_NODE:
return '<!--' + node.data + '-->';
default:
console.error(node);
throw new Error('not implemented');
}
}
function getInnerHTML(node, composed) {
if (node instanceof HTMLTemplateElement)
node = node.content;
var s = '';
var c$ = Polymer.dom(node).childNodes;
c$ = composed ? node._composedChildren : c$;
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
s += getOuterHTML(child, node, composed);
}
return s;
}
return { getInnerHTML: getInnerHTML };
}();

Polymer.DomApi = function () {
'use strict';
var Settings = Polymer.Settings;
var getInnerHTML = Polymer.domInnerHTML.getInnerHTML;
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
var nativeAppendChild = Element.prototype.appendChild;
var dirtyRoots = [];
var DomApi = function (node) {
this.node = node;
if (this.patch) {
this.patch();
}
};
DomApi.prototype = {
flush: function () {
for (var i = 0, host; i < dirtyRoots.length; i++) {
host = dirtyRoots[i];
host.flushDebouncer('_distribute');
}
dirtyRoots = [];
},
_lazyDistribute: function (host) {
if (host.shadyRoot && host.shadyRoot._distributionClean) {
host.shadyRoot._distributionClean = false;
host.debounce('_distribute', host._distributeContent);
dirtyRoots.push(host);
}
},
appendChild: function (node) {
var distributed;
this._removeNodeFromHost(node);
if (this._nodeIsInLogicalTree(this.node)) {
var host = this._hostForNode(this.node);
this._addLogicalInfo(node, this.node, host && host.shadyRoot);
this._addNodeToHost(node);
if (host) {
distributed = this._maybeDistribute(node, this.node, host);
}
}
if (!distributed && !this._tryRemoveUndistributedNode(node)) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
nativeAppendChild.call(container, node);
addToComposedParent(container, node);
}
return node;
},
insertBefore: function (node, ref_node) {
if (!ref_node) {
return this.appendChild(node);
}
var distributed;
this._removeNodeFromHost(node);
if (this._nodeIsInLogicalTree(this.node)) {
saveLightChildrenIfNeeded(this.node);
var children = this.childNodes;
var index = children.indexOf(ref_node);
if (index < 0) {
throw Error('The ref_node to be inserted before is not a child ' + 'of this node');
}
var host = this._hostForNode(this.node);
this._addLogicalInfo(node, this.node, host && host.shadyRoot, index);
this._addNodeToHost(node);
if (host) {
distributed = this._maybeDistribute(node, this.node, host);
}
}
if (!distributed && !this._tryRemoveUndistributedNode(node)) {
ref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;
var container = this.node._isShadyRoot ? this.node.host : this.node;
nativeInsertBefore.call(container, node, ref_node);
addToComposedParent(container, node, ref_node);
}
return node;
},
removeChild: function (node) {
if (factory(node).parentNode !== this.node) {
console.warn('The node to be removed is not a child of this node', node);
}
var distributed;
if (this._nodeIsInLogicalTree(this.node)) {
var host = this._hostForNode(this.node);
distributed = this._maybeDistribute(node, this.node, host);
this._removeNodeFromHost(node);
}
if (!distributed) {
var container = this.node._isShadyRoot ? this.node.host : this.node;
if (container === node.parentNode) {
nativeRemoveChild.call(container, node);
removeFromComposedParent(container, node);
}
}
return node;
},
replaceChild: function (node, ref_node) {
this.insertBefore(node, ref_node);
this.removeChild(ref_node);
return node;
},
getOwnerRoot: function () {
return this._ownerShadyRootForNode(this.node);
},
_ownerShadyRootForNode: function (node) {
if (!node) {
return;
}
if (node._ownerShadyRoot === undefined) {
var root;
if (node._isShadyRoot) {
root = node;
} else {
var parent = Polymer.dom(node).parentNode;
if (parent) {
root = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);
} else {
root = null;
}
}
node._ownerShadyRoot = root;
}
return node._ownerShadyRoot;
},
_maybeDistribute: function (node, parent, host) {
var nodeNeedsDistribute = this._nodeNeedsDistribution(node);
var distribute = this._parentNeedsDistribution(parent) || nodeNeedsDistribute;
if (nodeNeedsDistribute) {
this._updateInsertionPoints(host);
}
if (distribute) {
this._lazyDistribute(host);
}
return distribute;
},
_tryRemoveUndistributedNode: function (node) {
if (this.node.shadyRoot) {
if (node.parentNode) {
nativeRemoveChild.call(node.parentNode, node);
}
return true;
}
},
_updateInsertionPoints: function (host) {
host.shadyRoot._insertionPoints = factory(host.shadyRoot).querySelectorAll(CONTENT);
},
_nodeIsInLogicalTree: function (node) {
return Boolean(node._lightParent || node._isShadyRoot || this._ownerShadyRootForNode(node) || node.shadyRoot);
},
_hostForNode: function (node) {
var root = node.shadyRoot || (node._isShadyRoot ? node : this._ownerShadyRootForNode(node));
return root && root.host;
},
_parentNeedsDistribution: function (parent) {
return parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot);
},
_nodeNeedsDistribution: function (node) {
return node.localName === CONTENT || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && node.querySelector(CONTENT);
},
_removeNodeFromHost: function (node) {
if (node._lightParent) {
var root = this._ownerShadyRootForNode(node);
if (root) {
root.host._elementRemove(node);
}
this._removeLogicalInfo(node, node._lightParent);
}
this._removeOwnerShadyRoot(node);
},
_addNodeToHost: function (node) {
var checkNode = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? node.firstChild : node;
var root = this._ownerShadyRootForNode(checkNode);
if (root) {
root.host._elementAdd(node);
}
},
_addLogicalInfo: function (node, container, root, index) {
saveLightChildrenIfNeeded(container);
var children = factory(container).childNodes;
index = index === undefined ? children.length : index;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, n; i < c$.length && (n = c$[i]); i++) {
children.splice(index++, 0, n);
n._lightParent = container;
}
} else {
children.splice(index, 0, node);
node._lightParent = container;
}
},
_removeLogicalInfo: function (node, container) {
var children = factory(container).childNodes;
var index = children.indexOf(node);
if (index < 0 || container !== node._lightParent) {
throw Error('The node to be removed is not a child of this node');
}
children.splice(index, 1);
node._lightParent = null;
},
_removeOwnerShadyRoot: function (node) {
var hasCachedRoot = factory(node).getOwnerRoot() !== undefined;
if (hasCachedRoot) {
var c$ = factory(node).childNodes;
for (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {
this._removeOwnerShadyRoot(n);
}
}
node._ownerShadyRoot = undefined;
},
_firstComposedNode: function (content) {
var n$ = factory(content).getDistributedNodes();
for (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {
p$ = factory(n).getDestinationInsertionPoints();
if (p$[p$.length - 1] === content) {
return n;
}
}
},
querySelector: function (selector) {
return this.querySelectorAll(selector)[0];
},
querySelectorAll: function (selector) {
return this._query(function (n) {
return matchesSelector.call(n, selector);
}, this.node);
},
_query: function (matcher, node) {
node = node || this.node;
var list = [];
this._queryElements(factory(node).childNodes, matcher, list);
return list;
},
_queryElements: function (elements, matcher, list) {
for (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {
if (c.nodeType === Node.ELEMENT_NODE) {
this._queryElement(c, matcher, list);
}
}
},
_queryElement: function (node, matcher, list) {
if (matcher(node)) {
list.push(node);
}
this._queryElements(factory(node).childNodes, matcher, list);
},
getDestinationInsertionPoints: function () {
return this.node._destinationInsertionPoints || [];
},
getDistributedNodes: function () {
return this.node._distributedNodes || [];
},
queryDistributedElements: function (selector) {
var c$ = this.childNodes;
var list = [];
this._distributedFilter(selector, c$, list);
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.localName === CONTENT) {
this._distributedFilter(selector, factory(c).getDistributedNodes(), list);
}
}
return list;
},
_distributedFilter: function (selector, list, results) {
results = results || [];
for (var i = 0, l = list.length, d; i < l && (d = list[i]); i++) {
if (d.nodeType === Node.ELEMENT_NODE && d.localName !== CONTENT && matchesSelector.call(d, selector)) {
results.push(d);
}
}
return results;
},
_clear: function () {
while (this.childNodes.length) {
this.removeChild(this.childNodes[0]);
}
},
setAttribute: function (name, value) {
this.node.setAttribute(name, value);
this._distributeParent();
},
removeAttribute: function (name) {
this.node.removeAttribute(name);
this._distributeParent();
},
_distributeParent: function () {
if (this._parentNeedsDistribution(this.parentNode)) {
this._lazyDistribute(this.parentNode);
}
}
};
Object.defineProperty(DomApi.prototype, 'classList', {
get: function () {
if (!this._classList) {
this._classList = new DomApi.ClassList(this);
}
return this._classList;
},
configurable: true
});
DomApi.ClassList = function (host) {
this.domApi = host;
this.node = host.node;
};
DomApi.ClassList.prototype = {
add: function () {
this.node.classList.add.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
remove: function () {
this.node.classList.remove.apply(this.node.classList, arguments);
this.domApi._distributeParent();
},
toggle: function () {
this.node.classList.toggle.apply(this.node.classList, arguments);
this.domApi._distributeParent();
}
};
if (!Settings.useShadow) {
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
var c$ = getLightChildren(this.node);
return Array.isArray(c$) ? c$ : Array.prototype.slice.call(c$);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.filter.call(this.childNodes, function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
configurable: true
},
parentNode: {
get: function () {
return this.node._lightParent || (this.node.__patched ? this.node._composedParent : this.node.parentNode);
},
configurable: true
},
firstChild: {
get: function () {
return this.childNodes[0];
},
configurable: true
},
lastChild: {
get: function () {
var c$ = this.childNodes;
return c$[c$.length - 1];
},
configurable: true
},
nextSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).childNodes;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
firstElementChild: {
get: function () {
return this.children[0];
},
configurable: true
},
lastElementChild: {
get: function () {
var c$ = this.children;
return c$[c$.length - 1];
},
configurable: true
},
nextElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) + 1];
}
},
configurable: true
},
previousElementSibling: {
get: function () {
var c$ = this.parentNode && factory(this.parentNode).children;
if (c$) {
return c$[Array.prototype.indexOf.call(c$, this.node) - 1];
}
},
configurable: true
},
textContent: {
get: function () {
if (this.node.nodeType === Node.TEXT_NODE) {
return this.node.textContent;
} else {
return Array.prototype.map.call(this.childNodes, function (c) {
return c.textContent;
}).join('');
}
},
set: function (text) {
this._clear();
if (text) {
this.appendChild(document.createTextNode(text));
}
},
configurable: true
},
innerHTML: {
get: function () {
if (this.node.nodeType === Node.TEXT_NODE) {
return null;
} else {
return getInnerHTML(this.node);
}
},
set: function (text) {
if (this.node.nodeType !== Node.TEXT_NODE) {
this._clear();
var d = document.createElement('div');
d.innerHTML = text;
for (var e = d.firstChild; e; e = e.nextSibling) {
this.appendChild(e);
}
}
},
configurable: true
}
});
DomApi.prototype._getComposedInnerHTML = function () {
return getInnerHTML(this.node, true);
};
} else {
DomApi.prototype.querySelectorAll = function (selector) {
return Array.prototype.slice.call(this.node.querySelectorAll(selector));
};
DomApi.prototype.getOwnerRoot = function () {
var n = this.node;
while (n) {
if (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {
return n;
}
n = n.parentNode;
}
};
DomApi.prototype.getDestinationInsertionPoints = function () {
var n$ = this.node.getDestinationInsertionPoints();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype.getDistributedNodes = function () {
var n$ = this.node.getDistributedNodes();
return n$ ? Array.prototype.slice.call(n$) : [];
};
DomApi.prototype._distributeParent = function () {
};
Object.defineProperties(DomApi.prototype, {
childNodes: {
get: function () {
return Array.prototype.slice.call(this.node.childNodes);
},
configurable: true
},
children: {
get: function () {
return Array.prototype.slice.call(this.node.children);
},
configurable: true
},
textContent: {
get: function () {
return this.node.textContent;
},
set: function (value) {
return this.node.textContent = value;
},
configurable: true
},
innerHTML: {
get: function () {
return this.node.innerHTML;
},
set: function (value) {
return this.node.innerHTML = value;
},
configurable: true
}
});
var forwards = [
'parentNode',
'firstChild',
'lastChild',
'nextSibling',
'previousSibling',
'firstElementChild',
'lastElementChild',
'nextElementSibling',
'previousElementSibling'
];
forwards.forEach(function (name) {
Object.defineProperty(DomApi.prototype, name, {
get: function () {
return this.node[name];
},
configurable: true
});
});
}
var CONTENT = 'content';
var factory = function (node, patch) {
node = node || document;
if (!node.__domApi) {
node.__domApi = new DomApi(node, patch);
}
return node.__domApi;
};
Polymer.dom = function (obj, patch) {
if (obj instanceof Event) {
return Polymer.EventApi.factory(obj);
} else {
return factory(obj, patch);
}
};
Polymer.dom.flush = DomApi.prototype.flush;
function getLightChildren(node) {
var children = node._lightChildren;
return children ? children : node.childNodes;
}
function getComposedChildren(node) {
if (!node._composedChildren) {
node._composedChildren = Array.prototype.slice.call(node.childNodes);
}
return node._composedChildren;
}
function addToComposedParent(parent, node, ref_node) {
var children = getComposedChildren(parent);
var i = ref_node ? children.indexOf(ref_node) : -1;
if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
var fragChildren = getComposedChildren(node);
fragChildren.forEach(function (c) {
addNodeToComposedChildren(c, parent, children, i);
});
} else {
addNodeToComposedChildren(node, parent, children, i);
}
}
function addNodeToComposedChildren(node, parent, children, i) {
node._composedParent = parent;
if (i >= 0) {
children.splice(i, 0, node);
} else {
children.push(node);
}
}
function removeFromComposedParent(parent, node) {
node._composedParent = null;
if (parent) {
var children = getComposedChildren(parent);
var i = children.indexOf(node);
if (i >= 0) {
children.splice(i, 1);
}
}
}
function saveLightChildrenIfNeeded(node) {
if (!node._lightChildren) {
var c$ = Array.prototype.slice.call(node.childNodes);
for (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
child._lightParent = child._lightParent || node;
}
node._lightChildren = c$;
}
}
function hasInsertionPoint(root) {
return Boolean(root._insertionPoints.length);
}
var p = Element.prototype;
var matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;
return {
getLightChildren: getLightChildren,
getComposedChildren: getComposedChildren,
removeFromComposedParent: removeFromComposedParent,
saveLightChildrenIfNeeded: saveLightChildrenIfNeeded,
matchesSelector: matchesSelector,
hasInsertionPoint: hasInsertionPoint,
ctor: DomApi,
factory: factory
};
}();

(function () {
Polymer.Base._addFeature({
_prepShady: function () {
this._useContent = this._useContent || Boolean(this._template);
if (this._useContent) {
this._template._hasInsertionPoint = this._template.content.querySelector('content');
}
},
_poolContent: function () {
if (this._useContent) {
saveLightChildrenIfNeeded(this);
}
},
_setupRoot: function () {
if (this._useContent) {
this._createLocalRoot();
if (!this.dataHost) {
upgradeLightChildren(this._lightChildren);
}
}
},
_createLocalRoot: function () {
this.shadyRoot = this.root;
this.shadyRoot._distributionClean = false;
this.shadyRoot._isShadyRoot = true;
this.shadyRoot._dirtyRoots = [];
this.shadyRoot._insertionPoints = this._template._hasInsertionPoint ? this.shadyRoot.querySelectorAll('content') : [];
saveLightChildrenIfNeeded(this.shadyRoot);
this.shadyRoot.host = this;
},
get domHost() {
var root = Polymer.dom(this).getOwnerRoot();
return root && root.host;
},
distributeContent: function () {
if (this.shadyRoot) {
var host = getTopDistributingHost(this);
Polymer.dom(this)._lazyDistribute(host);
}
},
_distributeContent: function () {
if (this._useContent && !this.shadyRoot._distributionClean) {
this._beginDistribute();
this._distributeDirtyRoots();
this._finishDistribute();
}
},
_beginDistribute: function () {
if (this._useContent && hasInsertionPoint(this.shadyRoot)) {
this._resetDistribution();
this._distributePool(this.shadyRoot, this._collectPool());
}
},
_distributeDirtyRoots: function () {
var c$ = this.shadyRoot._dirtyRoots;
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
c._distributeContent();
}
this.shadyRoot._dirtyRoots = [];
},
_finishDistribute: function () {
if (this._useContent) {
if (hasInsertionPoint(this.shadyRoot)) {
this._composeTree();
} else {
if (!this.shadyRoot._hasDistributed) {
this.textContent = '';
this.appendChild(this.shadyRoot);
} else {
var children = this._composeNode(this);
this._updateChildNodes(this, children);
}
}
this.shadyRoot._hasDistributed = true;
this.shadyRoot._distributionClean = true;
}
},
elementMatches: function (selector, node) {
node = node || this;
return matchesSelector.call(node, selector);
},
_resetDistribution: function () {
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (child._destinationInsertionPoints) {
child._destinationInsertionPoints = undefined;
}
if (isInsertionPoint(child)) {
clearDistributedDestinationInsertionPoints(child);
}
}
var root = this.shadyRoot;
var p$ = root._insertionPoints;
for (var j = 0; j < p$.length; j++) {
p$[j]._distributedNodes = [];
}
},
_collectPool: function () {
var pool = [];
var children = getLightChildren(this);
for (var i = 0; i < children.length; i++) {
var child = children[i];
if (isInsertionPoint(child)) {
pool.push.apply(pool, child._distributedNodes);
} else {
pool.push(child);
}
}
return pool;
},
_distributePool: function (node, pool) {
var p$ = node._insertionPoints;
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
this._distributeInsertionPoint(p, pool);
maybeRedistributeParent(p, this);
}
},
_distributeInsertionPoint: function (content, pool) {
var anyDistributed = false;
for (var i = 0, l = pool.length, node; i < l; i++) {
node = pool[i];
if (!node) {
continue;
}
if (this._matchesContentSelect(node, content)) {
distributeNodeInto(node, content);
pool[i] = undefined;
anyDistributed = true;
}
}
if (!anyDistributed) {
var children = getLightChildren(content);
for (var j = 0; j < children.length; j++) {
distributeNodeInto(children[j], content);
}
}
},
_composeTree: function () {
this._updateChildNodes(this, this._composeNode(this));
var p$ = this.shadyRoot._insertionPoints;
for (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {
parent = p._lightParent || p.parentNode;
if (!parent._useContent && parent !== this && parent !== this.shadyRoot) {
this._updateChildNodes(parent, this._composeNode(parent));
}
}
},
_composeNode: function (node) {
var children = [];
var c$ = getLightChildren(node.shadyRoot || node);
for (var i = 0; i < c$.length; i++) {
var child = c$[i];
if (isInsertionPoint(child)) {
var distributedNodes = child._distributedNodes;
for (var j = 0; j < distributedNodes.length; j++) {
var distributedNode = distributedNodes[j];
if (isFinalDestination(child, distributedNode)) {
children.push(distributedNode);
}
}
} else {
children.push(child);
}
}
return children;
},
_updateChildNodes: function (container, children) {
var composed = getComposedChildren(container);
var splices = Polymer.ArraySplice.calculateSplices(children, composed);
for (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
for (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
remove(n);
composed.splice(s.index + d, 1);
}
d -= s.addedCount;
}
for (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
next = composed[s.index];
for (var j = s.index, n; j < s.index + s.addedCount; j++) {
n = children[j];
insertBefore(container, n, next);
composed.splice(j, 0, n);
}
}
},
_matchesContentSelect: function (node, contentElement) {
var select = contentElement.getAttribute('select');
if (!select) {
return true;
}
select = select.trim();
if (!select) {
return true;
}
if (!(node instanceof Element)) {
return false;
}
var validSelectors = /^(:not\()?[*.#[a-zA-Z_|]/;
if (!validSelectors.test(select)) {
return false;
}
return this.elementMatches(select, node);
},
_elementAdd: function () {
},
_elementRemove: function () {
}
});
var saveLightChildrenIfNeeded = Polymer.DomApi.saveLightChildrenIfNeeded;
var getLightChildren = Polymer.DomApi.getLightChildren;
var matchesSelector = Polymer.DomApi.matchesSelector;
var hasInsertionPoint = Polymer.DomApi.hasInsertionPoint;
var getComposedChildren = Polymer.DomApi.getComposedChildren;
var removeFromComposedParent = Polymer.DomApi.removeFromComposedParent;
function distributeNodeInto(child, insertionPoint) {
insertionPoint._distributedNodes.push(child);
var points = child._destinationInsertionPoints;
if (!points) {
child._destinationInsertionPoints = [insertionPoint];
} else {
points.push(insertionPoint);
}
}
function clearDistributedDestinationInsertionPoints(content) {
var e$ = content._distributedNodes;
for (var i = 0; i < e$.length; i++) {
var d = e$[i]._destinationInsertionPoints;
if (d) {
d.splice(d.indexOf(content) + 1, d.length);
}
}
}
function maybeRedistributeParent(content, host) {
var parent = content._lightParent;
if (parent && parent.shadyRoot && hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {
parent.shadyRoot._distributionClean = false;
host.shadyRoot._dirtyRoots.push(parent);
}
}
function isFinalDestination(insertionPoint, node) {
var points = node._destinationInsertionPoints;
return points && points[points.length - 1] === insertionPoint;
}
function isInsertionPoint(node) {
return node.localName == 'content';
}
var nativeInsertBefore = Element.prototype.insertBefore;
var nativeRemoveChild = Element.prototype.removeChild;
function insertBefore(parentNode, newChild, refChild) {
var newChildParent = getComposedParent(newChild);
if (newChildParent !== parentNode) {
removeFromComposedParent(newChildParent, newChild);
}
remove(newChild);
saveLightChildrenIfNeeded(parentNode);
nativeInsertBefore.call(parentNode, newChild, refChild || null);
newChild._composedParent = parentNode;
}
function remove(node) {
var parentNode = getComposedParent(node);
if (parentNode) {
saveLightChildrenIfNeeded(parentNode);
node._composedParent = null;
nativeRemoveChild.call(parentNode, node);
}
}
function getComposedParent(node) {
return node.__patched ? node._composedParent : node.parentNode;
}
function getTopDistributingHost(host) {
while (host && hostNeedsRedistribution(host)) {
host = host.domHost;
}
return host;
}
function hostNeedsRedistribution(host) {
var c$ = Polymer.dom(host).children;
for (var i = 0, c; i < c$.length; i++) {
c = c$[i];
if (c.localName === 'content') {
return host.domHost;
}
}
}
var needsUpgrade = window.CustomElements && !CustomElements.useNative;
function upgradeLightChildren(children) {
if (needsUpgrade && children) {
for (var i = 0; i < children.length; i++) {
CustomElements.upgrade(children[i]);
}
}
}
}());

if (Polymer.Settings.useShadow) {
Polymer.Base._addFeature({
_poolContent: function () {
},
_beginDistribute: function () {
},
distributeContent: function () {
},
_distributeContent: function () {
},
_finishDistribute: function () {
},
_createLocalRoot: function () {
this.createShadowRoot();
this.shadowRoot.appendChild(this.root);
this.root = this.shadowRoot;
}
});
}

Polymer.DomModule = document.createElement('dom-module');
Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepBehaviors();
this._prepExtends();
this._prepConstructor();
this._prepTemplate();
this._prepShady();
},
_prepBehavior: function (b) {
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalBehaviors();
this._tryReady();
},
_marshalBehavior: function (b) {
}
});</script>

<script>Polymer.nar = [];
Polymer.Annotations = {
parseAnnotations: function (template) {
var list = [];
var content = template._content || template.content;
this._parseNodeAnnotations(content, list);
return list;
},
_parseNodeAnnotations: function (node, list) {
return node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list);
},
_testEscape: function (value) {
var escape = value.slice(0, 2);
if (escape === '{{' || escape === '[[') {
return escape;
}
},
_parseTextNodeAnnotation: function (node, list) {
var v = node.textContent;
var escape = this._testEscape(v);
if (escape) {
node.textContent = ' ';
var annote = {
bindings: [{
kind: 'text',
mode: escape[0],
value: v.slice(2, -2).trim()
}]
};
list.push(annote);
return annote;
}
},
_parseElementAnnotations: function (element, list) {
var annote = {
bindings: [],
events: []
};
this._parseChildNodesAnnotations(element, annote, list);
if (element.attributes) {
this._parseNodeAttributeAnnotations(element, annote, list);
if (this.prepElement) {
this.prepElement(element);
}
}
if (annote.bindings.length || annote.events.length || annote.id) {
list.push(annote);
}
return annote;
},
_parseChildNodesAnnotations: function (root, annote, list, callback) {
if (root.firstChild) {
for (var i = 0, node = root.firstChild; node; node = node.nextSibling, i++) {
if (node.localName === 'template' && !node.hasAttribute('preserve-content')) {
this._parseTemplate(node, i, list, annote);
}
var childAnnotation = this._parseNodeAnnotations(node, list, callback);
if (childAnnotation) {
childAnnotation.parent = annote;
childAnnotation.index = i;
}
}
}
},
_parseTemplate: function (node, index, list, parent) {
var content = document.createDocumentFragment();
content._notes = this.parseAnnotations(node);
content.appendChild(node.content);
list.push({
bindings: Polymer.nar,
events: Polymer.nar,
templateContent: content,
parent: parent,
index: index
});
},
_parseNodeAttributeAnnotations: function (node, annotation) {
for (var i = node.attributes.length - 1, a; a = node.attributes[i]; i--) {
var n = a.name, v = a.value;
if (n === 'id' && !this._testEscape(v)) {
annotation.id = v;
} else if (n.slice(0, 3) === 'on-') {
node.removeAttribute(n);
annotation.events.push({
name: n.slice(3),
value: v
});
} else {
var b = this._parseNodeAttributeAnnotation(node, n, v);
if (b) {
annotation.bindings.push(b);
}
}
}
},
_parseNodeAttributeAnnotation: function (node, n, v) {
var escape = this._testEscape(v);
if (escape) {
var customEvent;
var name = n;
var mode = escape[0];
v = v.slice(2, -2).trim();
var not = false;
if (v[0] == '!') {
v = v.substring(1);
not = true;
}
var kind = 'property';
if (n[n.length - 1] == '$') {
name = n.slice(0, -1);
kind = 'attribute';
}
var notifyEvent, colon;
if (mode == '{' && (colon = v.indexOf('::')) > 0) {
notifyEvent = v.substring(colon + 2);
v = v.substring(0, colon);
customEvent = true;
}
if (node.localName == 'input' && n == 'value') {
node.setAttribute(n, '');
}
node.removeAttribute(n);
if (kind === 'property') {
name = Polymer.CaseMap.dashToCamelCase(name);
}
return {
kind: kind,
mode: mode,
name: name,
value: v,
negate: not,
event: notifyEvent,
customEvent: customEvent
};
}
},
_localSubTree: function (node, host) {
return node === host ? node.childNodes : node._lightChildren || node.childNodes;
},
findAnnotatedNode: function (root, annote) {
var parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);
return !parent ? root : Polymer.Annotations._localSubTree(parent, root)[annote.index];
}
};

(function () {
function resolveCss(cssText, ownerDocument) {
return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
return pre + '\'' + resolve(url.replace(/["']/g, ''), ownerDocument) + '\'' + post;
});
}
function resolveAttrs(element, ownerDocument) {
for (var name in URL_ATTRS) {
var a$ = URL_ATTRS[name];
for (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {
if (name === '*' || element.localName === name) {
at = element.attributes[a];
v = at && at.value;
if (v && v.search(BINDING_RX) < 0) {
at.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);
}
}
}
}
}
function resolve(url, ownerDocument) {
var resolver = getUrlResolver(ownerDocument);
resolver.href = url;
return resolver.href || url;
}
var tempDoc;
var tempDocBase;
function resolveUrl(url, baseUri) {
if (!tempDoc) {
tempDoc = document.implementation.createHTMLDocument('temp');
tempDocBase = tempDoc.createElement('base');
tempDoc.head.appendChild(tempDocBase);
}
tempDocBase.href = baseUri;
return resolve(url, tempDoc);
}
function getUrlResolver(ownerDocument) {
return ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));
}
var CSS_URL_RX = /(url\()([^)]*)(\))/g;
var URL_ATTRS = {
'*': [
'href',
'src',
'style',
'url'
],
form: ['action']
};
var BINDING_RX = /\{\{|\[\[/;
Polymer.ResolveUrl = {
resolveCss: resolveCss,
resolveAttrs: resolveAttrs,
resolveUrl: resolveUrl
};
}());

Polymer.Base._addFeature({
_prepAnnotations: function () {
if (!this._template) {
this._notes = [];
} else {
Polymer.Annotations.prepElement = this._prepElement.bind(this);
this._notes = Polymer.Annotations.parseAnnotations(this._template);
this._processAnnotations(this._notes);
Polymer.Annotations.prepElement = null;
}
},
_processAnnotations: function (notes) {
for (var i = 0; i < notes.length; i++) {
var note = notes[i];
for (var j = 0; j < note.bindings.length; j++) {
var b = note.bindings[j];
b.signature = this._parseMethod(b.value);
if (!b.signature) {
b.model = this._modelForPath(b.value);
}
}
if (note.templateContent) {
this._processAnnotations(note.templateContent._notes);
var pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);
var bindings = [];
for (var prop in pp) {
bindings.push({
index: note.index,
kind: 'property',
mode: '{',
name: '_parent_' + prop,
model: prop,
value: prop
});
}
note.bindings = note.bindings.concat(bindings);
}
}
},
_discoverTemplateParentProps: function (notes) {
var pp = {};
notes.forEach(function (n) {
n.bindings.forEach(function (b) {
if (b.signature) {
var args = b.signature.args;
for (var k = 0; k < args.length; k++) {
pp[args[k].model] = true;
}
} else {
pp[b.model] = true;
}
});
if (n.templateContent) {
var tpp = n.templateContent._parentProps;
Polymer.Base.mixin(pp, tpp);
}
});
return pp;
},
_prepElement: function (element) {
Polymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);
},
_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,
_marshalAnnotationReferences: function () {
if (this._template) {
this._marshalIdNodes();
this._marshalAnnotatedNodes();
this._marshalAnnotatedListeners();
}
},
_configureAnnotationReferences: function () {
this._configureTemplateContent();
},
_configureTemplateContent: function () {
this._notes.forEach(function (note, i) {
if (note.templateContent) {
this._nodes[i]._content = note.templateContent;
}
}, this);
},
_marshalIdNodes: function () {
this.$ = {};
this._notes.forEach(function (a) {
if (a.id) {
this.$[a.id] = this._findAnnotatedNode(this.root, a);
}
}, this);
},
_marshalAnnotatedNodes: function () {
if (this._nodes) {
this._nodes = this._nodes.map(function (a) {
return this._findAnnotatedNode(this.root, a);
}, this);
}
},
_marshalAnnotatedListeners: function () {
this._notes.forEach(function (a) {
if (a.events && a.events.length) {
var node = this._findAnnotatedNode(this.root, a);
a.events.forEach(function (e) {
this.listen(node, e.name, e.value);
}, this);
}
}, this);
}
});

Polymer.Base._addFeature({
listeners: {},
_listenListeners: function (listeners) {
var node, name, key;
for (key in listeners) {
if (key.indexOf('.') < 0) {
node = this;
name = key;
} else {
name = key.split('.');
node = this.$[name[0]];
name = name[1];
}
this.listen(node, name, listeners[key]);
}
},
listen: function (node, eventName, methodName) {
this._listen(node, eventName, this._createEventHandler(node, eventName, methodName));
},
_createEventHandler: function (node, eventName, methodName) {
var host = this;
return function (e) {
if (host[methodName]) {
host[methodName](e, e.detail);
} else {
console.warn('[%s]: event handler [%s] is null in scope (%o)', node.localName, eventName, methodName, host);
}
};
},
_listen: function (node, eventName, handler) {
node.addEventListener(eventName, handler);
},
keyCodes: {
ESC_KEY: 27,
ENTER_KEY: 13,
LEFT: 37,
UP: 38,
RIGHT: 39,
DOWN: 40,
SPACE: 32
}
});

(function () {
'use strict';
var HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
var GESTURE_KEY = '__polymerGestures';
var HANDLED_OBJ = '__polymerGesturesHandled';
var TOUCH_ACTION = '__polymerGesturesTouchAction';
var TAP_DISTANCE = 25;
var TRACK_DISTANCE = 5;
var TRACK_LENGTH = 2;
var MOUSE_TIMEOUT = 500;
var MOUSE_EVENTS = [
'mousedown',
'mousemove',
'mouseup',
'click'
];
var mouseCanceller = function (mouseEvent) {
mouseEvent[HANDLED_OBJ] = { skip: true };
if (mouseEvent.type === 'click') {
var path = Polymer.dom(mouseEvent).path;
for (var i = 0; i < path.length; i++) {
if (path[i] === POINTERSTATE.mouse.target) {
return;
}
}
mouseEvent.preventDefault();
mouseEvent.stopPropagation();
}
};
function ignoreMouse(set) {
if (set && POINTERSTATE.touch.mouseIgnoreId !== -1) {
return;
}
for (var i = 0, en; i < MOUSE_EVENTS.length; i++) {
en = MOUSE_EVENTS[i];
if (set) {
document.addEventListener(en, mouseCanceller, true);
} else {
document.removeEventListener(en, mouseCanceller, true);
}
}
if (set) {
POINTERSTATE.mouse.mouseIgnoreId = setTimeout(ignoreMouse, MOUSE_TIMEOUT);
} else {
POINTERSTATE.mouse.target = null;
POINTERSTATE.touch.mouseIgnoreId = -1;
}
}
var POINTERSTATE = {
tapPrevented: false,
mouse: { target: null },
touch: {
x: 0,
y: 0,
id: -1,
scrollDecided: false,
mouseIgnoreId: -1
}
};
function firstTouchAction(ev) {
var path = Polymer.dom(ev).path;
var ta = 'auto';
for (var i = 0, n; i < path.length; i++) {
n = path[i];
if (n[TOUCH_ACTION]) {
ta = n[TOUCH_ACTION];
break;
}
}
return ta;
}
var Gestures = {
gestures: {},
recognizers: [],
deepTargetFind: function (x, y) {
var node = document.elementFromPoint(x, y);
var next = node;
while (next && next.shadowRoot) {
next = next.shadowRoot.elementFromPoint(x, y);
if (next) {
node = next;
}
}
return node;
},
handleNative: function (ev) {
var handled;
var type = ev.type;
var node = ev.currentTarget;
var gobj = node[GESTURE_KEY];
var gs = gobj[type];
if (!gs) {
return;
}
if (!ev[HANDLED_OBJ]) {
ev[HANDLED_OBJ] = {};
if (type.slice(0, 5) === 'touch') {
var t = ev.changedTouches[0];
if (type === 'touchstart') {
if (ev.touches.length === 1) {
POINTERSTATE.touch.id = t.identifier;
}
}
if (POINTERSTATE.touch.id !== t.identifier) {
return;
}
if (!HAS_NATIVE_TA) {
if (type === 'touchstart' || type === 'touchmove') {
Gestures.handleTouchAction(ev);
}
}
if (type === 'touchend') {
POINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;
ignoreMouse(true);
}
}
}
handled = ev[HANDLED_OBJ];
if (handled.skip) {
return;
}
var recognizers = Gestures.recognizers;
for (var i = 0, r; i < recognizers.length; i++) {
r = recognizers[i];
if (gs[r.name] && !handled[r.name]) {
handled[r.name] = true;
r[type](ev);
}
}
},
handleTouchAction: function (ev) {
var t = ev.changedTouches[0];
var type = ev.type;
if (type === 'touchstart') {
POINTERSTATE.touch.x = t.clientX;
POINTERSTATE.touch.y = t.clientY;
POINTERSTATE.touch.scrollDecided = false;
} else if (type === 'touchmove') {
if (POINTERSTATE.touch.scrollDecided) {
return;
}
POINTERSTATE.touch.scrollDecided = true;
var ta = firstTouchAction(ev);
var prevent = false;
var dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
var dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
if (!ev.cancelable) {
} else if (ta === 'none') {
prevent = true;
} else if (ta === 'pan-x') {
prevent = dy > dx;
} else if (ta === 'pan-y') {
prevent = dx > dy;
}
if (prevent) {
ev.preventDefault();
}
}
},
add: function (node, evType, handler) {
var recognizer = this.gestures[evType];
var deps = recognizer.deps;
var name = recognizer.name;
var gobj = node[GESTURE_KEY];
if (!gobj) {
node[GESTURE_KEY] = gobj = {};
}
for (var i = 0, dep, gd; i < deps.length; i++) {
dep = deps[i];
gd = gobj[dep];
if (!gd) {
gobj[dep] = gd = {};
node.addEventListener(dep, this.handleNative);
}
gd[name] = (gd[name] || 0) + 1;
}
node.addEventListener(evType, handler);
if (recognizer.touchAction) {
this.setTouchAction(node, recognizer.touchAction);
}
},
register: function (recog) {
this.recognizers.push(recog);
for (var i = 0; i < recog.emits.length; i++) {
this.gestures[recog.emits[i]] = recog;
}
},
setTouchAction: function (node, value) {
if (HAS_NATIVE_TA) {
node.style.touchAction = value;
}
node[TOUCH_ACTION] = value;
},
fire: function (target, type, detail) {
var ev = new CustomEvent(type, {
detail: detail,
bubbles: true,
cancelable: true
});
target.dispatchEvent(ev);
}
};
Gestures.register({
name: 'downup',
deps: [
'mousedown',
'touchstart',
'touchend'
],
emits: [
'down',
'up'
],
mousedown: function (e) {
var t = e.currentTarget;
var self = this;
var upfn = function upfn(e) {
self.fire('up', t, e);
document.removeEventListener('mouseup', upfn);
};
document.addEventListener('mouseup', upfn);
this.fire('down', t, e);
},
touchstart: function (e) {
this.fire('down', e.currentTarget, e.changedTouches[0]);
},
touchend: function (e) {
this.fire('up', e.currentTarget, e.changedTouches[0]);
},
fire: function (type, target, event) {
Gestures.fire(target, type, {
x: event.clientX,
y: event.clientY,
sourceEvent: event
});
}
});
Gestures.register({
name: 'track',
touchAction: 'none',
deps: [
'mousedown',
'touchstart',
'touchmove',
'touchend'
],
emits: ['track'],
info: {
x: 0,
y: 0,
state: 'start',
started: false,
moves: [],
addMove: function (move) {
if (this.moves.length > TRACK_LENGTH) {
this.moves.shift();
}
this.moves.push(move);
}
},
clearInfo: function () {
this.info.state = 'start';
this.info.started = false;
this.info.moves = [];
this.info.x = 0;
this.info.y = 0;
},
hasMovedEnough: function (x, y) {
if (this.info.started) {
return true;
}
var dx = Math.abs(this.info.x - x);
var dy = Math.abs(this.info.y - y);
return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
},
mousedown: function (e) {
var t = e.currentTarget;
var self = this;
var movefn = function movefn(e) {
var x = e.clientX, y = e.clientY;
if (self.hasMovedEnough(x, y)) {
self.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';
self.info.addMove({
x: x,
y: y
});
self.fire(t, e);
e.preventDefault();
self.info.started = true;
}
};
var upfn = function upfn(e) {
if (self.info.started) {
POINTERSTATE.tapPrevented = true;
movefn(e);
}
self.clearInfo();
document.removeEventListener('mousemove', movefn);
document.removeEventListener('mouseup', upfn);
};
document.addEventListener('mousemove', movefn);
document.addEventListener('mouseup', upfn);
this.info.x = e.clientX;
this.info.y = e.clientY;
},
touchstart: function (e) {
var ct = e.changedTouches[0];
this.info.x = ct.clientX;
this.info.y = ct.clientY;
},
touchmove: function (e) {
var t = e.currentTarget;
var ct = e.changedTouches[0];
var x = ct.clientX, y = ct.clientY;
if (this.hasMovedEnough(x, y)) {
this.info.addMove({
x: x,
y: y
});
this.fire(t, ct);
this.info.state = 'track';
this.info.started = true;
}
},
touchend: function (e) {
var t = e.currentTarget;
var ct = e.changedTouches[0];
if (this.info.started) {
POINTERSTATE.tapPrevented = true;
this.info.state = 'end';
this.info.addMove({
x: ct.clientX,
y: ct.clientY
});
this.fire(t, ct);
}
this.clearInfo();
},
fire: function (target, touch) {
var secondlast = this.info.moves[this.info.moves.length - 2];
var lastmove = this.info.moves[this.info.moves.length - 1];
var dx = lastmove.x - this.info.x;
var dy = lastmove.y - this.info.y;
var ddx, ddy = 0;
if (secondlast) {
ddx = lastmove.x - secondlast.x;
ddy = lastmove.y - secondlast.y;
}
return Gestures.fire(target, 'track', {
state: this.info.state,
x: touch.clientX,
y: touch.clientY,
dx: dx,
dy: dy,
ddx: ddx,
ddy: ddy,
hover: function () {
return Gestures.deepTargetFind(touch.clientX, touch.clientY);
}
});
}
});
Gestures.register({
name: 'tap',
deps: [
'mousedown',
'click',
'touchstart',
'touchend'
],
emits: ['tap'],
start: {
x: 0,
y: 0
},
reset: function () {
this.start.x = 0;
this.start.y = 0;
},
save: function (e) {
this.start.x = e.clientX;
this.start.y = e.clientY;
},
mousedown: function (e) {
POINTERSTATE.tapPrevented = false;
this.save(e);
},
click: function (e) {
this.forward(e);
},
touchstart: function (e) {
POINTERSTATE.tapPrevented = false;
this.save(e.changedTouches[0]);
},
touchend: function (e) {
this.forward(e.changedTouches[0]);
},
forward: function (e) {
var dx = Math.abs(e.clientX - this.start.x);
var dy = Math.abs(e.clientY - this.start.y);
if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE || dy <= TAP_DISTANCE) {
if (!POINTERSTATE.tapPrevented) {
Gestures.fire(e.target, 'tap', {
x: e.clientX,
y: e.clientY,
sourceEvent: e
});
}
}
this.reset();
}
});
var DIRECTION_MAP = {
x: 'pan-x',
y: 'pan-y',
none: 'none',
all: 'auto'
};
Polymer.Base._addFeature({
_listen: function (node, eventName, handler) {
if (Gestures.gestures[eventName]) {
Gestures.add(node, eventName, handler);
} else {
node.addEventListener(eventName, handler);
}
},
setScrollDirection: function (direction, node) {
node = node || this;
Gestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');
}
});
Polymer.Gestures = Gestures;
}());

Polymer.Async = function () {
var currVal = 0;
var lastVal = 0;
var callbacks = [];
var twiddle = document.createTextNode('');
function runAsync(callback, waitTime) {
if (waitTime > 0) {
return ~setTimeout(callback, waitTime);
} else {
twiddle.textContent = currVal++;
callbacks.push(callback);
return currVal - 1;
}
}
function cancelAsync(handle) {
if (handle < 0) {
clearTimeout(~handle);
} else {
var idx = handle - lastVal;
if (idx >= 0) {
if (!callbacks[idx]) {
throw 'invalid async handle: ' + handle;
}
callbacks[idx] = null;
}
}
}
function atEndOfMicrotask() {
var len = callbacks.length;
for (var i = 0; i < len; i++) {
var cb = callbacks[i];
if (cb) {
cb();
}
}
callbacks.splice(0, len);
lastVal += len;
}
new (window.MutationObserver || JsMutationObserver)(atEndOfMicrotask).observe(twiddle, { characterData: true });
return {
run: runAsync,
cancel: cancelAsync
};
}();

Polymer.Debounce = function () {
var Async = Polymer.Async;
var Debouncer = function (context) {
this.context = context;
this.boundComplete = this.complete.bind(this);
};
Debouncer.prototype = {
go: function (callback, wait) {
var h;
this.finish = function () {
Async.cancel(h);
};
h = Async.run(this.boundComplete, wait);
this.callback = callback;
},
stop: function () {
if (this.finish) {
this.finish();
this.finish = null;
}
},
complete: function () {
if (this.finish) {
this.stop();
this.callback.call(this.context);
}
}
};
function debounce(debouncer, callback, wait) {
if (debouncer) {
debouncer.stop();
} else {
debouncer = new Debouncer(this);
}
debouncer.go(callback, wait);
return debouncer;
}
return debounce;
}();

Polymer.Base._addFeature({
$$: function (slctr) {
return Polymer.dom(this.root).querySelector(slctr);
},
toggleClass: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.classList.contains(name);
}
if (bool) {
Polymer.dom(node).classList.add(name);
} else {
Polymer.dom(node).classList.remove(name);
}
},
toggleAttribute: function (name, bool, node) {
node = node || this;
if (arguments.length == 1) {
bool = !node.hasAttribute(name);
}
if (bool) {
Polymer.dom(node).setAttribute(name, '');
} else {
Polymer.dom(node).removeAttribute(name);
}
},
classFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).classList.remove(name);
}
if (toElement) {
Polymer.dom(toElement).classList.add(name);
}
},
attributeFollows: function (name, toElement, fromElement) {
if (fromElement) {
Polymer.dom(fromElement).removeAttribute(name);
}
if (toElement) {
Polymer.dom(toElement).setAttribute(name, '');
}
},
getContentChildNodes: function (slctr) {
return Polymer.dom(Polymer.dom(this.root).querySelector(slctr || 'content')).getDistributedNodes();
},
getContentChildren: function (slctr) {
return this.getContentChildNodes(slctr).filter(function (n) {
return n.nodeType === Node.ELEMENT_NODE;
});
},
fire: function (type, detail, options) {
options = options || Polymer.nob;
var node = options.node || this;
var detail = detail === null || detail === undefined ? Polymer.nob : detail;
var bubbles = options.bubbles === undefined ? true : options.bubbles;
var event = new CustomEvent(type, {
bubbles: Boolean(bubbles),
cancelable: Boolean(options.cancelable),
detail: detail
});
node.dispatchEvent(event);
return event;
},
async: function (callback, waitTime) {
return Polymer.Async.run(callback.bind(this), waitTime);
},
cancelAsync: function (handle) {
Polymer.Async.cancel(handle);
},
arrayDelete: function (path, item) {
var index;
if (Array.isArray(path)) {
index = path.indexOf(item);
if (index >= 0) {
return path.splice(index, 1);
}
} else {
var arr = this.get(path);
index = arr.indexOf(item);
if (index >= 0) {
return this.splice(path, index, 1);
}
}
},
transform: function (transform, node) {
node = node || this;
node.style.webkitTransform = transform;
node.style.transform = transform;
},
translate3d: function (x, y, z, node) {
node = node || this;
this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
},
importHref: function (href, onload, onerror) {
var l = document.createElement('link');
l.rel = 'import';
l.href = href;
if (onload) {
l.onload = onload.bind(this);
}
if (onerror) {
l.onerror = onerror.bind(this);
}
document.head.appendChild(l);
return l;
},
create: function (tag, props) {
var elt = document.createElement(tag);
if (props) {
for (var n in props) {
elt[n] = props[n];
}
}
return elt;
},
mixin: function (a, b) {
for (var i in b) {
a[i] = b[i];
}
}
});

Polymer.Bind = {
prepareModel: function (model) {
model._propertyEffects = {};
model._bindListeners = [];
var api = this._modelApi;
for (var n in api) {
model[n] = api[n];
}
},
_modelApi: {
_notifyChange: function (property) {
var eventName = Polymer.CaseMap.camelToDashCase(property) + '-changed';
this.fire(eventName, { value: this[property] }, { bubbles: false });
},
_propertySet: function (property, value, effects) {
var old = this.__data__[property];
if (old !== value) {
this.__data__[property] = value;
if (typeof value == 'object') {
this._clearPath(property);
}
if (this._propertyChanged) {
this._propertyChanged(property, value, old);
}
if (effects) {
this._effectEffects(property, value, effects, old);
}
}
return old;
},
_effectEffects: function (property, value, effects, old) {
effects.forEach(function (fx) {
var fn = Polymer.Bind['_' + fx.kind + 'Effect'];
if (fn) {
fn.call(this, property, value, fx.effect, old);
}
}, this);
},
_clearPath: function (path) {
for (var prop in this.__data__) {
if (prop.indexOf(path + '.') === 0) {
this.__data__[prop] = undefined;
}
}
}
},
ensurePropertyEffects: function (model, property) {
var fx = model._propertyEffects[property];
if (!fx) {
fx = model._propertyEffects[property] = [];
}
return fx;
},
addPropertyEffect: function (model, property, kind, effect) {
var fx = this.ensurePropertyEffects(model, property);
fx.push({
kind: kind,
effect: effect
});
},
createBindings: function (model) {
var fx$ = model._propertyEffects;
if (fx$) {
for (var n in fx$) {
var fx = fx$[n];
fx.sort(this._sortPropertyEffects);
this._createAccessors(model, n, fx);
}
}
},
_sortPropertyEffects: function () {
var EFFECT_ORDER = {
'compute': 0,
'annotation': 1,
'computedAnnotation': 2,
'reflect': 3,
'notify': 4,
'observer': 5,
'complexObserver': 6,
'function': 7
};
return function (a, b) {
return EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];
};
}(),
_createAccessors: function (model, property, effects) {
var defun = {
get: function () {
return this.__data__[property];
}
};
var setter = function (value) {
this._propertySet(property, value, effects);
};
if (model.getPropertyInfo && model.getPropertyInfo(property).readOnly) {
model['_set' + this.upper(property)] = setter;
} else {
defun.set = setter;
}
Object.defineProperty(model, property, defun);
},
upper: function (name) {
return name[0].toUpperCase() + name.substring(1);
},
_addAnnotatedListener: function (model, index, property, path, event) {
var fn = this._notedListenerFactory(property, path, this._isStructured(path), this._isEventBogus);
var eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';
model._bindListeners.push({
index: index,
property: property,
path: path,
changedFn: fn,
event: eventName
});
},
_isStructured: function (path) {
return path.indexOf('.') > 0;
},
_isEventBogus: function (e, target) {
return e.path && e.path[0] !== target;
},
_notedListenerFactory: function (property, path, isStructured, bogusTest) {
return function (e, target) {
if (!bogusTest(e, target)) {
if (e.detail && e.detail.path) {
this.notifyPath(this._fixPath(path, property, e.detail.path), e.detail.value);
} else {
var value = target[property];
if (!isStructured) {
this[path] = target[property];
} else {
if (this.__data__[path] != value) {
this.set(path, value);
}
}
}
}
};
},
prepareInstance: function (inst) {
inst.__data__ = Object.create(null);
},
setupBindListeners: function (inst) {
inst._bindListeners.forEach(function (info) {
var node = inst._nodes[info.index];
node.addEventListener(info.event, inst._notifyListener.bind(inst, info.changedFn));
});
}
};

Polymer.Base.extend(Polymer.Bind, {
_shouldAddListener: function (effect) {
return effect.name && effect.mode === '{' && !effect.negate && effect.kind != 'attribute';
},
_annotationEffect: function (source, value, effect) {
if (source != effect.value) {
value = this.get(effect.value);
this.__data__[effect.value] = value;
}
var calc = effect.negate ? !value : value;
if (!effect.customEvent || this._nodes[effect.index][effect.name] !== calc) {
return this._applyEffectValue(calc, effect);
}
},
_reflectEffect: function (source) {
this.reflectPropertyToAttribute(source);
},
_notifyEffect: function (source) {
this._notifyChange(source);
},
_functionEffect: function (source, value, fn, old) {
fn.call(this, source, value, old);
},
_observerEffect: function (source, value, effect, old) {
this[effect.method](value, old);
},
_complexObserverEffect: function (source, value, effect) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
this[effect.method].apply(this, args);
}
},
_computeEffect: function (source, value, effect) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
this[effect.property] = this[effect.method].apply(this, args);
}
},
_annotatedComputationEffect: function (source, value, effect) {
var args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);
if (args) {
var computedHost = this._rootDataHost || this;
var computedvalue = computedHost[effect.method].apply(computedHost, args);
if (effect.negate) {
computedvalue = !computedvalue;
}
this._applyEffectValue(computedvalue, effect);
}
},
_marshalArgs: function (model, effect, path, value) {
var values = [];
var args = effect.args;
for (var i = 0, l = args.length; i < l; i++) {
var arg = args[i];
var name = arg.name;
if (arg.literal) {
v = arg.value;
} else if (arg.structured) {
v = Polymer.Base.get(name, model);
} else {
v = model[name];
}
if (args.length > 1 && v === undefined) {
return;
}
if (arg.wildcard) {
var baseChanged = name.indexOf(path + '.') === 0;
var matches = effect.trigger.name.indexOf(name) === 0 && !baseChanged;
values[i] = {
path: matches ? path : name,
value: matches ? value : v,
base: v
};
} else {
values[i] = v;
}
}
return values;
}
});

Polymer.Base._addFeature({
_addPropertyEffect: function (property, kind, effect) {
Polymer.Bind.addPropertyEffect(this, property, kind, effect);
},
_prepEffects: function () {
Polymer.Bind.prepareModel(this);
this._addAnnotationEffects(this._notes);
},
_prepBindings: function () {
Polymer.Bind.createBindings(this);
},
_addPropertyEffects: function (properties) {
if (properties) {
for (var p in properties) {
var prop = properties[p];
if (prop.observer) {
this._addObserverEffect(p, prop.observer);
}
if (prop.computed) {
this._addComputedEffect(p, prop.computed);
}
if (prop.notify) {
this._addPropertyEffect(p, 'notify');
}
if (prop.reflectToAttribute) {
this._addPropertyEffect(p, 'reflect');
}
if (prop.readOnly) {
Polymer.Bind.ensurePropertyEffects(this, p);
}
}
}
},
_addComputedEffect: function (name, expression) {
var sig = this._parseMethod(expression);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'compute', {
method: sig.method,
args: sig.args,
trigger: arg,
property: name
});
}, this);
},
_addObserverEffect: function (property, observer) {
this._addPropertyEffect(property, 'observer', {
method: observer,
property: property
});
},
_addComplexObserverEffects: function (observers) {
if (observers) {
observers.forEach(function (observer) {
this._addComplexObserverEffect(observer);
}, this);
}
},
_addComplexObserverEffect: function (observer) {
var sig = this._parseMethod(observer);
sig.args.forEach(function (arg) {
this._addPropertyEffect(arg.model, 'complexObserver', {
method: sig.method,
args: sig.args,
trigger: arg
});
}, this);
},
_addAnnotationEffects: function (notes) {
this._nodes = [];
notes.forEach(function (note) {
var index = this._nodes.push(note) - 1;
note.bindings.forEach(function (binding) {
this._addAnnotationEffect(binding, index);
}, this);
}, this);
},
_addAnnotationEffect: function (note, index) {
if (Polymer.Bind._shouldAddListener(note)) {
Polymer.Bind._addAnnotatedListener(this, index, note.name, note.value, note.event);
}
if (note.signature) {
this._addAnnotatedComputationEffect(note, index);
} else {
note.index = index;
this._addPropertyEffect(note.model, 'annotation', note);
}
},
_addAnnotatedComputationEffect: function (note, index) {
var sig = note.signature;
if (sig.static) {
this.__addAnnotatedComputationEffect('__static__', index, note, sig, null);
} else {
sig.args.forEach(function (arg) {
if (!arg.literal) {
this.__addAnnotatedComputationEffect(arg.model, index, note, sig, arg);
}
}, this);
}
},
__addAnnotatedComputationEffect: function (property, index, note, sig, trigger) {
this._addPropertyEffect(property, 'annotatedComputation', {
index: index,
kind: note.kind,
property: note.name,
negate: note.negate,
method: sig.method,
args: sig.args,
trigger: trigger
});
},
_parseMethod: function (expression) {
var m = expression.match(/(\w*)\((.*)\)/);
if (m) {
var sig = {
method: m[1],
static: true
};
if (m[2].trim()) {
var args = m[2].replace(/\\,/g, '&comma;').split(',');
return this._parseArgs(args, sig);
} else {
sig.args = Polymer.nar;
return sig;
}
}
},
_parseArgs: function (argList, sig) {
sig.args = argList.map(function (rawArg) {
var arg = this._parseArg(rawArg);
if (!arg.literal) {
sig.static = false;
}
return arg;
}, this);
return sig;
},
_parseArg: function (rawArg) {
var arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\(.)/g, '$1');
var a = {
name: arg,
model: this._modelForPath(arg)
};
var fc = arg[0];
if (fc >= '0' && fc <= '9') {
fc = '#';
}
switch (fc) {
case '\'':
case '"':
a.value = arg.slice(1, -1);
a.literal = true;
break;
case '#':
a.value = Number(arg);
a.literal = true;
break;
}
if (!a.literal) {
a.structured = arg.indexOf('.') > 0;
if (a.structured) {
a.wildcard = arg.slice(-2) == '.*';
if (a.wildcard) {
a.name = arg.slice(0, -2);
}
}
}
return a;
},
_marshalInstanceEffects: function () {
Polymer.Bind.prepareInstance(this);
Polymer.Bind.setupBindListeners(this);
},
_applyEffectValue: function (value, info) {
var node = this._nodes[info.index];
var property = info.property || info.name || 'textContent';
if (info.kind == 'attribute') {
this.serializeValueToAttribute(value, property, node);
} else {
if (property === 'className') {
value = this._scopeElementClass(node, value);
}
if (property === 'textContent' || node.localName == 'input' && property == 'value') {
value = value == undefined ? '' : value;
}
return node[property] = value;
}
},
_executeStaticEffects: function () {
if (this._propertyEffects.__static__) {
this._effectEffects('__static__', null, this._propertyEffects.__static__);
}
}
});

Polymer.Base._addFeature({
_setupConfigure: function (initialConfig) {
this._config = initialConfig || {};
this._handlers = [];
},
_marshalAttributes: function () {
this._takeAttributesToModel(this._config);
},
_configValue: function (name, value) {
this._config[name] = value;
},
_beforeClientsReady: function () {
this._configure();
},
_configure: function () {
this._configureAnnotationReferences();
var config = {};
this.behaviors.forEach(function (b) {
this._configureProperties(b.properties, config);
}, this);
this._configureProperties(this.properties, config);
this._mixinConfigure(config, this._config);
this._config = config;
this._distributeConfig(this._config);
},
_configureProperties: function (properties, config) {
for (var i in properties) {
var c = properties[i];
if (c.value !== undefined) {
var value = c.value;
if (typeof value == 'function') {
value = value.call(this, this._config);
}
config[i] = value;
}
}
},
_mixinConfigure: function (a, b) {
for (var prop in b) {
if (!this.getPropertyInfo(prop).readOnly) {
a[prop] = b[prop];
}
}
},
_distributeConfig: function (config) {
var fx$ = this._propertyEffects;
if (fx$) {
for (var p in config) {
var fx = fx$[p];
if (fx) {
for (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {
if (x.kind === 'annotation') {
var node = this._nodes[x.effect.index];
if (node._configValue) {
var value = p === x.effect.value ? config[p] : this.get(x.effect.value, config);
node._configValue(x.effect.name, value);
}
}
}
}
}
}
},
_afterClientsReady: function () {
this._executeStaticEffects();
this._applyConfig(this._config);
this._flushHandlers();
},
_applyConfig: function (config) {
for (var n in config) {
if (this[n] === undefined) {
var effects = this._propertyEffects[n];
if (effects) {
this._propertySet(n, config[n], effects);
} else {
this[n] = config[n];
}
}
}
},
_notifyListener: function (fn, e) {
if (!this._clientsReadied) {
this._queueHandler([
fn,
e,
e.target
]);
} else {
return fn.call(this, e, e.target);
}
},
_queueHandler: function (args) {
this._handlers.push(args);
},
_flushHandlers: function () {
var h$ = this._handlers;
for (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {
h[0].call(this, h[1], h[2]);
}
}
});

(function () {
'use strict';
Polymer.Base._addFeature({
notifyPath: function (path, value, fromAbove) {
var old = this._propertySet(path, value);
if (old !== value) {
this._pathEffector(path, value);
if (!fromAbove) {
this._notifyPath(path, value);
}
}
},
_getPathParts: function (path) {
if (Array.isArray(path)) {
var parts = [];
for (var i = 0; i < path.length; i++) {
var args = path[i].toString().split('.');
for (var j = 0; j < args.length; j++) {
parts.push(args[j]);
}
}
return parts;
} else {
return path.toString().split('.');
}
},
set: function (path, value, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var array;
var last = parts[parts.length - 1];
if (parts.length > 1) {
for (var i = 0; i < parts.length - 1; i++) {
prop = prop[parts[i]];
if (array) {
parts[i] = Polymer.Collection.get(array).getKey(prop);
}
if (!prop) {
return;
}
array = Array.isArray(prop) ? prop : null;
}
prop[last] = value;
if (!root) {
this.notifyPath(parts.join('.'), value);
}
} else {
prop[path] = value;
}
},
get: function (path, root) {
var prop = root || this;
var parts = this._getPathParts(path);
var last = parts.pop();
while (parts.length) {
prop = prop[parts.shift()];
if (!prop) {
return;
}
}
return prop[last];
},
_pathEffector: function (path, value) {
var model = this._modelForPath(path);
var fx$ = this._propertyEffects[model];
if (fx$) {
fx$.forEach(function (fx) {
var fxFn = this['_' + fx.kind + 'PathEffect'];
if (fxFn) {
fxFn.call(this, path, value, fx.effect);
}
}, this);
}
if (this._boundPaths) {
this._notifyBoundPaths(path, value);
}
},
_annotationPathEffect: function (path, value, effect) {
if (effect.value === path || effect.value.indexOf(path + '.') === 0) {
Polymer.Bind._annotationEffect.call(this, path, value, effect);
} else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {
var node = this._nodes[effect.index];
if (node && node.notifyPath) {
var p = this._fixPath(effect.name, effect.value, path);
node.notifyPath(p, value, true);
}
}
},
_complexObserverPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._complexObserverEffect.call(this, path, value, effect);
}
},
_computePathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._computeEffect.call(this, path, value, effect);
}
},
_annotatedComputationPathEffect: function (path, value, effect) {
if (this._pathMatchesEffect(path, effect)) {
Polymer.Bind._annotatedComputationEffect.call(this, path, value, effect);
}
},
_pathMatchesEffect: function (path, effect) {
var effectArg = effect.trigger.name;
return effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg) === 0;
},
linkPaths: function (to, from) {
this._boundPaths = this._boundPaths || {};
if (from) {
this._boundPaths[to] = from;
} else {
this.unbindPath(to);
}
},
unlinkPaths: function (path) {
if (this._boundPaths) {
delete this._boundPaths[path];
}
},
_notifyBoundPaths: function (path, value) {
var from, to;
for (var a in this._boundPaths) {
var b = this._boundPaths[a];
if (path.indexOf(a + '.') == 0) {
from = a;
to = b;
break;
}
if (path.indexOf(b + '.') == 0) {
from = b;
to = a;
break;
}
}
if (from && to) {
var p = this._fixPath(to, from, path);
this.notifyPath(p, value);
}
},
_fixPath: function (property, root, path) {
return property + path.slice(root.length);
},
_notifyPath: function (path, value) {
var rootName = this._modelForPath(path);
var dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);
var eventName = dashCaseName + this._EVENT_CHANGED;
this.fire(eventName, {
path: path,
value: value
}, { bubbles: false });
},
_modelForPath: function (path) {
var dot = path.indexOf('.');
return dot < 0 ? path : path.slice(0, dot);
},
_EVENT_CHANGED: '-changed',
_notifySplice: function (array, path, index, added, removed) {
var splices = [{
index: index,
addedCount: added,
removed: removed,
object: array,
type: 'splice'
}];
var change = {
keySplices: Polymer.Collection.get(array).applySplices(splices),
indexSplices: splices
};
this.set(path + '.splices', change);
if (added != removed.length) {
this.notifyPath(path + '.length', array.length);
}
change.keySplices = null;
change.indexSplices = null;
},
push: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var len = array.length;
var ret = array.push.apply(array, args);
this._notifySplice(array, path, len, args.length, []);
return ret;
},
pop: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var rem = array.slice(-1);
var ret = array.pop.apply(array, args);
this._notifySplice(array, path, array.length, 0, rem);
return ret;
},
splice: function (path, start, deleteCount) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var rem = array.slice(start, start + deleteCount);
var ret = array.splice.apply(array, args);
this._notifySplice(array, path, start, args.length - 2, rem);
return ret;
},
shift: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.shift.apply(array, args);
this._notifySplice(array, path, 0, 0, [ret]);
return ret;
},
unshift: function (path) {
var array = this.get(path);
var args = Array.prototype.slice.call(arguments, 1);
var ret = array.unshift.apply(array, args);
this._notifySplice(array, path, 0, args.length, []);
return ret;
}
});
}());

Polymer.Base._addFeature({
resolveUrl: function (url) {
var module = Polymer.DomModule.import(this.is);
var root = '';
if (module) {
var assetPath = module.getAttribute('assetpath') || '';
root = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);
}
return Polymer.ResolveUrl.resolveUrl(url, root);
}
});

Polymer.CssParse = function () {
var api = {
parse: function (text) {
text = this._clean(text);
return this._parseCss(this._lex(text), text);
},
_clean: function (cssText) {
return cssText.replace(rx.comments, '').replace(rx.port, '');
},
_lex: function (text) {
var root = {
start: 0,
end: text.length
};
var n = root;
for (var i = 0, s = 0, l = text.length; i < l; i++) {
switch (text[i]) {
case this.OPEN_BRACE:
if (!n.rules) {
n.rules = [];
}
var p = n;
var previous = p.rules[p.rules.length - 1];
n = {
start: i + 1,
parent: p,
previous: previous
};
p.rules.push(n);
break;
case this.CLOSE_BRACE:
n.end = i + 1;
n = n.parent || root;
break;
}
}
return root;
},
_parseCss: function (node, text) {
var t = text.substring(node.start, node.end - 1);
node.parsedCssText = node.cssText = t.trim();
if (node.parent) {
var ss = node.previous ? node.previous.end : node.parent.start;
t = text.substring(ss, node.start - 1);
t = t.substring(t.lastIndexOf(';') + 1);
var s = node.parsedSelector = node.selector = t.trim();
node.atRule = s.indexOf(AT_START) === 0;
if (node.atRule) {
if (s.indexOf(MEDIA_START) === 0) {
node.type = this.types.MEDIA_RULE;
} else if (s.match(rx.keyframesRule)) {
node.type = this.types.KEYFRAMES_RULE;
}
} else {
if (s.indexOf(VAR_START) === 0) {
node.type = this.types.MIXIN_RULE;
} else {
node.type = this.types.STYLE_RULE;
}
}
}
var r$ = node.rules;
if (r$) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this._parseCss(r, text);
}
}
return node;
},
stringify: function (node, preserveProperties, text) {
text = text || '';
var cssText = '';
if (node.cssText || node.rules) {
var r$ = node.rules;
if (r$ && (preserveProperties || !hasMixinRules(r$))) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
cssText = this.stringify(r, preserveProperties, cssText);
}
} else {
cssText = preserveProperties ? node.cssText : removeCustomProps(node.cssText);
cssText = cssText.trim();
if (cssText) {
cssText = '  ' + cssText + '\n';
}
}
}
if (cssText) {
if (node.selector) {
text += node.selector + ' ' + this.OPEN_BRACE + '\n';
}
text += cssText;
if (node.selector) {
text += this.CLOSE_BRACE + '\n\n';
}
}
return text;
},
types: {
STYLE_RULE: 1,
KEYFRAMES_RULE: 7,
MEDIA_RULE: 4,
MIXIN_RULE: 1000
},
OPEN_BRACE: '{',
CLOSE_BRACE: '}'
};
function hasMixinRules(rules) {
return rules[0].selector.indexOf(VAR_START) >= 0;
}
function removeCustomProps(cssText) {
return cssText.replace(rx.customProp, '').replace(rx.mixinProp, '').replace(rx.mixinApply, '').replace(rx.varApply, '');
}
var VAR_START = '--';
var MEDIA_START = '@media';
var AT_START = '@';
var rx = {
comments: /\/\*[^*]*\*+([^\/*][^*]*\*+)*\//gim,
port: /@import[^;]*;/gim,
customProp: /(?:^|[\s;])--[^;{]*?:[^{};]*?;/gim,
mixinProp: /(?:^|[\s;])--[^;{]*?:[^{;]*?{[^}]*?};?/gim,
mixinApply: /@apply[\s]*\([^)]*?\)[\s]*;/gim,
varApply: /[^;:]*?:[^;]*var[^;]*;/gim,
keyframesRule: /^@[^\s]*keyframes/
};
return api;
}();

Polymer.StyleUtil = function () {
return {
MODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css]',
toCssText: function (rules, callback, preserveProperties) {
if (typeof rules === 'string') {
rules = this.parser.parse(rules);
}
if (callback) {
this.forEachStyleRule(rules, callback);
}
return this.parser.stringify(rules, preserveProperties);
},
forRulesInStyles: function (styles, callback) {
for (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {
this.forEachStyleRule(this.rulesForStyle(s), callback);
}
},
rulesForStyle: function (style) {
if (!style.__cssRules) {
style.__cssRules = this.parser.parse(style.textContent);
}
return style.__cssRules;
},
clearStyleRules: function (style) {
style.__cssRules = null;
},
forEachStyleRule: function (node, callback) {
var s = node.selector;
var skipRules = false;
if (node.type === this.ruleTypes.STYLE_RULE) {
callback(node);
} else if (node.type === this.ruleTypes.KEYFRAMES_RULE || node.type === this.ruleTypes.MIXIN_RULE) {
skipRules = true;
}
var r$ = node.rules;
if (r$ && !skipRules) {
for (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
this.forEachStyleRule(r, callback);
}
}
},
applyCss: function (cssText, moniker, target, afterNode) {
var style = document.createElement('style');
if (moniker) {
style.setAttribute('scope', moniker);
}
style.textContent = cssText;
target = target || document.head;
if (!afterNode) {
var n$ = target.querySelectorAll('style[scope]');
afterNode = n$[n$.length - 1];
}
target.insertBefore(style, afterNode && afterNode.nextSibling || target.firstChild);
return style;
},
cssFromModule: function (moduleId) {
var m = Polymer.DomModule.import(moduleId);
if (m && !m._cssText) {
var cssText = '';
var e$ = Array.prototype.slice.call(m.querySelectorAll(this.MODULE_STYLES_SELECTOR));
for (var i = 0, e; i < e$.length; i++) {
e = e$[i];
if (e.localName === 'style') {
e = e.__appliedElement || e;
e.parentNode.removeChild(e);
} else {
e = e.import && e.import.body;
}
if (e) {
cssText += Polymer.ResolveUrl.resolveCss(e.textContent, e.ownerDocument);
}
}
m._cssText = cssText;
}
return m && m._cssText || '';
},
parser: Polymer.CssParse,
ruleTypes: Polymer.CssParse.types
};
}();

Polymer.StyleTransformer = function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var api = {
dom: function (node, scope, useAttr, shouldRemoveScope) {
this._transformDom(node, scope || '', useAttr, shouldRemoveScope);
},
_transformDom: function (node, selector, useAttr, shouldRemoveScope) {
if (node.setAttribute) {
this.element(node, selector, useAttr, shouldRemoveScope);
}
var c$ = Polymer.dom(node).childNodes;
for (var i = 0; i < c$.length; i++) {
this._transformDom(c$[i], selector, useAttr, shouldRemoveScope);
}
},
element: function (element, scope, useAttr, shouldRemoveScope) {
if (useAttr) {
if (shouldRemoveScope) {
element.removeAttribute(SCOPE_NAME);
} else {
element.setAttribute(SCOPE_NAME, scope);
}
} else {
if (scope) {
if (element.classList) {
if (shouldRemoveScope) {
element.classList.remove(SCOPE_NAME);
element.classList.remove(scope);
} else {
element.classList.add(SCOPE_NAME);
element.classList.add(scope);
}
} else if (element.getAttribute) {
var c = element.getAttribute(CLASS);
if (shouldRemoveScope) {
if (c) {
element.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));
}
} else {
element.setAttribute(CLASS, c + (c ? ' ' : '') + SCOPE_NAME + ' ' + scope);
}
}
}
}
},
elementStyles: function (element, callback) {
var styles = element._styles;
var cssText = '';
for (var i = 0, l = styles.length, s, text; i < l && (s = styles[i]); i++) {
var rules = styleUtil.rulesForStyle(s);
cssText += nativeShadow ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\n\n';
}
return cssText.trim();
},
css: function (rules, scope, ext, callback, useAttr) {
var hostScope = this._calcHostScope(scope, ext);
scope = this._calcElementScope(scope, useAttr);
var self = this;
return styleUtil.toCssText(rules, function (rule) {
if (!rule.isScoped) {
self.rule(rule, scope, hostScope);
rule.isScoped = true;
}
if (callback) {
callback(rule, scope, hostScope);
}
});
},
_calcElementScope: function (scope, useAttr) {
if (scope) {
return useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;
} else {
return '';
}
},
_calcHostScope: function (scope, ext) {
return ext ? '[is=' + scope + ']' : scope;
},
rule: function (rule, scope, hostScope) {
this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
},
_transformRule: function (rule, transformer, scope, hostScope) {
var p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);
for (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
p$[i] = transformer.call(this, p, scope, hostScope);
}
rule.selector = p$.join(COMPLEX_SELECTOR_SEP);
},
_transformComplexSelector: function (selector, scope, hostScope) {
var stop = false;
var self = this;
selector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {
if (!stop) {
var o = self._transformCompoundSelector(s, c, scope, hostScope);
if (o.stop) {
stop = true;
}
c = o.combinator;
s = o.value;
}
return c + s;
});
return selector;
},
_transformCompoundSelector: function (selector, combinator, scope, hostScope) {
var jumpIndex = selector.search(SCOPE_JUMP);
if (selector.indexOf(HOST) >= 0) {
selector = selector.replace(HOST_PAREN, function (m, host, paren) {
return hostScope + paren;
});
selector = selector.replace(HOST, hostScope);
} else if (jumpIndex !== 0) {
selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
}
if (selector.indexOf(CONTENT) >= 0) {
combinator = '';
}
var stop;
if (jumpIndex >= 0) {
selector = selector.replace(SCOPE_JUMP, ' ');
stop = true;
}
return {
value: selector,
combinator: combinator,
stop: stop
};
},
_transformSimpleSelector: function (selector, scope) {
var p$ = selector.split(PSEUDO_PREFIX);
p$[0] += scope;
return p$.join(PSEUDO_PREFIX);
},
rootRule: function (rule) {
this._transformRule(rule, this._transformRootSelector);
},
_transformRootSelector: function (selector) {
return selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector) : selector.trim() + SCOPE_ROOT_SELECTOR;
},
SCOPE_NAME: 'style-scope'
};
var SCOPE_NAME = api.SCOPE_NAME;
var SCOPE_ROOT_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';
var COMPLEX_SELECTOR_SEP = ',';
var SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)([^\s>+~]+)/g;
var HOST = ':host';
var HOST_PAREN = /(\:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/g;
var CONTENT = '::content';
var SCOPE_JUMP = /\:\:content|\:\:shadow|\/deep\//;
var CSS_CLASS_PREFIX = '.';
var CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';
var CSS_ATTR_SUFFIX = ']';
var PSEUDO_PREFIX = ':';
var CLASS = 'class';
return api;
}();

Polymer.StyleExtends = function () {
var styleUtil = Polymer.StyleUtil;
return {
hasExtends: function (cssText) {
return Boolean(cssText.match(this.rx.EXTEND));
},
transform: function (style) {
var rules = styleUtil.rulesForStyle(style);
var self = this;
styleUtil.forEachStyleRule(rules, function (rule) {
var map = self._mapRule(rule);
if (rule.parent) {
var m;
while (m = self.rx.EXTEND.exec(rule.cssText)) {
var extend = m[1];
var extendor = self._findExtendor(extend, rule);
if (extendor) {
self._extendRule(rule, extendor);
}
}
}
rule.cssText = rule.cssText.replace(self.rx.EXTEND, '');
});
return styleUtil.toCssText(rules, function (rule) {
if (rule.selector.match(self.rx.STRIP)) {
rule.cssText = '';
}
}, true);
},
_mapRule: function (rule) {
if (rule.parent) {
var map = rule.parent.map || (rule.parent.map = {});
var parts = rule.selector.split(',');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
map[p.trim()] = rule;
}
return map;
}
},
_findExtendor: function (extend, rule) {
return rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);
},
_extendRule: function (target, source) {
if (target.parent !== source.parent) {
this._cloneAndAddRuleToParent(source, target.parent);
}
target.extends = target.extends || (target.extends = []);
target.extends.push(source);
source.selector = source.selector.replace(this.rx.STRIP, '');
source.selector = (source.selector && source.selector + ',\n') + target.selector;
if (source.extends) {
source.extends.forEach(function (e) {
this._extendRule(target, e);
}, this);
}
},
_cloneAndAddRuleToParent: function (rule, parent) {
rule = Object.create(rule);
rule.parent = parent;
if (rule.extends) {
rule.extends = rule.extends.slice();
}
parent.rules.push(rule);
},
rx: {
EXTEND: /@extends\(([^)]*)\)\s*?;/gim,
STRIP: /%[^,]*$/
}
};
}();

(function () {
var prepElement = Polymer.Base._prepElement;
var nativeShadow = Polymer.Settings.useNativeShadow;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
var styleExtends = Polymer.StyleExtends;
Polymer.Base._addFeature({
_prepElement: function (element) {
if (this._encapsulateStyle) {
styleTransformer.element(element, this.is, this._scopeCssViaAttr);
}
prepElement.call(this, element);
},
_prepStyles: function () {
if (this._encapsulateStyle === undefined) {
this._encapsulateStyle = !nativeShadow && Boolean(this._template);
}
this._styles = this._collectStyles();
var cssText = styleTransformer.elementStyles(this);
if (cssText && this._template) {
var style = styleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null);
if (!nativeShadow) {
this._scopeStyle = style;
}
}
},
_collectStyles: function () {
var styles = [];
var cssText = '', m$ = this.styleModules;
if (m$) {
for (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {
cssText += styleUtil.cssFromModule(m);
}
}
cssText += styleUtil.cssFromModule(this.is);
if (cssText) {
var style = document.createElement('style');
style.textContent = cssText;
if (styleExtends.hasExtends(style.textContent)) {
cssText = styleExtends.transform(style);
}
styles.push(style);
}
return styles;
},
_elementAdd: function (node) {
if (this._encapsulateStyle && !node.__styleScoped) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr);
}
},
_elementRemove: function (node) {
if (this._encapsulateStyle) {
styleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);
}
},
scopeSubtree: function (container, shouldObserve) {
if (nativeShadow) {
return;
}
var self = this;
var scopify = function (node) {
if (node.nodeType === Node.ELEMENT_NODE) {
node.className = self._scopeElementClass(node, node.className);
var n$ = node.querySelectorAll('*');
Array.prototype.forEach.call(n$, function (n) {
n.className = self._scopeElementClass(n, n.className);
});
}
};
scopify(container);
if (shouldObserve) {
var mo = new MutationObserver(function (mxns) {
mxns.forEach(function (m) {
if (m.addedNodes) {
for (var i = 0; i < m.addedNodes.length; i++) {
scopify(m.addedNodes[i]);
}
}
});
});
mo.observe(container, {
childList: true,
subtree: true
});
return mo;
}
}
});
}());

Polymer.StyleProperties = function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var matchesSelector = Polymer.DomApi.matchesSelector;
var styleUtil = Polymer.StyleUtil;
var styleTransformer = Polymer.StyleTransformer;
return {
decorateStyles: function (styles) {
var self = this, props = {};
styleUtil.forRulesInStyles(styles, function (rule) {
self.decorateRule(rule);
self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
});
var names = [];
for (var i in props) {
names.push(i);
}
return names;
},
decorateRule: function (rule) {
if (rule.propertyInfo) {
return rule.propertyInfo;
}
var info = {}, properties = {};
var hasProperties = this.collectProperties(rule, properties);
if (hasProperties) {
info.properties = properties;
rule.rules = null;
}
info.cssText = this.collectCssText(rule);
rule.propertyInfo = info;
return info;
},
collectProperties: function (rule, properties) {
var info = rule.propertyInfo;
if (info) {
if (info.properties) {
Polymer.Base.mixin(properties, info.properties);
return true;
}
} else {
var m, rx = this.rx.VAR_ASSIGN;
var cssText = rule.parsedCssText;
var any;
while (m = rx.exec(cssText)) {
properties[m[1]] = (m[2] || m[3]).trim();
any = true;
}
return any;
}
},
collectCssText: function (rule) {
var customCssText = '';
var cssText = rule.parsedCssText;
cssText = cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');
var parts = cssText.split(';');
for (var i = 0, p; i < parts.length; i++) {
p = parts[i];
if (p.match(this.rx.MIXIN_MATCH) || p.match(this.rx.VAR_MATCH)) {
customCssText += p + ';\n';
}
}
return customCssText;
},
collectPropertiesInCssText: function (cssText, props) {
var m;
while (m = this.rx.VAR_CAPTURE.exec(cssText)) {
props[m[1]] = true;
}
},
reify: function (props) {
var names = Object.getOwnPropertyNames(props);
for (var i = 0, n; i < names.length; i++) {
n = names[i];
props[n] = this.valueForProperty(props[n], props);
}
},
valueForProperty: function (property, props) {
if (property) {
if (property.indexOf(';') >= 0) {
property = this.valueForProperties(property, props);
} else {
var self = this;
var fn = function (all, prefix, value, fallback) {
var propertyValue = self.valueForProperty(props[value], props) || (props[fallback] ? self.valueForProperty(props[fallback], props) : fallback);
return prefix + (propertyValue || '');
};
property = property.replace(this.rx.VAR_MATCH, fn);
}
}
return property && property.trim() || '';
},
valueForProperties: function (property, props) {
var parts = property.split(';');
for (var i = 0, p, m; i < parts.length && (p = parts[i]); i++) {
m = p.match(this.rx.MIXIN_MATCH);
if (m) {
p = this.valueForProperty(props[m[1]], props);
} else {
var pp = p.split(':');
if (pp[1]) {
pp[1] = pp[1].trim();
pp[1] = this.valueForProperty(pp[1], props) || pp[1];
}
p = pp.join(': ');
}
parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';
}
return parts.join(';');
},
applyProperties: function (rule, props) {
var output = '';
if (!rule.properties) {
this.decorateRule(rule);
}
if (rule.propertyInfo.cssText) {
output = this.valueForProperties(rule.propertyInfo.cssText, props);
}
rule.cssText = output;
},
propertyDataFromStyles: function (styles, element) {
var props = {}, self = this;
var o = [], i = 0;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
if (element && rule.propertyInfo.properties && matchesSelector.call(element, rule.selector)) {
self.collectProperties(rule, props);
addToBitMask(i, o);
}
i++;
});
return {
properties: props,
key: o
};
},
scopePropertiesFromStyles: function (styles) {
if (!styles._scopeStyleProperties) {
styles._scopeStyleProperties = this.selectedPropertiesFromStyles(styles, this.SCOPE_SELECTORS);
}
return styles._scopeStyleProperties;
},
hostPropertiesFromStyles: function (styles) {
if (!styles._hostStyleProperties) {
styles._hostStyleProperties = this.selectedPropertiesFromStyles(styles, this.HOST_SELECTORS);
}
return styles._hostStyleProperties;
},
selectedPropertiesFromStyles: function (styles, selectors) {
var props = {}, self = this;
styleUtil.forRulesInStyles(styles, function (rule) {
if (!rule.propertyInfo) {
self.decorateRule(rule);
}
for (var i = 0; i < selectors.length; i++) {
if (rule.parsedSelector === selectors[i]) {
self.collectProperties(rule, props);
return;
}
}
});
return props;
},
transformStyles: function (element, properties, scopeSelector) {
var self = this;
var hostRx = new RegExp(this.rx.HOST_PREFIX + element.is + this.rx.HOST_SUFFIX);
return styleTransformer.elementStyles(element, function (rule) {
self.applyProperties(rule, properties);
if (rule.cssText && !nativeShadow) {
self._scopeSelector(rule, hostRx, element.is, element._scopeCssViaAttr, scopeSelector);
}
});
},
_scopeSelector: function (rule, hostRx, is, viaAttr, scopeId) {
rule.transformedSelector = rule.transformedSelector || rule.selector;
var selector = rule.transformedSelector;
var scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;
var parts = selector.split(',');
for (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
parts[i] = p.match(hostRx) ? p.replace(is, is + scope) : scope + ' ' + p;
}
rule.selector = parts.join(',');
},
applyElementScopeSelector: function (element, selector, old, viaAttr) {
var c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.className;
v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;
if (c !== v) {
if (viaAttr) {
element.setAttribute(styleTransformer.SCOPE_NAME, v);
} else {
element.className = v;
}
}
},
applyElementStyle: function (element, properties, selector, style) {
var cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);
var s = element._customStyle;
if (s && !nativeShadow && s !== style) {
s._useCount--;
if (s._useCount <= 0) {
s.parentNode.removeChild(s);
}
}
if (nativeShadow || (!style || !style.parentNode)) {
if (nativeShadow && element._customStyle) {
element._customStyle.textContent = cssText;
style = element._customStyle;
} else if (cssText) {
style = styleUtil.applyCss(cssText, selector, nativeShadow ? element.root : null, element._scopeStyle);
}
}
if (style) {
style._useCount = style._useCount || 0;
if (element._customStyle != style) {
style._useCount++;
}
element._customStyle = style;
}
return style;
},
rx: {
VAR_ASSIGN: /(?:^|;\s*)(--[^\:;]*?):\s*?(?:([^;{]*?)|{([^}]*)})(?=;)/gim,
MIXIN_MATCH: /(?:^|\W+)@apply[\s]*\(([^)]*)\);?/im,
VAR_MATCH: /(^|\W+)var\([\s]*([^,)]*)[\s]*,?[\s]*((?:[^,)]*)|(?:[^;]*\([^;)]*\)))[\s]*?\)/gim,
VAR_CAPTURE: /\([\s]*(--[^,\s)]*)(?:,[\s]*(--[^,\s)]*))?(?:\)|,)/gim,
BRACKETED: /\{[^}]*\}/g,
HOST_PREFIX: '(?:^|[^.])',
HOST_SUFFIX: '($|[.:[\\s>+~])'
},
HOST_SELECTORS: [':host'],
SCOPE_SELECTORS: [':root'],
XSCOPE_NAME: 'x-scope'
};
function addToBitMask(n, bits) {
var o = parseInt(n / 32);
var v = 1 << n % 32;
bits[o] = (bits[o] || 0) | v;
}
}();

Polymer.StyleDefaults = function () {
var styleProperties = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var style = document.createElement('style');
var api = {
style: style,
_styles: [style],
_properties: null,
applyCss: function (cssText) {
this.style.textContent += cssText;
styleUtil.clearStyleRules(this.style);
this._properties = null;
},
get _styleProperties() {
if (!this._properties) {
styleProperties.decorateStyles(this._styles);
this._styles._scopeStyleProperties = null;
this._properties = styleProperties.scopePropertiesFromStyles(this._styles);
}
return this._properties;
},
_needsStyleProperties: function () {
},
_computeStyleProperties: function () {
return this._styleProperties;
}
};
return api;
}();

(function () {
Polymer.StyleCache = function () {
this.cache = {};
};
Polymer.StyleCache.prototype = {
MAX: 100,
store: function (is, data, keyValues, keyStyles) {
data.keyValues = keyValues;
data.styles = keyStyles;
var s$ = this.cache[is] = this.cache[is] || [];
s$.push(data);
if (s$.length > this.MAX) {
s$.shift();
}
},
retrieve: function (is, keyValues, keyStyles) {
var cache = this.cache[is];
if (cache) {
for (var i = cache.length - 1, data; i >= 0; i--) {
data = cache[i];
if (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {
return data;
}
}
}
},
clear: function () {
this.cache = {};
},
_objectsEqual: function (target, source) {
for (var i in target) {
if (target[i] !== source[i]) {
return false;
}
}
if (Array.isArray(target)) {
return target.length === source.length;
}
return true;
}
};
}());

(function () {
var serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;
var propertyUtils = Polymer.StyleProperties;
var styleTransformer = Polymer.StyleTransformer;
var styleUtil = Polymer.StyleUtil;
var styleDefaults = Polymer.StyleDefaults;
var nativeShadow = Polymer.Settings.useNativeShadow;
Polymer.Base._addFeature({
_prepStyleProperties: function () {
this._ownStylePropertyNames = this._styles ? propertyUtils.decorateStyles(this._styles) : [];
},
_setupStyleProperties: function () {
this.customStyle = {};
},
_needsStyleProperties: function () {
return Boolean(this._ownStylePropertyNames && this._ownStylePropertyNames.length);
},
_beforeAttached: function () {
if (!this._scopeSelector && this._needsStyleProperties()) {
this._updateStyleProperties();
}
},
_updateStyleProperties: function () {
var info, scope = this.domHost || styleDefaults;
if (!scope._styleCache) {
scope._styleCache = new Polymer.StyleCache();
}
var scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);
info = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);
var scopeCached = Boolean(info);
if (scopeCached) {
this._styleProperties = info._styleProperties;
} else {
this._computeStyleProperties(scopeData.properties);
}
this._computeOwnStyleProperties();
if (!scopeCached) {
info = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);
}
var globalCached = Boolean(info) && !scopeCached;
style = this._applyStyleProperties(info);
if (!scopeCached) {
var cacheableStyle = style;
if (nativeShadow) {
cacheableStyle = style.cloneNode ? style.cloneNode(true) : Object.create(style || null);
}
info = {
style: cacheableStyle,
_scopeSelector: this._scopeSelector,
_styleProperties: this._styleProperties
};
scope._styleCache.store(this.is, info, scopeData.key, this._styles);
if (!globalCached) {
styleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);
}
}
},
_computeStyleProperties: function (scopeProps) {
var scope = this.domHost || styleDefaults;
if (!scope._styleProperties) {
scope._computeStyleProperties();
}
var props = Object.create(scope._styleProperties);
this.mixin(props, propertyUtils.hostPropertiesFromStyles(this._styles));
scopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;
this.mixin(props, scopeProps);
this.mixin(props, propertyUtils.scopePropertiesFromStyles(this._styles));
this.mixin(props, this.customStyle);
propertyUtils.reify(props);
this._styleProperties = props;
},
_computeOwnStyleProperties: function () {
var props = {};
for (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {
n = this._ownStylePropertyNames[i];
props[n] = this._styleProperties[n];
}
this._ownStyleProperties = props;
},
_scopeCount: 0,
_applyStyleProperties: function (info) {
var oldScopeSelector = this._scopeSelector;
this._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;
style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);
if ((style || oldScopeSelector) && !nativeShadow) {
propertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);
}
return style || {};
},
serializeValueToAttribute: function (value, attribute, node) {
node = node || this;
if (attribute === 'class') {
var host = node === this ? this.domHost || this.dataHost : this;
if (host) {
value = host._scopeElementClass(node, value);
}
}
node = Polymer.dom(node);
serializeValueToAttribute.call(this, value, attribute, node);
},
_scopeElementClass: function (element, selector) {
if (!nativeShadow && !this._scopeCssViaAttr) {
selector += (selector ? ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');
}
return selector;
},
updateStyles: function () {
if (this.isAttached) {
if (this._needsStyleProperties()) {
this._updateStyleProperties();
} else {
this._styleProperties = null;
}
if (this._styleCache) {
this._styleCache.clear();
}
this._updateRootStyles();
}
},
_updateRootStyles: function (root) {
root = root || this.root;
var c$ = Polymer.dom(root)._query(function (e) {
return e.shadyRoot || e.shadowRoot;
});
for (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {
if (c.updateStyles) {
c.updateStyles();
}
}
}
});
Polymer.updateStyles = function () {
styleDefaults._styleCache.clear();
Polymer.Base._updateRootStyles(document);
};
var styleCache = new Polymer.StyleCache();
Polymer.customStyleCache = styleCache;
var SCOPE_NAME = styleTransformer.SCOPE_NAME;
var XSCOPE_NAME = propertyUtils.XSCOPE_NAME;
}());

Polymer.Base._addFeature({
_registerFeatures: function () {
this._prepIs();
this._prepAttributes();
this._prepExtends();
this._prepConstructor();
this._prepTemplate();
this._prepStyles();
this._prepStyleProperties();
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepBindings();
this._prepShady();
},
_prepBehavior: function (b) {
this._addPropertyEffects(b.properties);
this._addComplexObserverEffects(b.observers);
this._addHostAttributes(b.hostAttributes);
},
_initFeatures: function () {
this._poolContent();
this._setupConfigure();
this._setupStyleProperties();
this._pushHost();
this._stampTemplate();
this._popHost();
this._marshalAnnotationReferences();
this._marshalHostAttributes();
this._setupDebouncers();
this._marshalInstanceEffects();
this._marshalBehaviors();
this._marshalAttributes();
this._tryReady();
},
_marshalBehavior: function (b) {
this._listenListeners(b.listeners);
}
});

(function () {
var nativeShadow = Polymer.Settings.useNativeShadow;
var propertyUtils = Polymer.StyleProperties;
var styleUtil = Polymer.StyleUtil;
var styleDefaults = Polymer.StyleDefaults;
Polymer({
is: 'custom-style',
extends: 'style',
created: function () {
this._appliesToDocument = this.parentNode.localName !== 'dom-module';
if (this._appliesToDocument) {
var e = this.__appliedElement || this;
var rules = styleUtil.rulesForStyle(e);
propertyUtils.decorateStyles([e]);
this._rulesToDefaultProperties(rules);
this.async(this._applyStyle);
}
},
_applyStyle: function () {
var e = this.__appliedElement || this;
this._computeStyleProperties();
var props = this._styleProperties;
var self = this;
e.textContent = styleUtil.toCssText(styleUtil.rulesForStyle(e), function (rule) {
if (rule.selector === ':root') {
rule.selector = 'body';
}
var css = rule.cssText = rule.parsedCssText;
if (rule.propertyInfo.cssText) {
css = css.replace(propertyUtils.rx.VAR_ASSIGN, '');
rule.cssText = propertyUtils.valueForProperties(css, props);
}
if (!nativeShadow) {
Polymer.StyleTransformer.rootRule(rule);
}
});
},
_rulesToDefaultProperties: function (rules) {
styleUtil.forEachStyleRule(rules, function (rule) {
if (!rule.propertyInfo.properties) {
rule.cssText = '';
}
});
var cssText = styleUtil.parser.stringify(rules, true);
if (cssText) {
styleDefaults.applyCss(cssText);
}
}
});
}());

Polymer.Templatizer = {
properties: { _hideTemplateChildren: { observer: '_hideTemplateChildrenChanged' } },
_templatizerStatic: {
count: 0,
callbacks: {},
debouncer: null
},
_instanceProps: Polymer.nob,
created: function () {
this._templatizerId = this._templatizerStatic.count++;
},
templatize: function (template) {
if (!template._content) {
template._content = template.content;
}
if (template._content._ctor) {
this.ctor = template._content._ctor;
this._prepParentProperties(this.ctor.prototype, template);
return;
}
var archetype = Object.create(Polymer.Base);
this._customPrepAnnotations(archetype, template);
archetype._prepEffects();
this._customPrepEffects(archetype);
archetype._prepBehaviors();
archetype._prepBindings();
this._prepParentProperties(archetype, template);
archetype._notifyPath = this._notifyPathImpl;
archetype._scopeElementClass = this._scopeElementClassImpl;
archetype.listen = this._listenImpl;
var _constructor = this._constructorImpl;
var ctor = function TemplateInstance(model, host) {
_constructor.call(this, model, host);
};
ctor.prototype = archetype;
archetype.constructor = ctor;
template._content._ctor = ctor;
this.ctor = ctor;
},
_getRootDataHost: function () {
return this.dataHost && this.dataHost._rootDataHost || this.dataHost;
},
_hideTemplateChildrenChanged: function (hidden) {
if (this._hideChildren) {
this._hideChildren(hidden);
}
},
_debounceTemplate: function (fn) {
this._templatizerStatic.callbacks[this._templatizerId] = fn.bind(this);
this._templatizerStatic.debouncer = Polymer.Debounce(this._templatizerStatic.debouncer, this._flushTemplates.bind(this, true));
},
_flushTemplates: function (debouncerExpired) {
var db = this._templatizerStatic.debouncer;
while (debouncerExpired || db && db.finish) {
db.stop();
var cbs = this._templatizerStatic.callbacks;
this._templatizerStatic.callbacks = {};
for (var id in cbs) {
cbs[id]();
}
debouncerExpired = false;
}
},
_customPrepEffects: function (archetype) {
var parentProps = archetype._parentProps;
for (var prop in parentProps) {
archetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));
}
},
_customPrepAnnotations: function (archetype, template) {
archetype._template = template;
var c = template._content;
if (!c._notes) {
var rootDataHost = archetype._rootDataHost;
if (rootDataHost) {
Polymer.Annotations.prepElement = rootDataHost._prepElement.bind(rootDataHost);
}
c._notes = Polymer.Annotations.parseAnnotations(template);
Polymer.Annotations.prepElement = null;
this._processAnnotations(c._notes);
}
archetype._notes = c._notes;
archetype._parentProps = c._parentProps;
},
_prepParentProperties: function (archetype, template) {
var parentProps = this._parentProps = archetype._parentProps;
if (this._forwardParentProp && parentProps) {
var proto = archetype._parentPropProto;
var prop;
if (!proto) {
for (prop in this._instanceProps) {
delete parentProps[prop];
}
proto = archetype._parentPropProto = Object.create(null);
if (template != this) {
Polymer.Bind.prepareModel(proto);
}
for (prop in parentProps) {
var parentProp = '_parent_' + prop;
var effects = [
{
kind: 'function',
effect: this._createForwardPropEffector(prop)
},
{ kind: 'notify' }
];
Polymer.Bind._createAccessors(proto, parentProp, effects);
}
}
if (template != this) {
Polymer.Bind.prepareInstance(template);
template._forwardParentProp = this._forwardParentProp.bind(this);
}
this._extendTemplate(template, proto);
}
},
_createForwardPropEffector: function (prop) {
return function (source, value) {
this._forwardParentProp(prop, value);
};
},
_createHostPropEffector: function (prop) {
return function (source, value) {
this.dataHost['_parent_' + prop] = value;
};
},
_extendTemplate: function (template, proto) {
Object.getOwnPropertyNames(proto).forEach(function (n) {
var val = template[n];
var pd = Object.getOwnPropertyDescriptor(proto, n);
Object.defineProperty(template, n, pd);
if (val !== undefined) {
template._propertySet(n, val);
}
});
},
_forwardInstancePath: function (inst, path, value) {
},
_notifyPathImpl: function (path, value) {
var dataHost = this.dataHost;
var dot = path.indexOf('.');
var root = dot < 0 ? path : path.slice(0, dot);
dataHost._forwardInstancePath.call(dataHost, this, path, value);
if (root in dataHost._parentProps) {
dataHost.notifyPath('_parent_' + path, value);
}
},
_pathEffector: function (path, value, fromAbove) {
if (this._forwardParentPath) {
if (path.indexOf('_parent_') === 0) {
this._forwardParentPath(path.substring(8), value);
}
}
Polymer.Base._pathEffector.apply(this, arguments);
},
_constructorImpl: function (model, host) {
this._rootDataHost = host._getRootDataHost();
this._setupConfigure(model);
this._pushHost(host);
this.root = this.instanceTemplate(this._template);
this.root.__styleScoped = true;
this._popHost();
this._marshalAnnotatedNodes();
this._marshalInstanceEffects();
this._marshalAnnotatedListeners();
var children = [];
for (var n = this.root.firstChild; n; n = n.nextSibling) {
children.push(n);
n._templateInstance = this;
}
this._children = children;
this._tryReady();
},
_listenImpl: function (node, eventName, methodName) {
var model = this;
var host = this._rootDataHost;
var handler = host._createEventHandler(node, eventName, methodName);
var decorated = function (e) {
e.model = model;
handler(e);
};
host._listen(node, eventName, decorated);
},
_scopeElementClassImpl: function (node, value) {
var host = this._rootDataHost;
if (host) {
return host._scopeElementClass(node, value);
}
},
stamp: function (model) {
model = model || {};
if (this._parentProps) {
for (var prop in this._parentProps) {
model[prop] = this['_parent_' + prop];
}
}
return new this.ctor(model, this);
}
};

Polymer({
is: 'dom-template',
extends: 'template',
behaviors: [Polymer.Templatizer],
ready: function () {
this.templatize(this);
}
});

Polymer._collections = new WeakMap();
Polymer.Collection = function (userArray) {
Polymer._collections.set(userArray, this);
this.userArray = userArray;
this.store = userArray.slice();
this.initMap();
};
Polymer.Collection.prototype = {
constructor: Polymer.Collection,
initMap: function () {
var omap = this.omap = new WeakMap();
var pmap = this.pmap = {};
var s = this.store;
for (var i = 0; i < s.length; i++) {
var item = s[i];
if (item && typeof item == 'object') {
omap.set(item, i);
} else {
pmap[item] = i;
}
}
},
add: function (item) {
var key = this.store.push(item) - 1;
if (item && typeof item == 'object') {
this.omap.set(item, key);
} else {
this.pmap[item] = key;
}
return key;
},
removeKey: function (key) {
this._removeFromMap(this.store[key]);
delete this.store[key];
},
_removeFromMap: function (item) {
if (typeof item == 'object') {
this.omap.delete(item);
} else {
delete this.pmap[item];
}
},
remove: function (item) {
var key = this.getKey(item);
this.removeKey(key);
return key;
},
getKey: function (item) {
if (typeof item == 'object') {
return this.omap.get(item);
} else {
return this.pmap[item];
}
},
getKeys: function () {
return Object.keys(this.store);
},
setItem: function (key, value) {
this.store[key] = value;
},
getItem: function (key) {
return this.store[key];
},
getItems: function () {
var items = [], store = this.store;
for (var key in store) {
items.push(store[key]);
}
return items;
},
applySplices: function (splices) {
var keySplices = [];
for (var i = 0; i < splices.length; i++) {
var j, o, key, s = splices[i];
var removed = [];
for (j = 0; j < s.removed.length; j++) {
o = s.removed[j];
key = this.remove(o);
removed.push(key);
}
var added = [];
for (j = 0; j < s.addedCount; j++) {
o = this.userArray[s.index + j];
key = this.add(o);
added.push(key);
}
keySplices.push({
index: s.index,
removed: removed,
removedItems: s.removed,
added: added
});
}
return keySplices;
}
};
Polymer.Collection.get = function (userArray) {
return Polymer._collections.get(userArray) || new Polymer.Collection(userArray);
};

Polymer({
is: 'dom-repeat',
extends: 'template',
properties: {
items: { type: Array },
as: {
type: String,
value: 'item'
},
indexAs: {
type: String,
value: 'index'
},
sort: {
type: Function,
observer: '_sortChanged'
},
filter: {
type: Function,
observer: '_filterChanged'
},
observe: {
type: String,
observer: '_observeChanged'
},
delay: Number
},
behaviors: [Polymer.Templatizer],
observers: ['_itemsChanged(items.*)'],
detached: function () {
if (this.rows) {
for (var i = 0; i < this.rows.length; i++) {
this._detachRow(i);
}
}
this.rows = null;
},
ready: function () {
this._instanceProps = { __key__: true };
this._instanceProps[this.as] = true;
this._instanceProps[this.indexAs] = true;
if (!this.ctor) {
this.templatize(this);
}
},
_sortChanged: function () {
var dataHost = this._getRootDataHost();
var sort = this.sort;
this._sortFn = sort && (typeof sort == 'function' ? sort : function () {
return dataHost[sort].apply(dataHost, arguments);
});
this._fullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_filterChanged: function () {
var dataHost = this._getRootDataHost();
var filter = this.filter;
this._filterFn = filter && (typeof filter == 'function' ? filter : function () {
return dataHost[filter].apply(dataHost, arguments);
});
this._fullRefresh = true;
if (this.items) {
this._debounceTemplate(this._render);
}
},
_observeChanged: function () {
this._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');
},
_itemsChanged: function (change) {
if (change.path == 'items') {
this.collection = this.items ? Polymer.Collection.get(this.items) : null;
this._splices = [];
this._fullRefresh = true;
this._debounceTemplate(this._render);
} else if (change.path == 'items.splices') {
this._splices = this._splices.concat(change.value.keySplices);
this._debounceTemplate(this._render);
} else {
var subpath = change.path.slice(6);
this._forwardItemPath(subpath, change.value);
this._checkObservedPaths(subpath);
}
},
_checkObservedPaths: function (path) {
if (this._observePaths) {
path = path.substring(path.indexOf('.') + 1);
var paths = this._observePaths;
for (var i = 0; i < paths.length; i++) {
if (path.indexOf(paths[i]) === 0) {
this._fullRefresh = true;
if (this.delay) {
this.debounce('render', this._render, this.delay);
} else {
this._debounceTemplate(this._render);
}
return;
}
}
}
},
render: function () {
this._fullRefresh = true;
this.debounce('render', this._render);
this._flushTemplates();
},
_render: function () {
var c = this.collection;
if (!this._fullRefresh) {
if (this._sortFn) {
this._applySplicesViewSort(this._splices);
} else {
if (this._filterFn) {
this._fullRefresh = true;
} else {
this._applySplicesArraySort(this._splices);
}
}
}
if (this._fullRefresh) {
this._sortAndFilter();
this._fullRefresh = false;
}
this._splices = [];
var rowForKey = this._rowForKey = {};
var keys = this._orderedKeys;
this.rows = this.rows || [];
for (var i = 0; i < keys.length; i++) {
var key = keys[i];
var item = c.getItem(key);
var row = this.rows[i];
rowForKey[key] = i;
if (!row) {
this.rows.push(row = this._insertRow(i, null, item));
}
row[this.as] = item;
row.__key__ = key;
row[this.indexAs] = i;
}
for (; i < this.rows.length; i++) {
this._detachRow(i);
}
this.rows.splice(keys.length, this.rows.length - keys.length);
this.fire('dom-change');
},
_sortAndFilter: function () {
var c = this.collection;
if (!this._sortFn) {
this._orderedKeys = [];
var items = this.items;
if (items) {
for (var i = 0; i < items.length; i++) {
this._orderedKeys.push(c.getKey(items[i]));
}
}
} else {
this._orderedKeys = c ? c.getKeys() : [];
}
if (this._filterFn) {
this._orderedKeys = this._orderedKeys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
if (this._sortFn) {
this._orderedKeys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
}
},
_keySort: function (a, b) {
return this.collection.getKey(a) - this.collection.getKey(b);
},
_applySplicesViewSort: function (splices) {
var c = this.collection;
var keys = this._orderedKeys;
var rows = this.rows;
var removedRows = [];
var addedKeys = [];
var pool = [];
var sortFn = this._sortFn || this._keySort.bind(this);
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
var idx = this._rowForKey[s.removed[i]];
if (idx != null) {
removedRows.push(idx);
}
}
for (var i = 0; i < s.added.length; i++) {
addedKeys.push(s.added[i]);
}
}, this);
if (removedRows.length) {
removedRows.sort();
for (var i = removedRows.length - 1; i >= 0; i--) {
var idx = removedRows[i];
pool.push(this._detachRow(idx));
rows.splice(idx, 1);
keys.splice(idx, 1);
}
}
if (addedKeys.length) {
if (this._filterFn) {
addedKeys = addedKeys.filter(function (a) {
return this._filterFn(c.getItem(a));
}, this);
}
addedKeys.sort(function (a, b) {
return this._sortFn(c.getItem(a), c.getItem(b));
}.bind(this));
var start = 0;
for (var i = 0; i < addedKeys.length; i++) {
start = this._insertRowIntoViewSort(start, addedKeys[i], pool);
}
}
},
_insertRowIntoViewSort: function (start, key, pool) {
var c = this.collection;
var item = c.getItem(key);
var end = this.rows.length - 1;
var idx = -1;
var sortFn = this._sortFn || this._keySort.bind(this);
while (start <= end) {
var mid = start + end >> 1;
var midKey = this._orderedKeys[mid];
var cmp = sortFn(c.getItem(midKey), item);
if (cmp < 0) {
start = mid + 1;
} else if (cmp > 0) {
end = mid - 1;
} else {
idx = mid;
break;
}
}
if (idx < 0) {
idx = end + 1;
}
this._orderedKeys.splice(idx, 0, key);
this.rows.splice(idx, 0, this._insertRow(idx, pool, c.getItem(key)));
return idx;
},
_applySplicesArraySort: function (splices) {
var keys = this._orderedKeys;
var pool = [];
splices.forEach(function (s) {
for (var i = 0; i < s.removed.length; i++) {
pool.push(this._detachRow(s.index + i));
}
this.rows.splice(s.index, s.removed.length);
}, this);
var c = this.collection;
splices.forEach(function (s) {
var args = [
s.index,
s.removed.length
].concat(s.added);
keys.splice.apply(keys, args);
for (var i = 0; i < s.added.length; i++) {
var item = c.getItem(s.added[i]);
var row = this._insertRow(s.index + i, pool, item);
this.rows.splice(s.index + i, 0, row);
}
}, this);
},
_detachRow: function (idx) {
var row = this.rows[idx];
var parentNode = Polymer.dom(this).parentNode;
for (var i = 0; i < row._children.length; i++) {
var el = row._children[i];
Polymer.dom(row.root).appendChild(el);
}
return row;
},
_insertRow: function (idx, pool, item) {
var row = pool && pool.pop() || this._generateRow(idx, item);
var beforeRow = this.rows[idx];
var beforeNode = beforeRow ? beforeRow._children[0] : this;
var parentNode = Polymer.dom(this).parentNode;
Polymer.dom(parentNode).insertBefore(row.root, beforeNode);
return row;
},
_generateRow: function (idx, item) {
var model = { __key__: this.collection.getKey(item) };
model[this.as] = item;
model[this.indexAs] = idx;
var row = this.stamp(model);
return row;
},
_hideChildren: function (hidden) {
if (this.rows) {
for (var i = 0; i < this.rows.length; i++) {
var c$ = this.rows[i]._children;
for (var j = 0; j < c$.length; j++) {
var c = c$[j];
if (c.style) {
c.style.display = hidden ? 'none' : '';
}
c._hideTemplateChildren = hidden;
}
}
}
},
_forwardInstancePath: function (row, path, value) {
if (path.indexOf(this.as + '.') === 0) {
this.notifyPath('items.' + row.__key__ + '.' + path.slice(this.as.length + 1), value);
return true;
}
},
_forwardParentProp: function (prop, value) {
if (this.rows) {
this.rows.forEach(function (row) {
row[prop] = value;
}, this);
}
},
_forwardParentPath: function (path, value) {
if (this.rows) {
this.rows.forEach(function (row) {
row.notifyPath(path, value, true);
}, this);
}
},
_forwardItemPath: function (path, value) {
if (this._rowForKey) {
var dot = path.indexOf('.');
var key = path.substring(0, dot < 0 ? path.length : dot);
var idx = this._rowForKey[key];
var row = this.rows[idx];
if (row) {
if (dot >= 0) {
path = this.as + '.' + path.substring(dot + 1);
row.notifyPath(path, value, true);
} else {
row[this.as] = value;
}
}
}
},
modelForElement: function (el) {
var model;
while (el) {
if (model = el._templateInstance) {
if (model.dataHost != this) {
el = model.dataHost;
} else {
return model;
}
} else {
el = el.parentNode;
}
}
},
itemForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.as];
},
keyForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance.__key__;
},
indexForElement: function (el) {
var instance = this.modelForElement(el);
return instance && instance[this.indexAs];
}
});

Polymer({
is: 'array-selector',
properties: {
items: {
type: Array,
observer: '_itemsChanged'
},
selected: {
type: Object,
notify: true
},
toggle: Boolean,
multi: Boolean
},
_itemsChanged: function () {
if (Array.isArray(this.selected)) {
for (var i = 0; i < this.selected.length; i++) {
this.unlinkPaths('selected.' + i);
}
} else {
this.unlinkPaths('selected');
}
if (this.multi) {
this.selected = [];
} else {
this.selected = null;
}
},
deselect: function (item) {
if (this.multi) {
var scol = Polymer.Collection.get(this.selected);
var sidx = this.selected.indexOf(item);
if (sidx >= 0) {
var skey = scol.getKey(item);
this.splice('selected', sidx, 1);
this.unlinkPaths('selected.' + skey);
return true;
}
} else {
this.selected = null;
this.unlinkPaths('selected');
}
},
select: function (item) {
var icol = Polymer.Collection.get(this.items);
var key = icol.getKey(item);
if (this.multi) {
var scol = Polymer.Collection.get(this.selected);
var skey = scol.getKey(item);
if (skey >= 0) {
this.deselect(item);
} else if (this.toggle) {
this.push('selected', item);
this.async(function () {
skey = scol.getKey(item);
this.linkPaths('selected.' + skey, 'items.' + key);
});
}
} else {
if (this.toggle && item == this.selected) {
this.deselect();
} else {
this.linkPaths('selected', 'items.' + key);
this.selected = item;
}
}
}
});

Polymer({
is: 'dom-if',
extends: 'template',
properties: {
'if': {
type: Boolean,
value: false
},
restamp: {
type: Boolean,
value: false
}
},
behaviors: [Polymer.Templatizer],
observers: ['_queueRender(if, restamp)'],
_queueRender: function () {
this._debounceTemplate(this._render);
},
detached: function () {
this._teardownInstance();
},
attached: function () {
if (this.if && this.ctor) {
this.async(this._ensureInstance);
}
},
render: function () {
this._flushTemplates();
},
_render: function () {
if (this.if) {
if (!this.ctor) {
this._wrapTextNodes(this._content || this.content);
this.templatize(this);
}
this._ensureInstance();
this._hideTemplateChildren = false;
} else if (this.restamp) {
this._teardownInstance();
}
if (!this.restamp && this._instance) {
this._hideTemplateChildren = !this.if;
}
if (this.if != this._lastIf) {
this.fire('dom-change');
this._lastIf = this.if;
}
},
_ensureInstance: function () {
if (!this._instance) {
this._instance = this.stamp();
var root = this._instance.root;
var parent = Polymer.dom(Polymer.dom(this).parentNode);
parent.insertBefore(root, this);
}
},
_teardownInstance: function () {
if (this._instance) {
var c = this._instance._children;
if (c) {
var parent = Polymer.dom(Polymer.dom(c[0]).parentNode);
c.forEach(function (n) {
parent.removeChild(n);
});
}
this._instance = null;
}
},
_wrapTextNodes: function (root) {
for (var n = root.firstChild; n; n = n.nextSibling) {
if (n.nodeType === Node.TEXT_NODE) {
var s = document.createElement('span');
root.insertBefore(s, n);
s.appendChild(n);
n = s;
}
}
},
_hideChildren: function (hidden) {
if (this._instance) {
var c$ = this._instance._children;
for (var i = 0; i < c$.length; i++) {
var c = c$[i];
c.style.display = hidden ? 'none' : '';
c._hideTemplateChildren = hidden;
}
}
},
_forwardParentProp: function (prop, value) {
if (this._instance) {
this._instance[prop] = value;
}
},
_forwardParentPath: function (path, value) {
if (this._instance) {
this._instance.notifyPath(path, value, true);
}
}
});

Polymer.ImportStatus = {
_ready: false,
_callbacks: [],
whenLoaded: function (cb) {
if (this._ready) {
cb();
} else {
this._callbacks.push(cb);
}
},
_importsLoaded: function () {
this._ready = true;
this._callbacks.forEach(function (cb) {
cb();
});
this._callbacks = [];
}
};
window.addEventListener('load', function () {
Polymer.ImportStatus._importsLoaded();
});
if (window.HTMLImports) {
HTMLImports.whenReady(function () {
Polymer.ImportStatus._importsLoaded();
});
}

Polymer({
is: 'dom-bind',
extends: 'template',
created: function () {
Polymer.ImportStatus.whenLoaded(this._readySelf.bind(this));
},
_registerFeatures: function () {
this._prepExtends();
this._prepConstructor();
},
_insertChildren: function () {
var parentDom = Polymer.dom(Polymer.dom(this).parentNode);
parentDom.insertBefore(this.root, this);
},
_removeChildren: function () {
if (this._children) {
for (var i = 0; i < this._children.length; i++) {
this.root.appendChild(this._children[i]);
}
}
},
_initFeatures: function () {
},
_scopeElementClass: function (element, selector) {
if (this.dataHost) {
return this.dataHost._scopeElementClass(element, selector);
} else {
return selector;
}
},
attached: function () {
if (!this._children) {
this._template = this;
this._prepAnnotations();
this._prepEffects();
this._prepBehaviors();
this._prepBindings();
Polymer.Base._initFeatures.call(this);
this._children = Array.prototype.slice.call(this.root.childNodes);
}
this._insertChildren();
this.fire('dom-change');
},
detached: function () {
this._removeChildren();
}
});</script>

<!-- The Polymer v0.8 rc doesn't have this :( -->
<style>
  /*******************************
            Flex Layout
  *******************************/
  .layout.horizontal,
  .layout.horizontal-reverse,
  .layout.vertical,
  .layout.vertical-reverse {
    display: -ms-flexbox;
    display: -webkit-flex;
    display: flex;
  }
  .layout.inline {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;
  }
  .layout.horizontal {
    -ms-flex-direction: row;
    -webkit-flex-direction: row;
    flex-direction: row;
  }
  .layout.horizontal-reverse {
    -ms-flex-direction: row-reverse;
    -webkit-flex-direction: row-reverse;
    flex-direction: row-reverse;
  }
  .layout.vertical {
    -ms-flex-direction: column;
    -webkit-flex-direction: column;
    flex-direction: column;
  }
  .layout.vertical-reverse {
    -ms-flex-direction: column-reverse;
    -webkit-flex-direction: column-reverse;
    flex-direction: column-reverse;
  }
  .layout.wrap {
    -ms-flex-wrap: wrap;
    -webkit-flex-wrap: wrap;
    flex-wrap: wrap;
  }
  .layout.wrap-reverse {
    -ms-flex-wrap: wrap-reverse;
    -webkit-flex-wrap: wrap-reverse;
    flex-wrap: wrap-reverse;
  }
  .flex-auto {
    -ms-flex: 1 1 auto;
    -webkit-flex: 1 1 auto;
    flex: 1 1 auto;
  }
  .flex-none {
    -ms-flex: none;
    -webkit-flex: none;
    flex: none;
  }
  .flex,
  .flex-1 {
    -ms-flex: 1;
    -webkit-flex: 1;
    flex: 1;
  }
  .flex-2 {
    -ms-flex: 2;
    -webkit-flex: 2;
    flex: 2;
  }
  .flex-3 {
    -ms-flex: 3;
    -webkit-flex: 3;
    flex: 3;
  }
  .flex-4 {
    -ms-flex: 4;
    -webkit-flex: 4;
    flex: 4;
  }
  .flex-5 {
    -ms-flex: 5;
    -webkit-flex: 5;
    flex: 5;
  }
  .flex-6 {
    -ms-flex: 6;
    -webkit-flex: 6;
    flex: 6;
  }
  .flex-7 {
    -ms-flex: 7;
    -webkit-flex: 7;
    flex: 7;
  }
  .flex-8 {
    -ms-flex: 8;
    -webkit-flex: 8;
    flex: 8;
  }
  .flex-9 {
    -ms-flex: 9;
    -webkit-flex: 9;
    flex: 9;
  }
  .flex-10 {
    -ms-flex: 10;
    -webkit-flex: 10;
    flex: 10;
  }
  .flex-11 {
    -ms-flex: 11;
    -webkit-flex: 11;
    flex: 11;
  }
  .flex-12 {
    -ms-flex: 12;
    -webkit-flex: 12;
    flex: 12;
  }
  /* alignment in cross axis */
  .layout.start {
    -ms-flex-align: start;
    -webkit-align-items: flex-start;
    align-items: flex-start;
  }
  .layout.center,
  .layout.center-center {
    -ms-flex-align: center;
    -webkit-align-items: center;
    align-items: center;
  }
  .layout.end {
    -ms-flex-align: end;
    -webkit-align-items: flex-end;
    align-items: flex-end;
  }
  /* alignment in main axis */
  .layout.start-justified {
    -ms-flex-pack: start;
    -webkit-justify-content: flex-start;
    justify-content: flex-start;
  }
  .layout.center-justified,
  .layout.center-center {
    -ms-flex-pack: center;
    -webkit-justify-content: center;
    justify-content: center;
  }
  .layout.end-justified {
    -ms-flex-pack: end;
    -webkit-justify-content: flex-end;
    justify-content: flex-end;
  }
  .layout.around-justified {
    -ms-flex-pack: around;
    -webkit-justify-content: space-around;
    justify-content: space-around;
  }
  .layout.justified {
    -ms-flex-pack: justify;
    -webkit-justify-content: space-between;
    justify-content: space-between;
  }
  /* self alignment */
  .self-start {
    -ms-align-self: flex-start;
    -webkit-align-self: flex-start;
    align-self: flex-start;
  }
  .self-center {
    -ms-align-self: center;
    -webkit-align-self: center;
    align-self: center;
  }
  .self-end {
    -ms-align-self: flex-end;
    -webkit-align-self: flex-end;
    align-self: flex-end;
  }
  .self-stretch {
    -ms-align-self: stretch;
    -webkit-align-self: stretch;
    align-self: stretch;
  }
  /*******************************
            Other Layout
  *******************************/
  .block {
    display: block;
  }
  /* IE 10 support for HTML5 hidden attr */
  [hidden] {
    display: none !important;
  }
  .invisible {
    visibility: hidden !important;
  }
  .relative {
    position: relative;
  }
  .fit {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
  body.fullbleed {
    margin: 0;
    height: 100vh;
  }
  .scroll {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
  }
  /* fixed position */
  .fixed-bottom,
  .fixed-left,
  .fixed-right,
  .fixed-top {
    position: fixed;
  }
  .fixed-top {
    top: 0;
    left: 0;
    right: 0;
  }
  .fixed-right {
    top: 0;
    right: 0;
    bottom: 0;
  }
  .fixed-bottom {
    right: 0;
    bottom: 0;
    left: 0;
  }
  .fixed-left {
    top: 0;
    bottom: 0;
    left: 0;
  }
</style>





<script>
  Polymer({
    is : 'ecosis-theme-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Theme;
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      var c = 0;
      for( var i = 0; i < this.schema.length; i++ ) {
        if( this.schema[i].name == 'Keywords' ) continue;

        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( c % 2 == 0 ) col1 += input;
        else col2 += input;
        c++;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      this.addEventListener('update', this.onUpdate.bind(this));

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {
        if( this.schema[i].name == 'Keywords' ) continue;

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');
        var value = ecosis.ds.getDatasetExtra(this.schema[i].name).value || '';

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.getDatasetExtra(this.schema[i].name+' Other').value || '';
        }

        ele.setValue(value, other);
      }
    },

    onUpdate : function(e) {
      var attr = e.detail.attribute;
      var value = e.detail.value;
      ecosis.ds.setDatasetExtra(attr, value);
    }


  })
</script>

<script>
  Polymer({
    is : 'ecosis-measurement-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Measurement;
    },

    attached : function() {
      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {
        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      this.addEventListener('update', this.onUpdate.bind(this));

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');
        var value = ecosis.ds.getDatasetExtra(this.schema[i].name).value || '';

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.getDatasetExtra(this.schema[i].name+' Other').value || '';
        }

        ele.setValue(value, other);
      }
    },

    onUpdate : function(e) {
      var attr = e.detail.attribute;
      var value = e.detail.value;
      ecosis.ds.setDatasetExtra(attr, value);
    }


  })
</script>

<script>
  Polymer({
    is : 'ecosis-processing-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions['Processing Information'];
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {

        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      this.addEventListener('update', this.onUpdate.bind(this));

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');
        var value = ecosis.ds.getDatasetExtra(this.schema[i].name).value || '';

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.getDatasetExtra(this.schema[i].name+' Other').value || '';
        }

        ele.setValue(value, other);
      }
    },

    onUpdate : function(e) {
      var attr = e.detail.attribute;
      var value = e.detail.value;
      ecosis.ds.setDatasetExtra(attr, value);
    }


  })
</script>

<script>
  Polymer({
    is : 'ecosis-instrument-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Instrument;
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {

        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      this.addEventListener('update', this.onUpdate.bind(this));

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {
        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');
        var value = ecosis.ds.getDatasetExtra(this.schema[i].name).value || '';

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.getDatasetExtra(this.schema[i].name+' Other').value || '';
        }

        ele.setValue(value, other);
      }
    },

    onUpdate : function(e) {
      var attr = e.detail.attribute;
      var value = e.detail.value;
      ecosis.ds.setDatasetExtra(attr, value);
    }


  })
</script>

<script>
  Polymer({
    is : 'ecosis-citation-input',

    ready : function() {
      this.schema = ecosis.ds.metadataDefinitions.Citation;

      this.packageAttrMap = {
        'Author' : 'author',
        'Author Email' : 'author_email',
        'Maintainer' : 'maintainer',
        'Maintainer Email' : 'maintainer_email'
      }
    },

    attached : function() {

      var col1 = '';
      var col2 = '';

      for( var i = 0; i < this.schema.length; i++ ) {
        if( this.schema[i].name == 'Website' ) continue;
        var input = '<ecosis-schema-input metadata="'+this.schema[i].name+'"></ecosis-schema-input>';

        if( i % 2 == 0 ) col1 += input;
        else col2 += input;
      }

      this.innerHTML =
        '<div class="row">'+
          '<div class="col-md-6">'+ col1 + '</div>'+
          '<div class="col-md-6">'+ col2 + '</div>'+
        '</div>';

      this.addEventListener('update', this.onUpdate.bind(this));

      ecosis.ds.on('load', this.setValues.bind(this));
    },

    setValues : function() {
      for( var i = 0; i < this.schema.length; i++ ) {
        if( this.schema[i].name == 'Website' ) continue;

        var ele = this.querySelector('ecosis-schema-input[metadata="'+this.schema[i].name+'"]');
        var value;

        if( this.packageAttrMap[this.schema[i].name] ) {
          value = ecosis.ds.data[this.packageAttrMap[this.schema[i].name]] || '';
        } else {
          value = ecosis.ds.getDatasetExtra(this.schema[i].name).value || '';
        }

        var other = '';
        if( this.schema[i].allowOther ) {
          other = ecosis.ds.getDatasetExtra(this.schema[i].name+' Other').value || '';
        }

        ele.setValue(value, other);
      }
    },

    onUpdate : function(e) {
      var attr = e.detail.attribute;
      var value = e.detail.value;

      if( this.packageAttrMap[attr] ) {
        ecosis.ds.data[this.packageAttrMap[attr]] = value;
      } else {
        ecosis.ds.setDatasetExtra(attr, value);
      }
    }


  })
</script>

















<script>
  Polymer({
    is : 'ecosis-metadata-docs',

    ready : function() {
      this.style.display = 'none';
      this.className = 'animated zoomIn';

      this.render();
    },

    toggle : function() {
      if( this.style.display == 'block' ) {
        this.style.display = 'none';
      } else {
        this.style.display = 'block';
      }
    },

    render : function() {
      var html = '';
      for( var cat in ecosis.ds.metadataDefinitions ) {
        var items = ecosis.ds.metadataDefinitions[cat];
        html += '<h4>'+cat+'</h4>';

        html += this.renderTable(items);
      }

      html += '<div class="help-block">If you need help adding EcoSIS metadata attributes, '+
              'please try out the <a href="https://github.com/CSTARS/ecosis-data-tool/releases" '+
              'target="_blank">EcoSIS Data Tool.</a></div>';

      this.innerHTML = html;
    },

    renderTable : function(items) {
      var table = '<div class="well"><table class="table">';

      for( var i = 0; i < items.length; i++ ) {
        var item = items[i];
        table +=
          '<tr>'+
            '<td>'+(item.level == 1 ? '<i class="fa fa-star" style="color:#2196f3"></i> ' : '')+' <b>'+item.name+'</b>' + 
            (item.description ? '<div class="help-block">'+item.description+'</div>' : '')+'</td>'+
            '<td style="text-transform: capitalize">'+item.input+'</td>'+
            '<td class="vocab" style="font-style: italic; color: #888">'+(item.vocabulary ? item.vocabulary.join(', ') : '')+'</td>'+
          '</tr>';
      }

      return table + '</table></div>';
    }
  })
</script>










</head><body><div hidden="">

<dom-module id="ecosis-schema-input">
  <style>
    :host {
      display: block;
    }
  </style>

  <template></template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-schema-input',

    properties : {
      metadata : {
        type : String
      }
    },

    attached : function() {
      this.style.display = "block";

      this.schema = ecosis.ds.metadataLookup[this.metadata];

      if( this.schema.input == 'controlled' ) {
        this.innerHTML = '<ecosis-controlled-input metadata="'+this.metadata+'"></ecosis-controlled-input>';
      } else {
        var html =
          '<div class="form-group">'+
            '<label for="'+this.schema.flat+'Input" class="col-md-3 control-label">'  +
              (this.schema.level == 1 ? '<i class="fa fa-star" style="color:#2196f3"></i> ' : '') + this.schema.name+': </label>'+
            '<div class="col-md-7">'+
              '<input type="'+this.schema.input+'" class="form-control" />';

        if( this.schema.description ) {
          html += '<div class="help-block">'+this.schema.description+'</div>';
        }

        html += '</div></div>';

        this.innerHTML = html;

        this.querySelector('input').addEventListener('change', this.trigger.bind(this));
      }
    },

    setValue : function(value, otherValue) {
      if( this.schema.input == 'controlled' ) {
        this.querySelector('ecosis-controlled-input').setValue(value, otherValue);
      } else {
        this.querySelector('input').value = value;
      }
    },

    trigger : function(e) {
      this.fire('update', {
        attribute: this.schema.name,
        value : e.currentTarget.value
      });
    }
  })
</script>

<dom-module id="ecosis-controlled-input">
  <style>
    :host {
      display: block;
    }
  </style>

  <template>
    <div class="horizontal-form">
      <div class="form-group">
        <label id="label" for="input" class="col-md-3 control-label"></label>
        <div class="col-md-7">
          <select class="form-control" id="input" on-change="onChange"></select>

          <div id="selected"></div>

          <div class="help-block" id="help" style="display:none"></div>

          <div id="otherRoot" style="display:none"></div>
        </div>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-controlled-input',

    properties : {
      metadata : {
        type : String
      }
    },

    ready : function() {
      this.selected = [];
      this.schema = ecosis.ds.metadataLookup[this.metadata];

      this.$.label.innerHTML = (this.schema.level == 1 ? '<i class="fa fa-star" style="color:#2196f3"></i> ' : '')+this.schema.name;

      this.render();

      if( this.schema.description ) {
        this.$.help.style.display = 'block';
        this.$.help.innerHTML = this.schema.description;
      }

      if( this.schema.allowOther ) {
        var html = '<input type="text" class="form-control" id="other" placeholder="Please provide other value" />';
        this.$.otherRoot.innerHTML = html;

        this.$.other = this.$.otherRoot.querySelector('input');
        this.$.other.addEventListener('change', this.onOtherChange.bind(this));
      }
    },

    render : function() {
      var options = '<option></option>';
      for( var i = 0; i < this.schema.vocabulary.length; i++ ) {
        var vocab = this.schema.vocabulary[i];
        if( this.selected.indexOf(vocab) > -1 ) continue;
        options += '<option value="'+this.schema.vocabulary[i]+'">'+this.schema.vocabulary[i]+'</option>'
      }
      this.$.input.innerHTML = options;

      var btns = '';
      for( var i = 0; i < this.selected.length; i++ ) {
        btns += '<a class="btn btn-primary btn-xs" style="margin:2px" value="'+this.selected[i]+
                '"><i class="fa fa-times"></i> '+this.selected[i]+'</a>';
      }
      this.$.selected.innerHTML = btns;

      $(this.$.selected).find('a').on('click', this.onRemove.bind(this));

      if( this.selected.indexOf('Other') == -1 ) {
        this.$.otherRoot.style.display = 'none';
      } else {
        this.$.otherRoot.style.display = 'block';
      }
    },

    onRemove : function(e) {
      var value = e.currentTarget.getAttribute('value');
      var index = this.selected.indexOf(value);
      if( index > -1 ) this.selected.splice(index, 1);

      this.fire('update', {
        attribute : this.schema.name,
        value : this.selected.join(',')
      });

      if( value == 'Other' ) {
        this.$.otherRoot.style.display = 'none';
        this.$.other.value = '';
        this.onOtherChange();
      }

      this.render();
    },

    onChange : function() {
      if( this.$.input.value == '' ) return;

      this.selected.push(this.$.input.value);

      this.fire('update', {
        attribute : this.schema.name,
        value : this.selected.join(',')
      });

      this.render();
    },

    onOtherChange : function() {
      this.fire('update', {
        attribute : this.schema.name+' Other',
        value : this.$.other.value
      });
    },

    setValue: function(value, otherValue) {
      if( !value ) value = '';

      this.selected = value.split(',');
      for( var i = 0; i < this.selected.length; i++ ) {
        this.selected[i] = this.selected[i].trim();
      }
      for( var i = this.selected.length-1; i >= 0; i-- ) {
        if( this.selected[i] == '' ) {
          this.selected.splice(i, 1);
        }
      }

      if( this.schema.allowOther && otherValue ) {
        var ele = this.querySelector("#other");
        ele.style.display = (value.length > 0) ? 'block' : 'none';
        ele.value = otherValue;
      }

      this.render();
    }
  })
</script>






<dom-module id="ecosis-location-input">
  <style>
    :host {
      display : block;
    }
  </style>
  <template>
    <div class="well">
      <div id="map" style="height: 400px"></div>
      <div class="help-block">Draw bounding box for dataset</div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-location-input',

    attached : function() {
      this.drawing = false;

      this.map = L.map(this.$.map, {
          center: [0, 0],
          zoom: 2
      });

      L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {
        attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors'
      }).addTo(this.map);

      this.map.on('click', this.onClick.bind(this));
      this.map.on('mousemove', this.onMouseMove.bind(this));

      ecosis.ds.on('load', this.onLoad.bind(this));
    },

    onLoad : function() {
      var geojson = ecosis.ds.getDatasetExtra('geojson').value;
      if( !geojson ) return;

      var geojsonFeature = {
          "type": "Feature",
          "properties": {},
          "geometry": JSON.parse(geojson)
      };

      try {
        this.polygon = L.geoJson(geojsonFeature);
        this.polygon.addTo(this.map);
      } catch(e) {}
    },

    onShow : function() {
      this.drawing = false;

      setTimeout(function(){
        this.map.invalidateSize();
      }.bind(this), 50);
    },

    onClick : function(e) {
      if( this.drawing ) {
        this.drawing = false;
        this.setPolygon(e.latlng);
        return;
      }

      this.drawing = true;
      this.p1 = e.latlng;
    },

    onMouseMove : function(e) {
      if( !this.drawing ) return;

      if( this.polygon ) {
        this.map.removeLayer(this.polygon);
      }
      var p2 = e.latlng;

      var coordinates = [[
          [this.p1.lng, this.p1.lat],
          [this.p1.lng, p2.lat],
          [p2.lng, p2.lat],
          [p2.lng, this.p1.lat],
          [this.p1.lng, this.p1.lat]
      ]];

      var geojsonFeature = {
          "type": "Feature",
          "properties": {},
          "geometry": {
            "type" : "Polygon",
            "coordinates" : coordinates
          }
      };

      this.polygon = L.geoJson(geojsonFeature);
      this.polygon.on('click', this.onClick.bind(this));
      this.polygon.addTo(this.map);
    },

    setPolygon : function(p2) {
      var geojson = {
        "type" : "Polygon",
        "coordinates" : [[
            [this.p1.lng, this.p1.lat],
            [this.p1.lng, p2.lat],
            [p2.lng, p2.lat],
            [p2.lng, this.p1.lat],
            [this.p1.lng, this.p1.lat]
        ]]
      }
      geojson = JSON.stringify(geojson);

      ecosis.ds.setDatasetExtra('geojson', geojson);
      this.fire('update', {
        attribute : 'geojson',
        value : geojson
      });
    }

  })
</script>

<dom-module id="ecosis-title-input">
  <style>
    :host {
      display: block;
    }
    span.label {
      font-size: 12px;
    }
    #titleLabel {
      font-weight: bold;
    }
  </style>

  <template>
    <div id="editMode" style="display:none" class="form-horizontal">
      <div class="form-group">
        <label class="col-md-2 control-label">Title</label>
        <div class="col-md-9" style="padding-top:7px">
          <div><span id="titleLabel"></span></div>
          <div style="font-size:12px;color:#888;font-style:italic">
            URL: <span id="urlLabel"></span>
          </div>
        </div>
      </div>
    </div>

    <div id="inputMode" class="form-horizontal">
      <div class="form-group">
        <label for="titleInput" class="col-md-2 control-label">Title</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="titleInput" placeholder="Unique Dataset Title" on-keyup="onTitleInputChange">

          <span id="verifyingTitleLabel" class="label label-info" style="display:none">
            <i class="fa fa-spinner fa-spin"></i> Verifying name...
          </span>

          <span class="label label-danger" style="display:none" id="invalid">
            Invalid name.  A dataset with the name '<span id="nameLabel"></span>' already exists.
          </span>

          <span class="label label-success" style="display:none" id="valid">
            URL: <span id="urlLabelInput"></span>
          </span>
        </div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-title-input',

    ready : function() {
      this.verifyNameTime = -1;

      if( ecosis.ds.loaded ) this.onDataReady();
      else ecosis.ds.on('load', this.onDataReady.bind(this));
    },

    onDataReady : function() {
      if( ecosis.ds.editMode ) {
        this.$.editMode.style.display = 'block';
        this.$.inputMode.style.display = 'none';

        this.$.titleLabel.innerHTML = ecosis.ds.data.title;
        this.$.urlLabel.innerHTML = ecosis.ckan.host + '/dataset/' + ecosis.ds.data.name;
        return;
      }

      this.$.urlLabelInput.innerHTML = ecosis.ckan.host + '/dataset/';
    },

    onTitleInputChange : function() {
      ecosis.ds.data.title = this.$.titleInput.value;
      ecosis.ds.data.name = ecosis.ds.data.title.toLowerCase().replace(/[^a-z0-9]/g,'-');
      this.$.nameLabel.innerHTML = ecosis.ds.data.name;
      this.$.urlLabelInput.innerHTML = ecosis.ckan.host + '/dataset/' + ecosis.ds.data.name;

      this.$.verifyingTitleLabel.style.display = 'inline-block';
      this.$.invalid.style.display = 'none';
      this.$.valid.style.display = 'none';
      this.validName = false;

      if( this.verifyNameTimer != -1 ) clearTimeout(this.verifyNameTimer);

      this.verifyNameTimer = setTimeout(function(){

        ecosis.ckan.getPackage(ecosis.ds.data.name, function(resp){
          this.$.verifyingTitleLabel.style.display = 'none';

          if( resp.error ) {
            this.validName = true;
            this.$.valid.style.display = 'inline-block';
          } else {
            this.validName = false;
            this.$.invalid.style.display = 'inline-block';
          }

          this.fire('update');
        }.bind(this));

      }.bind(this), 500);
    }
  });
</script>

<dom-module id="ecosis-keyword-input">
  <style>
    :host {
      display : block;
    }
    span.label {
      font-size: 12px;
      position: absolute;
      right: 15px;
      top: 15px;
    }
    a.btn {
      margin: 5px;
    }
  </style>
  <template>

    <div class="form-horizontal">
      <div class="form-group">
        <label for="keywordInput" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> Keywords</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="keywordInput" on-keyup="onInputChange" placeholder="Search Keywords">

          <span id="searchingPanel" class="label label-primary" style="display:none">
            <i class="fa fa-spinner fa-spin"></i> Searching...
          </span>

          <div id="resultRoot"></div>
          <div id="currentKeywordsRoot"></div>

        </div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-keyword-input',

    ready : function() {
        this.tokens = [];
        this.focus = false;
        this.searchTimer = -1;
    },

    // fires when text is typed input field
    onInputChange : function(e) {
        if( e.which == 13 ) this.createToken();
        else this.search();
    },

    search : function(){
        if( this.searchTimer != -1 ) clearTimeout(this.searchTimer);
        if( this.$.keywordInput.value == '' ) {
          this.setSearching(false);
          this.$.resultRoot.innerHTML = '';
          return;
        }

        this.setSearching(true);

        this.searchTimer = setTimeout(function(){
          ecosis.ckan.tagSearch(this.$.keywordInput.value, 10, function(resp){
            this.setSearching(false);

            this.results = resp.result.results;
            this.renderResults();
          }.bind(this));
        }.bind(this), 500);
    },

    createToken : function() {
        if(this.$.keywordInput.value.length == 0) return;

        var t = {
            label : this.$.keywordInput.value,
            value : this.$.keywordInput.value
        }
        this.addToken(t, true);

        this.$.keywordInput.value = '';
        this.$.resultRoot.innerHTML = '';
    },

    addResult : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        var name = this.results[index].name;


        this.addToken({label:name, value:name}, true);

        this.$.keywordInput.value = '';
        this.$.resultRoot.innerHTML = '';
        this.renderTokens();
    },

    addToken : function(token, fireEvent) {
        if( !token.value || token.value == '' ) return;

        for( var i = 0; i < this.tokens.length; i++ ) {
            if( this.tokens[i].value == token.value ) return;
        }

        token.label = token.value;
        this.tokens.push(token);

        if( fireEvent ) this.fire('add', token);

        this.renderTokens();
    },

    renderResults : function() {
      var btns = '';
      for( var i = 0; i < this.results.length; i++ ) {
        btns += '<a class="btn btn-default btn-sm ecosis-keyword-input" index="'+i+'" ><i class="fa fa-plus"></i> '+this.results[i].name+'</a>';
      }
      this.$.resultRoot.innerHTML = btns;

      $(this.$.resultRoot).find('a').on('click', this.addResult.bind(this));
    },

    renderTokens : function() {
      var btns = '';
      for( var i = 0; i < this.tokens.length; i++ ) {
        btns += '<a class="btn btn-primary btn-sm ecosis-keyword-input" index="'+i+'"><i class="fa fa-times"></i> '+this.tokens[i].label+'</a>';
      }
      this.$.currentKeywordsRoot.innerHTML = btns;

      $(this.$.currentKeywordsRoot).find('a').on('click', this.onTokenClick.bind(this));
    },

    getTokens : function() {
        return this.tokens;
    },

    setTokens : function(tokens) {
        this.tokens.splice(0,this.tokens.length);
        for( var i = 0; i < tokens.length; i++ ) {
            this.addToken({label: tokens[i].name, value : tokens[i].name});
        }

        this.renderTokens();
    },

    onTokenClick : function(e) {
        var index = parseInt(e.currentTarget.getAttribute("index"));
        var token = this.tokens.splice(index,1)[0];

        this.fire('remove', token);

        // don't set focus to input
        e.stopPropagation();

        this.renderTokens();
    },

    setSearching : function(searching) {
      this.$.searchingPanel.style.display = searching ? 'inline-block' : 'none';
    }
  });
</script>

<dom-module id="ecosis-header">
  <style>
    :host {
      display: block;
    }
  </style>
  <template>
    <nav class="navbar navbar-default">
      <div class="container-fluid">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#ecosis-header-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="#">EcoSIS Importer</a>
        </div>

        <div class="collapse navbar-collapse" id="ecosis-header-collapse">
          <ul class="nav navbar-nav">

            <li class="active"><a id="basicInfo"><i class="fa fa-info-circle"></i> Basic Information</a></li>

            <li class="dropdown" id="resourcesDropdown" style="display:none">
              <a class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
                <i class="fa fa-files-o"></i> Resources <span class="caret"></span>
              </a>
              <ul class="dropdown-menu" role="menu">
                <li><a id="addResources"><i class="fa fa-plus"></i> Add Resources</a></li>
                <li><a id="currentResources"><i class="fa fa-list"></i> Current Resources</a></li>
              </ul>
            </li>

            <li><a id="advanced" style="display:none"><i class="fa fa-cog"></i> Advanced</a></li>
            <li><a id="push" style="display:none"><i class="fa fa-cloud-upload"></i> Push to Search</a></li>
          </ul>

          <ul class="nav navbar-nav navbar-right">
            <li><a href="http://tutorial.ecospectra.org" target="_blank"><i class="fa fa-question-circle"></i> Help</a></li>
            <li><a id="exit"><i class="fa fa-sign-in"></i> Exit</a></li>
          </ul>
        </div>
      </div>
    </nav>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-header',

    properties : {
      hack : {
        type : String,
        value : ''
      }
    },

    ready : function() {
      // such BS polymer!
      this.$.basicInfo.setAttribute('href', '#basic-info');
      this.$.addResources.setAttribute('href', '#add-resources');
      this.$.currentResources.setAttribute('href', '#current-resources');
      this.$.advanced.setAttribute('href', '#advanced');
      this.$.push.setAttribute('href', '#push');

      $(window).on('hashchange', this.updateActiveTab.bind(this));
      this.updateActiveTab();

      if( ecosis.ds.editMode ) {
        ecosis.ds.on('load', function(){
          if( ecosis.ds.editMode ) this.$.exit.setAttribute('href', '/dataset/'+ecosis.ds.data.name);
        }.bind(this));
      } else {
        this.$.exit.setAttribute('href', '/dataset/');
      }
    },

    attached : function() {
      if( ecosis.ds.editMode ) {
        this.$.resourcesDropdown.style.display = 'block';
        this.$.advanced.style.display = 'block';
        this.$.push.style.display = 'block';
      }
    },

    updateActiveTab : function() {
      $('li').removeClass('active');

      var loc = window.location.hash.replace(/#/,'');
      var ele = $(this).find('a[href="#'+loc+'"]');

      if( ele.length > 0 && (loc == 'add-resources' || loc == 'current-resources') ) {
        $(this.$.resourcesDropdown).addClass('active');
      } else if ( ele.length > 0 ) {
        ele.parent().addClass('active');
      } else {
        $(this.$.basicInfo).parent().addClass('active');
      }
    }

  });
</script>

<dom-module id="ecosis-dataformat-help">
  <style>
      table.preview {
          width: 100%;
          border-spacing: 0px;
          border-collapse: separate;
          border-top: 1px solid #ddd;
          border-left: 1px solid #ddd;
          background-color: white;
      }
      table.preview td {
          padding: 10px;
          border-right: 1px solid #ddd;
          border-bottom: 1px solid #ddd;
      }
      table.preview td.attr {
          font-weight: bold;
      }
      .file {
          background-color: #dff0d8;
      }
      .column {
          background-color: #fcf8e3;
      }
      .data {
          background-color: #d9edf7;
      }
      .note {
          padding: 10px 0;
          color: #777;
          font-size: 13px;
      }
      .note-label {
          padding: 3px;
          border-radius: 3px;
          font-weight: bold;
      }
      table.preview td.highlight {
          border-left: 1px solid red;
          border-right: 1px solid red;
      }
      table.preview td.highlight-row {
          border-top: 1px solid red;
          border-bottom: 1px solid red;
      }
      :host {
        display: block;
      }
  </style>
  <template>

    <div class="note">
        EcoSIS accepts data in several tabular formats.  These tabular files can have measurements laid out by column or by row.
        If you would like help filling out metadata or packaging your spectra, try the
        <a href="https://github.com/CSTARS/ecosis-data-tool/releases" target="_blank">EcoSIS Metadata Editor</a> to generate nice
        tabular packages with EcoSIS metadata.
    </div>

    <div id="column">
        <b>Column Orientation</b>
        <table class="preview">
            <tbody><tr>
                <td class="file attr">File metadata 1</td>
                <td class="file">My Attribute value</td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td class="file attr">File metadata 2</td>
                <td class="file">My other value</td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td class="column attr">column Attribute</td>
                <td class="column">column 1 value</td>
                <td class="column highlight" style="border-top:1px solid red">column 2 value</td>
                <td class="column">column 3 value</td>
            </tr>
            <tr>
                <td class="column attr">USDA Code</td>
                <td class="column">ORYZA</td>
                <td class="column highlight">ORYZA</td>
                <td class="column">ACRU</td>
            </tr>
            <tr>
                <td class="column attr">id</td>
                <td class="column">id1</td>
                <td class="column highlight">id2</td>
                <td class="column">id3</td>
            </tr>
            <tr>
                <td class="data attr">400<span style="color:red">*</span></td>
                <td class="data">.34</td>
                <td class="data highlight">.345</td>
                <td class="data">.454</td>
            </tr>
            <tr>
                <td class="data attr">410<span style="color:red">*</span></td>
                <td class="data">.400</td>
                <td class="data highlight">.430</td>
                <td class="data">.568</td>
            </tr>
            <tr>
                <td class="data attr">LAI__d (m2/m2)</td>
                <td class="data">1.812</td>
                <td class="data highlight">.441</td>
                <td class="data">1.501</td>
            </tr>
            <tr>
                <td class="data attr">NDVI__d</td>
                <td class="data">.53</td>
                <td class="data highlight" style="border-bottom:1px solid red">.5</td>
                <td class="data">.48</td>
            </tr>


        </tbody></table>
    </div>

    <div id="row">
        <b>Row Orientation</b>
        <table class="preview">
            <tbody><tr>
                <td class="file attr">File metadata 1</td>
                <td class="file">My Attribute value</td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            </tr>
            <tr>
                <td class="file attr">File metadata 2</td>
                <td class="file">My other value</td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
                <td></td>
            
            </tr><tr>
                <td class="column attr">datetime</td>
                <td class="column attr">id</td>
                <td class="column attr">Metadata Attribute</td>
                <td class="column attr">USDA Code</td>
                <td class="data attr">LAI__d (m2/m2)</td>
                <td class="data attr">NDVI__d</td>
                <td class="data attr">400<span style="color:red">*</span></td>
            </tr>
            <tr>
                <td class="column attr highlight-row" style="border-left: 1px solid red">2008-07-24</td>
                <td class="column highlight-row">id1</td>
                <td class="column highlight-row">metadata value 1</td>
                <td class="column highlight-row">ORYZA</td>
                <td class="data highlight-row">1.190</td>
                <td class="data highlight-row">.53</td>
                <td class="data highlight-row" style="border-right: 1px solid red">.487</td>
            </tr>
            <tr>
                <td class="column attr">2008-07-25</td>
                <td class="column">id2</td>
                <td class="column">metadata value 2</td>
                <td class="column">ACRU</td>
                <td class="data">0.606</td>
                <td class="data">.50</td>
                <td class="data">.400</td>
            </tr>
        </tbody></table>
    </div>

    <div class="note">
        Any <b>numeric</b><span style="color:red">*</span> attribute name will be considered wavelength
        <span class="data note-label">data</span>.  Any attribute name with a <b>__d</b> postfix will be
        considered <span class="data note-label">data</span>.  All other fields will be considered
        <span class="column note-label">metadata</span>.  You will have the opportunity to manually
        specify the difference later on as well.
    </div>

    <div class="note">
        <span class="file note-label">Global File Metadata</span> is applied to everything in the file
        and is completely <b>optional</b>.  You can also upload a seperate metadata file which can be
        joined to your data later on in the import process.
    </div>

    <div class="note">
        Units can be specified by placing them in parentheses <b>(m2/m2)</b> after the attribute name.
    </div>

    <div style="margin-top:15px">
        Still lost?  <a href="http://tutorial.ecocolumn.org/walkthrough/#/7" target="_blank">Click
          here</a> to checkout the tutorial on data formats.
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-dataformat-help',

    setType : function(type) {
      if( type == 'column' ) {
        this.$.column.style.display = 'block';
        this.$.row.style.display = 'none';
      } else if( type == 'row' ) {
        this.$.column.style.display = 'none';
        this.$.row.style.display = 'block';
      } else {
        this.$.column.style.display = 'block';
        this.$.row.style.display = 'block';
      }
    }
  });
</script>

<dom-module id="ecosis-datasheet-select-panel">
  <style>
    :host {
      display: block;
    }
  </style>

  <template>
    <div class="layout horizontal">
      <div>
        <a class="btn btn-default" on-click="back" id="back">
          <i class="fa fa-arrow-left"></i>
        </a>
      </div>
      <div class="flex" style="text-align:center; padding: 0 25px">
          <select id="select" class="form-control" on-change="onSelect"></select>
      </div>
      <div>
        <a class="btn btn-default" on-click="forward" id="forward">
          <i class="fa fa-arrow-right"></i>
        </a>
      </div>
  </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-datasheet-select-panel',

    update : function(resource) {
      this.resource = resource;
      this.selected = 0;

      var options = '';
      for( var i = 0; i < resource.datasheets.length; i++ ) {
        var ds = resource.datasheets[i];
        options += '<option value="'+i+'">'+ds.name+(ds.sheetname ? ' '+ds.sheetname : '')+'</option>';
      }
      this.$.select.innerHTML = options;
    },

    onSelect : function() {
      this.selected = parseInt(this.$.select.value);
      this.fire('select', this.selected);
    },

    back : function() {
      this.selected--;
      if( this.selected < 0 ) {
        this.selected = 0;
        return;
      }
      this.$.select.value = this.selected+'';
      this.fire('select', this.selected);
    },

    forward : function() {
      this.selected++;
      if( this.selected >= this.resource.datasheets.length ) {
        this.selected = this.resource.datasheets.length-1;
        return;
      }
      this.$.select.value = this.selected+'';
      this.fire('select', this.selected);
    },

    setDisabled : function(disable) {
      if( disable ) {
        this.$.forward.setAttribute('disabled', '');
        this.$.back.setAttribute('disabled', '');
        this.$.select.setAttribute('disabled', '');
      } else {
        this.$.forward.removeAttribute('disabled');
        this.$.back.removeAttribute('disabled');
        this.$.select.removeAttribute('disabled');
      }
    }
  });
</script>

<dom-module id="ecosis-parser-overview">
  <style>
    :host {
        display: block;
    }
    canvas {
      border-radius: 6px;
      margin: 5px;
      border: 1px solid #888;
    }
  </style>

  <template>
    <div class="layout horizontal">
        <div class="flex" id="canvasParent">
            <div id="loadingPanel"><i class="fa fa-spinner fa-spin"></i> Loading...</div>

            <canvas id="canvas" width="400" height="400" on-mousewheel="onMouseWheel" on-mousedown="onMouseDown" on-mousemove="onMouseMove" on-mouseup="onMouseUp" on-mouseout="onMouseOut">
            </canvas>
        </div>
        <div>
            <div class="layout vertical">
                <div>
                  <a class="btn btn-default" on-click="zoomIn">
                    <i class="fa fa-plus"></i>
                  </a>
                </div>
                <div>
                  <a class="btn btn-default" on-click="zoomOut">
                    <i class="fa fa-minus"></i>
                  </a>
                </div>
                <div>
                  <a class="btn btn-default" on-click="zoomStart">
                    <i class="fa fa-compress"></i>
                  </a>
                </div>
            </div>
        </div>
    </div>

    <div>
        <span class="label label-success">Global Metadata</span> |
        <span class="label label-warning">Schema Attribute Names</span> |
        <span class="label label-primary">Spectra Data/Metadata</span>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-parser-overview',

    attached : function() {
      this.top = 0;
      this.left = 0;
      this.data = null;

      this.zoom = 5;

      this.cell = {
          width : 3,
          height : 1
      };

      this.colors = {
          blue : '#2196F3',
          red : '#FF9800',
          green : '#2f9b45',
          grey : '#888888',
          light_grey : '#cccccc'
      };

      this.type = 'row';
      this.ranges = {
          global : {
              start : 0,
              end : 1
          },
          local : {
              start : 2,
              end : 4,
          }
      };
      this.width = 400;
      this.height = 400;

      this.dragging = false;
      this.dragStart = [0, 0];
      this.dragPos = [0, 0];

      this.ctx = this.$.canvas.getContext('2d');
      $(window).on('resize', this.resize.bind(this));
    },

    reset : function() {
        this.clear();
        this.data = null;
        this.ranges = {
            global : {
                start : 0,
                end : 0
            },
            local : {
                start : 0,
                end : 0,
            }
        },
        this.top = 0;
        this.left = 0;
        this.zoom = 5;
    },

    update : function(resource, datasheet) {
      this.resource = resource;
      this.datasheet = datasheet;
      this.load();
    },

    load : function() {
        this.setLoading(true);
        this.reset();

        ecosis.ckan.getLayoutOverview(
            ecosis.ds.package_id,
            this.resource.id,
            this.datasheet.id,
            function(resp) {
                this.setLoading(false);

                if( resp.error ) return alert('Error loading layout overview :(');

                this.type = resp.layout;
                if( resp.localRange ) {
                    this.ranges.local.start = resp.localRange.start;
                    this.ranges.local.end = resp.localRange.stop;
                }
                if( resp.globalRange ) {
                    this.ranges.global.start = resp.globalRange.start;
                    this.ranges.global.end = resp.globalRange.stop;
                }
                this.data = resp.data;

                this.resize();
            }.bind(this)
        );
    },

    resize : function() {
        this.width = $(this.$.canvasParent).width()-30;
        if( this.width < 250 ) this.width = 250;
        this.$.canvas.width = this.width;

        this.async(function(){
            this.redraw();
        });
    },

    onMouseDown : function(e) {
        this.dragging = true;
        this.dragStart = [e.x,e.y];
        this.dragPos = [this.left,this.top];
    },

    onMouseUp : function(e) {
        this.dragging = false;
    },
    onMouseOut : function(e) {
        this.dragging = false;
    },

    onMouseMove : function(e) {
        if( !this.dragging ) return;

        this.left = this.dragPos[0] + (e.x - this.dragStart[0]);
        this.top = this.dragPos[1] + (e.y - this.dragStart[1]);
        this.redraw();
    },

    onMouseWheel : function(e) {
        e.preventDefault();
        e.stopPropagation();
        var delta = Math.max(-1, Math.min(1, e.wheelDelta));
        this.adjustZoom(delta);
    },

    zoomStart : function() {
        this.top = 0;
        this.left = 0;
        this.zoom = 5;
        this.redraw();
    },

    zoomIn : function() {
        this.adjustZoom(1);
    },

    zoomOut : function() {
        this.adjustZoom(-1);
    },

    adjustZoom : function(delta) {
        this.zoom += delta;

        if( this.zoom < 1 ) this.zoom = 1;
        if( this.zoom > 12 ) this.zoom = 12;
        this.redraw();
    },

    redraw : function() {
        if( !this.data ) return;


        this.clear();

        var w = this.cell.width * this.zoom * 10;
        var h = this.cell.height * this.zoom * 10;
        var t = this.top, l = this.left, row, i, j, color, half, fh, text;

        this.ctx.lineWidth = "2";

        this.ctx.fillStyle = '#000000';

        for( i = 0; i < this.data.length; i++ ) {
            row = this.data[i];

            for( j = 0; j < row.length; j++ ) {

                color = this.getColor(i, j);

                if( color == this.colors.blue ) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = this.colors.light_grey;

                    if( this.type == 'row') {
                        half = (h / 2) - 1;
                        this.ctx.moveTo(l, t+half);
                        this.ctx.lineTo(l+w-2, t+half);
                    } else {
                        half = (w / 2) - 1;
                        this.ctx.moveTo(l+half, t);
                        this.ctx.lineTo(l+half, t+h-2);
                    }

                    this.ctx.stroke();

                    fh = Math.floor(h*.2);
                    this.ctx.font = fh+"px Arial";
                    this.ctx.fillStyle = this.colors.light_grey;

                    if( this.type == 'row') {
                        this.ctx.fillText(this.data[0][j], l+2, t+fh+3, w-2);
                    } else {
                        this.ctx.fillText(this.data[i][0], l+2, t+fh+3, w-2);
                    }
                }

                this.ctx.strokeStyle = color;
                this.ctx.fillStyle = color;

                this.ctx.beginPath();
                this.ctx.rect(l,t,w-2,h-2);
                this.ctx.stroke();

                this.ctx.font = Math.floor(h*.6)+"px Arial";
                this.ctx.fillStyle = color;
                this.ctx.fillText(row[j].substring(0, 10), l+2, t+h-7, w);

                l += w;
                if( l > this.width ) break;
            }

            l = this.left;
            t += h;
            if( t > this.height ) break;
        }
    },

    getColor : function(i, j) {
        if( i >= this.ranges.global.start && i < this.ranges.global.end && j < 2 ) {
            return this.colors.green
        } else if( i >= this.ranges.local.start && i <= this.ranges.local.end && this.type == 'column' && j == 0 ) {
            return this.colors.red;
        } else if( i >= this.ranges.local.start && i <= this.ranges.local.end && this.type == 'column' ) {
            return this.colors.blue;
        } else if( i == this.ranges.local.start && this.type == 'row' ) {
            return this.colors.red;
        } else if( i > this.ranges.local.start && i <= this.ranges.local.end && this.type == 'row' ) {
            return this.colors.blue;
        } else {
            return this.colors.light_grey;
        }
    },

    clear : function() {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.ctx.fillStyle = '#FFFFFF';
        this.ctx.fillRect(0, 0, this.width, this.height);
    },

    setLoading : function(loading) {
      this.$.loadingPanel.style.display = loading ? 'block' : 'none';
    }

  });
</script>

<dom-module id="ecosis-metadata-join-panel">
  <template>

    <div class="panel panel-default">
      <div class="panel-heading">
        <h3 class="panel-title">
          Join On:&nbsp;&nbsp;
          <select id="joinId" on-change="onJoinIdChange" style="color: #333"></select>
        </h3>
      </div>
      <div class="panel-body">

        <!-- Filename match -->
        <div class="form-horizontal">
          <div class="form-group">
            <label for="filenameMatch" class="col-lg-3">Filename Match</label>
            <div class="col-lg-9">
              <div class="checkbox">
                <label>
                  <input id="filenameMatch" type="checkbox" on-click="onFilenameMatch">
                  Match attributes to resource filename.
                </label>
              </div>

              <!-- Exact Match -->
              <div id="looseMatchPanel" style="margin-top: 15px">
                <div class="checkbox">
                  <label>
                    <input id="looseMatch" type="checkbox" on-click="onLooseMatch">
                    <b>Loose match</b>. If checked, the filename just needs to contain
                    the attribute value to match.  Otherwise the attribute value must
                    match the filename exactly.
                  </label>
                </div>
              </div>

            </div>
          </div>

          <div class="form-group" id="worksheetMatchPanel">
            <label for="looseMatch" class="col-lg-3">Worksheet Match</label>
            <div class="col-lg-9">
              <div class="checkbox">
                <label>
                  <input id="worksheetMatch" type="checkbox" on-click="onWorksheetMatch">
                  Match on Worksheet Name.
                </label>
              </div>
            </div>
          </div>
        </div>

        <div id="updatingPanel" class="alert alert-success" style="display:none">
          <i class="fa fa-spinner fa-spin"></i> Joining...
        </div>

        <div id="matchCountPanel" class="label label-primary">
          Matched to <span id="matchCountLabel">matchCount</span> measurements.
        </div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-metadata-join-panel',

    ready : function() {
      this.updateTimer = -1;
    },

    update : function(datasheet, resource) {
      if( datasheet ) this.datasheet = datasheet;
      if( resource ) this.resourceId = resource.id;

      this.updateMatchTypeUi();

      var options = '<option></option>';
      for( var i = 0; i < this.datasheet.attributes.length; i++ ) {
        var attr = this.datasheet.attributes[i];
        if( attr.type == 'metadata' ) {
          options += '<option value="'+attr.name+'" '+
              (this.datasheet.matchAttribute == attr.name ? 'selected' : '') +
              '>'+attr.name+'</option>';
        }
      }
      this.$.joinId.innerHTML = options;

      var matchCount = 0;
      for( var key in this.datasheet.matches ) {
        matchCount += this.datasheet.matches[key]
      }
      this.$.matchCountLabel.innerHTML = matchCount;
    },

    onJoinIdChange : function() {
      this.datasheet.matchAttribute = this.$.joinId.value;
      this.updateServer();
    },

    onWorksheetMatch : function() {
      if( $(this.$.worksheetMatch).is(':checked') ) {
        this.datasheet.matchType = 'sheetname';
      } else {
        this.datasheet.matchType = 'attribute';
      }

      this.updateMatchTypeUi();
      this.updateServer();
    },

    onFilenameMatch : function() {
      if( this.$.filenameMatch.checked ) {
        this.datasheet.matchType = 'filename';
        this.datasheet.looseMatch = this.$.looseMatch.checked;
      } else {
        this.datasheet.matchType = 'attribute';
      }

      this.updateMatchTypeUi();
      this.updateServer();
    },

    onLooseMatch : function() {
      this.datasheet.looseMatch = this.$.looseMatch.checked;

      this.updateMatchTypeUi();
      this.updateServer();
    },

    updateServer : function() {
      if( !this.datasheet.matchAttribute || this.datasheet.matchAttribute == '' ) return;

      this.setUpdating(true);

      if( this.updateTimer != -1 ) clearTimeout(this.updateTimer);

      this.updateTimer = setTimeout(function(){
        this.updateTimer = -1;
        this.join();
      }.bind(this), 1000);
    },

    join : function() {

      var matchType = this.datasheet.matchType;
      if( !matchType || matchType == '' ) matchType = 'attribute';

      ecosis.ckan.updateJoin(
        ecosis.ds.package_id,
        this.resourceId,
        {
          id : this.datasheet.id,
          layout : 'row',
          matchAttribute : this.datasheet.matchAttribute,
          matchType : matchType,
          metadata : true,
          looseMatch : this.datasheet.looseMatch ? true : false
        },
        function(resp){
          this.setUpdating(false);
          if( resp.error ) return alert('Error updating join information :(');

          for( var key in resp ) {
            this.datasheet[key] = resp[key];
          }

          this.update(this.datasheet);
        }.bind(this)
      );
    },

    setUpdating : function(updating) {
      if( updating ) {
        this.$.filenameMatch.setAttribute('disabled', '');
        this.$.looseMatch.setAttribute('disabled', '');
        this.$.joinId.setAttribute('disabled', '');

        this.$.matchCountPanel.style.display = 'none';
        this.$.updatingPanel.style.display = 'block';

        this.fire('metadata-update', {updating: true});
      } else {
        this.$.filenameMatch.removeAttribute('disabled');
        this.$.looseMatch.removeAttribute('disabled');
        this.$.joinId.removeAttribute('disabled');

        this.$.matchCountPanel.style.display = 'inline-block';
        this.$.updatingPanel.style.display = 'none';

        this.fire('metadata-update', {updating: false});
      }
    },

    updateMatchTypeUi : function() {

      if( this.datasheet.matchType == 'filename' ) {

        $(this.$.filenameMatch).prop('checked', true);
        $(this.$.worksheetMatch).prop('checked', false);
        this.$.looseMatchPanel.style.display = 'block';

      } else if( this.datasheet.matchType == 'sheetname'){

        $(this.$.filenameMatch).prop('checked', false);
        $(this.$.worksheetMatch).prop('checked', true);
        this.$.looseMatchPanel.style.display = 'none';

      } else { // matchType == 'attribute'

        $(this.$.filenameMatch).prop('checked', false);
        $(this.$.worksheetMatch).prop('checked', false);
        this.$.looseMatchPanel.style.display = 'none';
      }

      if( this.datasheet.sheetname ) {
        this.$.worksheetMatchPanel.style.display = 'block';
      } else {
        this.$.worksheetMatchPanel.style.display = 'none';
      }


      if( this.datasheet.looseMatch ) {
        $(this.$.looseMatch).prop('checked', true);
      } else {
        $(this.$.looseMatch).prop('checked', false);
      }
    }

  })
</script>

<dom-module id="ecosis-chart">
  <style>
    :host {
        display: block;
    }
  </style>

  <template>
    <div id="root" style="height:400px"></div>

    <div id="noData" style="color:#888">
      No spectral data to chart.
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-chart',

    properties : {
      animate : {
          type : Boolean,
          value : false
      },
      type : {
        type : String
      }
    },

    ready : function() {
      this.dt = null;
      this.chart = null;
      this.height = 400;

      this.updateTimer = -1;

      this.onLoadHandlerSet = false;

      this.options = null;
      this.cols = null;

      $(window).on('resize', function(){
          this.redraw();
      }.bind(this));
    },

    setOnloadHandler : function() {
        if( this.onLoadHandlerSet ) return;

        // put in global scope by cwn-datastore
        chartLoadHandlers.push(function(){
            this.update();
        }.bind(this));
    },

    setData : function(data) {
      this.data = data;
      this.update();
    },

    update : function() {
        if( !window.google.visualization ) return this.setOnloadHandler();
        if( !window.google.visualization.LineChart ) return this.setOnloadHandler();

        if( this.isEmpty() ) {
          this.$.root.style.display = 'none';
          this.$.noData.style.display = 'block';
          return;
        }
        this.$.root.style.display = 'block';
        this.$.noData.style.display = 'none';

        if( !this.chart ) {
            if( this.type ) {
                this.chart = new google.visualization[this.type](this.$.root);
            } else {
                this.chart = new google.visualization.LineChart(this.$.root);
            }
        }

        if( this.updateTimer == -1 ) clearTimeout(this.updateTimer);
        this.updateTimer = setTimeout(function() {
            this.updateTimer = -1;
            this._update();
        }.bind(this), 500);
    },

    _update : function() {
        if( this.cols ) {
            this.dt = new google.visualization.DataTable();
            for( var i = 0; i < this.cols.length; i++ ) {
                this.dt.addColumn(this.cols[i]);
            }
            this.dt.addRows(this.data);
        } else {
            this.dt = google.visualization.arrayToDataTable(this.data);
        }

        this.redraw();
    },

    isEmpty : function() {
        if( !this.data ) {
            return true;
        }
        if( this.data.length < 2 ) {
            return true;
        }
        if( this.data[0].length == 0 ) {
            return true;
        }

        return false;
    },

    redraw : function() {
        if( !this.chart || !this.dt ) return;

        var options = {
            legend : {
                position : 'none'
            }
        };

        if( this.options ) {
            for( var key in this.options ) {
                options[key] = this.options[key];
            }
        }

        this.chart.draw(this.dt, options);
    }
  });
</script>
<dom-module id="ecosis-spectra-panel">
  <style>
    :host {
      display: block;
    }
  </style>

  <template>
    <h6 id="loadingPanel">
      <i class="fa fa-spinner fa-spin"></i> Loading Spectra #<span id="spectraIndexLabel"></span>...
    </h6>

    <div id="mainPanel" style="display:none">
        <div style="text-align:right" id="spectraSelectPanel">
            Spectra #
            <select on-change="setIndex" class="form-control" style="width:100px; display:inline-block" id="select"></select>
        </div>

        <ecosis-chart id="chart"></ecosis-chart>
        <!--
        <esis-ui-chart data="{{data}}" options="{{chartOptions}}" height="500"></esis-ui-chart>
      -->

        <div id="tableRoot"></div>

    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-spectra-panel',

    ready : function() {
      this.$.chart.options = {}
    },

    update : function(resource, datasheet) {
      this.resource = resource;
      this.datasheet = datasheet;

      this.spectraCache = {};

      this.index = 0;

      var options = '';
      for( var i = 0; i < this.datasheet.spectra_count; i++ ) {
          options += '<option value="'+i+'">'+(i+1)+'</option>';
      }
      this.$.select.innerHTML = options;

      if( this.datasheet.spectra_count <= 1 ) {
        this.$.spectraSelectPanel.style.display = 'none';
      } else {
        this.$.spectraSelectPanel.style.display = 'block';
      }

      this.load();
    },

    clearCache : function() {
        this.spectraCache = {};
    },

    load : function() {
        this.$.spectraIndexLabel.innerHTML = this.index+1;

        if( this.spectraCache[this.index] ) {
            this.renderSpectra(this.spectraCache[this.index]);
            return;
        }

        this.setLoading(true);

        ecosis.ckan.getSpectra(
            ecosis.ds.package_id,
            this.resource.id,
            this.datasheet.id,
            this.index,
            function(resp) {

              this.setLoading(false);
              if( resp.error ) return alert('Error loading spectra: '+this.index);

              this.spectraCache[this.index] = resp;
              this.renderSpectra(resp);
            }.bind(this)
        )
    },

    setLoading : function(loading) {
      this.$.loadingPanel.style.display = loading ? 'block' : 'none';
      this.$.mainPanel.style.display = !loading ? 'block' : 'none';
    },

    renderSpectra : function(spectra) {
        this.currentSpectra = spectra;

        var re1Wave = /^-?\d+\.?\d*/;
        var re2Wave = /^-?\d*\.\d+/;

        this.data = [];
        for( var i = 0; i < spectra.datapoints.length; i++ ) {
            if( re1Wave.test(spectra.datapoints[i].key) || re2Wave.test(spectra.datapoints[i].key) ) {
                this.data.push([
                    parseFloat(spectra.datapoints[i].key),
                    parseFloat(spectra.datapoints[i].value)
                ])
            }
        }

        this.data.sort(function(a, b){
            if( a[0] > b[0] ) return 1;
            if( a[0] < b[0] ) return -1;
            return 0;
        });

        this.data.splice(0, 0, ['Wavelength', '']);
        this.$.chart.setData(this.data);

        this.attrs = [];

        for( var attrName in spectra ) {
            if( attrName == 'datapoints') continue;
            this.attrs.push({
                name: attrName,
                value: spectra[attrName],
                isEcosis : ( ecosis.ds.isEcosisMetadata(attrName) ) ? true : false
            });
        }

        this.attrs.sort(function(a, b){
            if( a.name > b.name ) return 1;
            if( a.name < b.name ) return -1;
            return 0;
        });

        this.renderTable();
    },

    renderTable : function() {
      var table = '<table class="table">';
      for( var i = 0; i < this.attrs.length; i++ ) {
        var attr = this.attrs[i];

        table +=
          '<tr class="'+(attr.isEcosis ? 'success' : '')+'" >'+
            '<td>'+attr.name+'</td>'+
            '<td>'+attr.value+'</td>'+
          '</tr>'
      }
      table += '</table>';

      this.$.tableRoot.innerHTML = table;
    },

    setIndex : function(e) {
        this.index = parseInt(e.currentTarget.value);
        this.load();
    }
  })
</script>
<dom-module id="ecosis-datasheet-panel">
  <style>
    :host {
      display: block;
    }
  </style>

  <template>

    <div id="main" style="display:none" class="animated fadeInUp">
      <h6 id="titleLabel" style="display:none"></h6>

      <span class="alert alert-danger" style="display:none" id="parseError">
          Error parsing file
      </span>

      <!-- Is Metadata -->
      <div id="metadataSelectPanel">
        <div class="form-horizontal">
          <div class="form-group">

            <label for="inputIsMetadata" class="col-md-2 control-label">Joinable Metadata</label>
            <div class="col-md-10">
              <div class="checkbox">
                <label>
                  <input id="inputIsMetadata" type="checkbox" on-change="onMetadataUpdate"> This datasheet only contains metadata to be joined on given data.
                </label>
              </div>
              <span class="help-block">
                NOTE:  Metadata must be in row format.
              </span>

              <ecosis-metadata-join-panel id="joinMetadata" style="display:none" on-metadata-update="onMetadataPanelUpdate">
              </ecosis-metadata-join-panel>
            </div>

          </div>
        </div>
      </div>

      <!-- Ignore -->
      <div class="form-horizontal">
        <div class="form-group">

          <label for="inputIgnore" class="col-md-2 control-label">Ignore</label>
          <div class="col-md-10">
            <div class="checkbox">
              <label>
                <input id="inputIgnore" type="checkbox" on-change="onIgnoreUpdate"> This datasheet should not be parsed.
              </label>
            </div>
          </div>

        </div>
      </div>

      <!-- Datasheet Orientation -->
      <div class="form-horizontal" id="orientationPanel">
        <div class="form-group">

          <label class="col-md-2 control-label">Orientation</label>
          <div class="col-md-10">
            <div class="radio">
              <label>
                <input type="radio" id="columnInput" value="column" checked="" on-click="onOrientationChange">
                Datasheet is laid out by column.
              </label>
            </div>
            <div class="radio">
              <label>
                <input type="radio" id="rowInput" value="row" on-click="onOrientationChange">
                Datasheet is laid out by row.
              </label>
            </div>

            <a on-click="toggleHelp">Format Help.</a>
            <ecosis-dataformat-help id="formatHelp" style="display:none" class="animated fadeInRight"></ecosis-dataformat-help>
          </div>

        </div>
      </div>

      <div class="form-horizontal" id="parseOverviewPanel" style="border-top: 1px solid #eee">
        <div class="form-group">

          <div class="col-md-2" style="text-align:right">
            <a class="btn btn-link" on-click="toggleCurrentParse">
                <i class="fa fa"></i> Format Overview
            </a>
          </div>
          <div class="col-md-10">
            <div class="help-block">
                Visually inspect how EcoSIS is parsing this sheet.
            </div>

            <ecosis-parser-overview id="parseOverview" style="display:none"></ecosis-parser-overview>
          </div>
        </div>
      </div>

      <div class="form-horizontal" id="spectraPanel" style="border-top: 1px solid #eee; display:none">
        <div class="form-group">

          <div class="col-md-2" style="text-align:right">
            <a class="btn btn-link" on-click="toggleSpectra">View Spectra <span id="spectraCountLabel"></span></a>
          </div>
          <div class="col-md-10">
            <div class="help-block">
                View the spectra for this sheet.
            </div>

            <ecosis-spectra-panel id="spectraUi" style="display:none"></ecosis-spectra-panel>
          </div>
        </div>
      </div>

      <div id="updatingPanel" class="alert alert-warning" style="display:none">
        <h6 style="color:white"><i class="fa fa-spinner fa-spin"></i> Updating...</h6>
      </div>
    </div>

    <div id="loading">
      <h6><i class="fa fa-spinner fa-spin"></i> Loading...</h6>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-datasheet-panel',

    ready : function() {
      this.datasheet = null;
    },

    update : function(resource, datasheet) {
      this.resource = resource;
      this.datasheetId = datasheet.id;
      this.datasheet = null;
      this.$.spectraUi.style.display = 'none';
      this.setLoading(true);
    },

    save : function() {
      this.setSaving(true);
      this.$.parseOverview.style.display = 'none';

      var resource = {
          id : this.resource.id,
          datasheets : [{
              id : this.datasheet.id,
              layout : this.datasheet.layout,
              ignore : this.datasheet.ignore ? true : false,
              metadata : this.datasheet.metadata ? true : false
          }]
      };

      ecosis.ckan.setParseInfo(
          ecosis.ds.package_id,
          resource,
          this.datasheet.id,
          function(resp){
            this.setSaving(false);

            if( resp.error ) return alert("Error updating datasheet :(");

            ecosis.ds.runAfterResourceAdd(resp);

            for( var i = 0; i < resp.resources.length; i++ ) {
                if( resp.resources[i].id != this.resource.id ) continue;
                var r = resp.resources[i];

                for( var j = 0; j < r.datasheets.length; j++ ) {
                    if( r.datasheets[j].id == this.datasheet.id ) {
                        for( var key in r.datasheets[j] ) {
                            this.datasheet[key] = r.datasheets[j][key];
                        }
                        break;
                    }
                }
            }

            // any time we perform an update like this, the state of joins may have changed,
            // so clear any cached spectra and datasheet information using spectra.clearCache()
            // and the update event to alert the rest of the app
            //TODO
            //this.$.spectraPanel.clearCache();

            this.fire('update', this.resource.id);

            // this 'update' event actually sets the entire resource as not loaded
            // but we have set the correct datasheet attributes above, so go ahead
            // and mark just this datasheet as loaded.  This will make sure things
            // like the attribute list in the metadata panel are set correctly.
            //setTimeout(function(){
            //    this.datasheet.loaded = true;
            //}.bind(this));

            this.updateMetadataUi();
            this.updateIgnoreUi();

            // update spectra count
            if( this.datasheet.spectra_count ) {
              this.$.spectraCountLabel.innerHTML = '('+this.datasheet.spectra_count+')';
            } else {
              this.$.spectraCountLabel.innerHTML = '';
            }

          }.bind(this)
      );
    },

    edit : function(callback) {
      if( !this.datasheet ) {
        this.loadFullDatasheet(callback);
        return;
      } else if( this.datasheet.id != this.datasheetId ) {
        this.loadFullDatasheet(callback);
        return;
      }

      // set title
      if( this.resource.datasheets.length == 1 ) {
        var title = this.datasheet.name;
        if( this.datasheet.sheet ) title += ' ('+this.datasheet.sheetname+')';
        this.$.titleLabel.innerHTML = title;
      } else { // title is shown by dropdown
        this.$.titleLabel.innerHTML = '';
      }

      // set count
      if( this.datasheet.spectra_count ) {
        this.$.spectraCountLabel.innerHTML = '('+this.datasheet.spectra_count+')';
      } else {
        this.$.spectraCountLabel.innerHTML = '';
      }

      // show parse error
      if( this.datasheet.error ) this.$.parseError.style.display = 'block';
      else this.$.parseError.style.display = 'none';

      // should we show the metadata selection
      if( this.datasheet.ignore ) this.$.metadataSelectPanel.style.display = 'none';
      else this.$.metadataSelectPanel.style.display = 'block';


      // set the correct layout
      if( this.datasheet.layout == 'column' ) {
        this.$.columnInput.setAttribute('checked', '');
        this.$.rowInput.removeAttribute('checked');
      } else {
        this.$.rowInput.setAttribute('checked', '');
        this.$.columnInput.removeAttribute('checked');
      }

      this.updateMetadataUi();
      this.updateIgnoreUi();

      if( callback ) callback();
    },

    updateMetadataUi : function() {
      if( this.datasheet.metadata ) {
        this.$.joinMetadata.update(this.datasheet, this.resource);
        this.$.joinMetadata.style.display = 'block';
        this.$.spectraPanel.style.display = 'none';
        this.$.orientationPanel.style.display = 'none';
        this.$.inputIsMetadata.setAttribute('checked','');
      } else {
        this.$.joinMetadata.style.display = 'none';
        this.$.spectraPanel.style.display = 'block';
        this.$.orientationPanel.style.display = 'block';
        this.$.inputIsMetadata.removeAttribute('checked');
      }
    },

    updateIgnoreUi : function() {
      var panels = ['spectraPanel', 'parseOverviewPanel', 'orientationPanel', 'metadataSelectPanel'];

      if( this.datasheet.ignore ) {
        panels.forEach(function(id){
          this.$[id].style.display = 'none';
        }.bind(this));
        $(this.$.inputIgnore).prop('checked', true);
      } else {
        panels.forEach(function(id){
          if( id == 'spectraPanel' || id == 'orientationPanel') return; // let the updateMetadataUi handle this
          this.$[id].style.display = 'block';
        }.bind(this));
        $(this.$.inputIgnore).prop('checked', false);
      }
    },

    onOrientationChange : function(e) {
      this.datasheet.layout = e.currentTarget.value;
      if( this.datasheet.layout == 'column' ) {
        $(this.$.rowInput).prop('checked', false);
      } else {
        $(this.$.columnInput).prop('checked', false);
      }

      this.save();
    },

    toggleCurrentParse : function() {
      if( this.$.parseOverview.style.display == 'none' ) {
        this.$.parseOverview.style.display = 'block';
        this.$.parseOverview.update(this.resource, this.datasheet);
      } else {
        this.$.parseOverview.style.display = 'none';
      }
    },

    toggleSpectra : function() {
      if( this.$.spectraUi.style.display == 'none' ) {
        this.$.spectraUi.style.display = 'block';
        this.$.spectraUi.update(this.resource, this.datasheet);
      } else {
        this.$.spectraUi.style.display = 'none';
      }
    },

    toggleHelp : function() {
      $(this.$.formatHelp).toggle();
    },

    loadFullDatasheet : function(callback) {
      this.setLoading(true);

      ecosis.ckan.getDatasheet(ecosis.ds.package_id, this.resource.id, this.datasheetId, function(resp){
        this.setLoading(false);

        this.datasheet = resp;
        this.edit();

        if( callback ) callback();
      }.bind(this));
    },

    setLoading : function(loading) {
      if( loading ) {
        this.$.main.style.display = 'none';
        this.$.loading.style.display = 'block';
      } else {
        this.$.main.style.display = 'block';
        this.$.loading.style.display = 'none';
      }
    },

    onMetadataPanelUpdate : function(e) {
      if( e.detail.updating ) {
        this.$.inputIsMetadata.setAttribute('disabled', '');
        this.$.inputIgnore.setAttribute('disabled', '');
      } else {
        this.$.inputIsMetadata.removeAttribute('disabled');
        this.$.inputIgnore.removeAttribute('disabled');
      }
    },

    onMetadataUpdate : function() {
      if( $(this.$.inputIsMetadata).is(':checked') ) {
        this.datasheet.metadata = true;
        this.fire('type-change', {type: 'metadata'});
      } else {
        this.datasheet.metadata = false;
        this.fire('type-change', {type: 'data'});
      }

      this.updateMetadataUi();

      this.save();
      this.fire('update', this.resource.id);
    },

    onIgnoreUpdate : function() {
      if( $(this.$.inputIgnore).is(':checked') ) {
        this.datasheet.ignore = true;
      } else {
        this.datasheet.ignore = false;
      }
      this.updateIgnoreUi();

      this.save();
      this.fire('update', this.resource.id);
    },

    setSaving : function(saving) {
      this.$.updatingPanel.style.display = saving ? 'block' : 'none';

      if( saving ) {
        $(this).find('input').attr('disabled', '');
      } else {
        $(this).find('input').removeAttr('disabled');
      }
    }
  });
</script>
<dom-module id="ecosis-resource-panel">
  <style>
    :host {
      display: block;
    }
    a.btn-link {
      padding-top: 0;
    }
    span.label-danger {
      box-shadow: 0 0 5px white;
      border: 1px solid white;
    }
  </style>

  <template>
    <div class="panel panel-default" id="root">
      <div class="panel-heading">
        <h3 class="panel-title">

          <div class="layout horizontal">
            <div class="flex">
              <span id="titleLabel"></span>
              <a class="btn btn-link" style="color:white" on-click="delete" id="trashBtn"><i class="fa fa-trash"></i></a>
              <span class="label label-danger" id="deletePanel" style="display:none">
                <i class="fa fa-spinner fa-spin"></i> Deleting Resource...
              </span>
            </div>
            <div>
              <a class="btn btn-link" style="color:white" id="editLink" on-click="toggleEdit">
                <i class="fa fa-pencil" id="editLinkIcon"></i>
              </a>
            </div>
          </div>

        </h3>
      </div>
      <div class="panel-body" style="display:none; overflow:hidden" id="body">
        <ecosis-datasheet-select-panel style="display:none" id="datasheetSelector" on-select="onDatasheetSelected">
        </ecosis-datasheet-select-panel>

        <ecosis-datasheet-panel id="datasheetUI" on-type-change="onDatasheetTypeChange">
        </ecosis-datasheet-panel>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-resource-panel',

    properties : {
      resourceid : {
        type : String
      }
    },

    ready : function() {
      this.edit = false;
    },

    attached : function() {
      this.resource = null;

      for( var i = 0; i < ecosis.ds.resources.length; i++ ) {
        var resource = ecosis.ds.resources[i];
        if( this.resourceid == resource.id ) {
          this.resource = resource;
          break;
        }
      }

      this.update();
    },

    update : function() {
      this.$.titleLabel.innerHTML = this.resource.name;
      this.setClass();

      if( !this.resource.datasheets ) {
        this.$.datasheetSelector.style.display = 'none';
      } else if( this.resource.datasheets.length <= 1 ) {
        this.$.datasheetSelector.style.display = 'none';
      } else {
        this.$.datasheetSelector.style.display = 'block';
        this.$.datasheetSelector.update(this.resource);
      }

      if( this.resource.datasheets ) {
        this.selectDatasheet(0);
      } else {
        this.$.trashBtn.style.color = '#333';
      }
    },

    onDatasheetTypeChange : function(e) {
      if( e.detail.type == 'metadata' ) {
        this.resource.datasheets[this.selectedIndex].metadata = true;
      } else {
        this.resource.datasheets[this.selectedIndex].metadata = false;
      }
      this.setClass();
    },

    setClass : function() {
      var className = this.getPanelClass(this.getResourceType());
      this.$.root.className = 'panel panel-'+className;
    },

    selectDatasheet : function(index, edit) {
      // set the resource and sheet we are going to render
      this.$.datasheetUI.update(this.resource, this.resource.datasheets[index]);

      // if the edit flag is passed, actually load the detailed datasheet and render
      if( edit ) {
        this.$.datasheetSelector.setDisabled(true);
        this.$.datasheetUI.edit(function(){
          this.$.datasheetSelector.setDisabled(false);
        }.bind(this));
      }

      this.selectedIndex = index;
    },

    onDatasheetSelected : function(e) {
      this.selectDatasheet(e.detail, true);
    },

    getPanelClass : function(type) {
      if( type == 'data' ) return 'success';
      if( type == 'metadata' ) return 'primary';
      if( type == 'zip' ) return 'info';
      return 'default';
    },

    getResourceType : function() {
      if( this.resource.datasheets && this.resource.datasheets.length == 1 && this.resource.datasheets[0].metadata ) {
        return 'metadata';
      }
      if( this.resource.type == 'zip' ) {
        return 'zip';
      }
      if( this.resource.type == 'datafile' ) {
        return 'data';
      }
      return 'ignored';
    },

    toggleEdit : function() {
      this.edit = !this.edit;

      if( this.edit ) {
        this.$.body.style.display = 'block';

        this.$.editLink.className = 'btn btn-default';
        this.$.editLinkIcon.className = 'fa fa-check';
        this.$.editLinkIcon.style.color = 'black';

        this.$.datasheetUI.edit();

        this.fire('editing', this.resourceid);
      } else {
        this.$.body.style.display = 'none';

        this.$.editLink.className = 'btn btn-link';
        this.$.editLinkIcon.className = 'fa fa-pencil';
        this.$.editLinkIcon.style.color = 'white';
      }
    },

    delete : function() {
      if( !confirm("Are you sure you want to remove: "+this.resource.name+"?") ) return;

      this.$.deletePanel.style.display = 'inline-block';

      ecosis.ckan.removeResource(this.resource.id,
        function(resp){
          this.$.deletePanel.style.display = 'block';

          if( resp.error ) return alert("Server error deleting resource");

          for( var i = 0; i < ecosis.ds.resources.length; i++ ) {
            if( ecosis.ds.resources[i] == this.resource ) {
              ecosis.ds.resources.splice(i, 1);
              ecosis.ds.fireUpdate();
              break;
            }
          }

          $(this).hide('slow', function(){
            $(this).remove();
          });

          this.fire('update', this.resourceid);
        }.bind(this)
      );
    },
  });
</script>


<dom-module id="ecosis-page-basic-info">
  <style>
    :host {
      display: block;
      padding: 0 5%;
    }
    .save-label {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        text-align: center;
        z-index: 1000;
        display: none;
    }
    a {
      cursor: pointer;
    }
  </style>
  <template>
    <div class="save-label" id="saveLabel">
      <span class="label label-primary"><i></i> Saving...</span>
    </div>

    <h4 class="page-header">Basic Information</h4>

    <div class="well" style="font-size: 14px; color: #888">
      <div style="color:#333; font-weight: bold; padding-bottom: 15px">Welcome <span id="usernameLabel"></span>.</div>
      Fill out the basic information for your dataset.  Then you can add resource files such as metadata or spectra.<br>
      First time adding data?  Checkout the <a href="http://tutorial.ecospectra.org/" target="_blank">screencast and tutorial.</a>
    </div>

    <ecosis-title-input id="titleInput" on-update="onTitleInputChange"></ecosis-title-input>

    <div class="form-horizontal">

      <!-- Description -->
      <div class="form-group">
        <label for="textArea" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> Description</label>
        <div class="col-md-9">
          <textarea class="form-control" rows="3" id="descriptionInput" on-change="onDescriptionInputChange"></textarea>
        </div>
      </div>

      <ecosis-keyword-input id="keywordInput" on-add="onKeywordsChange" on-remove="onKeywordsChange"></ecosis-keyword-input>
      <!-- TODO
      <div class="form-wrap">
        <esis-ui-token-input id="keywords" on-update="{{_setKeywords}}"></esis-ui-token-input>
      </div>
      -->

      <div class="form-group">
        <label for="licenseInput" class="col-md-2 control-label">License: </label>
        <div class="col-md-9">
          <div style="display:none">Loading...</div>
          <select class="form-control" id="licenseInput" on-change="onLicenseInputChange">
            <option>Loading...</option>
          </select>
        </div>
      </div>

      <div class="form-group">
        <label for="organizationInput" class="col-md-2 control-label"><i class="fa fa-star" style="color:#2196f3"></i> Organization: </label>
        <div class="col-md-9">
          <div style="display:none">Loading...</div>
          <select class="form-control" id="organizationInput" on-change="onOrganizationInputChange">
            <option>Loading...</option>
          </select>

          <div class="help-block">
            To add datasets to an <a href="/organization" target="_blank">organization</a>, <a href="/dashboard/organizations" target="_blank">you</a>
            must be a member of the organization with a role of 'editor' or 'admin'.
          </div>
        </div>
      </div>

      <div class="form-group">
        <label for="visibilityInput" class="col-md-2 control-label">Visibility: </label>
        <div class="col-md-9">
          <select class="form-control" id="visibilityInput" disabled="" on-change="onVisibilityInputChange">
            <option value="false">Public</option>
            <option value="true">Private</option>
          </select>

          <div class="help-block" id="visibilityWarnLabel">
            You must select an organization if you wish to set the dataset to private, otherwise the dataset must be public.
          </div>
        </div>
      </div>

      <!-- Version -->
      <div class="form-group">
        <label for="versionInput" class="col-md-2 control-label">Version</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="versionInput" on-change="onVersionInputChange">
        </div>
      </div>

      <!-- Website -->
      <div class="form-group">
        <label for="websiteInput" class="col-md-2 control-label">Website</label>
        <div class="col-md-9">
          <input type="text" class="form-control" id="websiteInput" on-change="onWebsiteInputChange">
        </div>
      </div>




      <h4 class="page-header">
          <a class="btn-toggle" on-click="toggleCat" cat="themeInput"><i class="fa fa-arrow-right"></i></a> Theme
      </h4>
      <ecosis-theme-input on-update="save" id="themeInput" style="display:none"></ecosis-theme-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="measureInput"><i class="fa fa-arrow-right"></i></a> Measurement
      </h4>
      <ecosis-measurement-input on-update="save" id="measureInput" style="display:none"></ecosis-measurement-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="processingInput"><i class="fa fa-arrow-right"></i></a> Processing Information
      </h4>
      <ecosis-processing-input on-update="save" id="processingInput" style="display:none"></ecosis-processing-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="instrumentInput"><i class="fa fa-arrow-right"></i></a> Instrument
      </h4>
      <ecosis-instrument-input on-update="save" id="instrumentInput" style="display:none"></ecosis-instrument-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="locationInput"><i class="fa fa-arrow-right"></i></a> Location
      </h4>
      <ecosis-location-input on-update="save" id="locationInput" style="display:none"></ecosis-location-input>

      <h4 class="page-header">
        <a class="btn-toggle" on-click="toggleCat" cat="citationInput"><i class="fa fa-arrow-right"></i></a> Citation
      </h4>
      <ecosis-citation-input on-update="save" id="citationInput" style="display:none"></ecosis-citation-input>

    </div>

    <!-- Create Dataset -->
    <a id="createDatasetBtn" class="btn btn-primary" style="display:none">Create Dataset</a>


    <div id="editModeFooter" style="display:none">
      Now <a href="#add-resources">add resources</a> to your dataset. <br>
    </div>

    <div class="layout horizontal" style="margin-top: 15px">
      <div class="flex">
        <a class="btn btn-primary" style="display:none" on-click="goToAdd" id="goToBtn"><i class="fa fa-plus"></i> Add Resources</a>
        <a class="btn btn-primary" style="display:none" on-click="goToList" id="goToListBtn"><i class="fa fa-list"></i> Current Resources</a>


        <a class="btn btn-primary" style="display:none" on-click="create" id="createBtn"><i class="fa fa-plus"></i> Create Dataset</a>

        <div id="helpCreatePanel" class="help-block" style="display:none">
          You must provide a valid dataset title to create.
        </div>
      </div>
      <div>
        <a class="btn btn-default" style="display:none" on-click="delete" id="deleteBtn"><i class="fa fa-trash"></i> Delete Dataset</a>
      </div>
    </div>



    <div class="well">
      <div>
        <i class="fa fa-star" style="color:#2196f3"></i> Recommented Input.  If you can't fill out everything, please try
        and at least fill out any starred field.
      </div>

      <div class="bugs" style="margin-top:20px">
          Found a bug?  Have an issue?  Let us know <a href="https://github.com/CSTARS/ckanext-esis/issues" target="_blank">here!</a>
      </div>

      <div class="gitInfo" id="gitInfo" style="display:none">
        <div><b>Branch:</b> <span id="gitBranchLabel"></span></div>
        <div><b>Version:</b> <span id="gitVersionLabel"></span></div>
        <div><b>Commit:</b> <span id="gitCommitLabel"></span></div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-basic-info',

    ready : function() {
      this.updateTimer = -1;

      if( ecosis.user ) this.setUsername();
      else ecosis.on('user-load', this.setUsername.bind(this));

      if( ecosis.ds.editMode ) {
        this.setMode('edit');
        if( ecosis.ds.loaded ) this.onDataLoad();
        else ecosis.ds.on('load', this.onDataLoad.bind(this));
      } else {
        this.setMode('create');
      }

      ecosis.ckan.getLicenseList(this.setLicenseList.bind(this));

      $.get(ecosis.ckan.host+'/spectra/gitInfo', function(resp){
        this.git = resp;
        if( this.git.branch != 'master' ) {
          this.$.gitInfo.style.display = 'block';
          this.$.gitBranchLabel.innerHTML = this.git.branch;
          this.$.gitVersionLabel.innerHTML = this.git.version;
          this.$.gitCommitLabel.innerHTML = this.git.commit;
        }
      }.bind(this));
    },

    setMode : function(mode) {
      this.mode = mode;
      if( mode == 'create' ) {
        this.$.createBtn.style.display = 'inline-block';
        this.updateCreateBtnState();
      } else {
        this.$.goToBtn.style.display = 'inline-block';
        this.$.goToListBtn.style.display = 'inline-block';
        this.$.deleteBtn.style.display = 'inline-block';
      }
    },

    onDataLoad : function() {
      var data = ecosis.ds.data;

      this.$.descriptionInput.value = data.notes || '';
      this.$.keywordInput.setTokens(data.tags || []);
      this.$.licenseInput.value = data.license_id || '';
      this.$.organizationInput.value = data.owner_org || '';
      this.$.visibilityInput.value = data.private ? 'true' : 'false';
      this.$.versionInput.value = data.version;
      this.$.websiteInput.value = ecosis.ds.getDatasetExtra('Website').value || '';

      this.updateVisibilityControl();
    },

    updateVisibilityControl : function() {
      if( !ecosis.ds.data.owner_org || ecosis.ds.data.owner_org == '' ) {
        this.$.visibilityInput.setAttribute('disabled', '');
        this.$.visibilityInput.value = 'false';
        ecosis.ds.data.private = false;
        this.$.visibilityWarnLabel.style.display = 'block';
      } else {
        this.$.visibilityInput.removeAttribute('disabled');
        this.$.visibilityWarnLabel.style.display = 'none';
        this.$.visibilityInput.value = ecosis.ds.data.private ? 'true' : 'false';
      }
    },

    updateCreateBtnState : function() {
      if( this.$.titleInput.validName ) {
        this.$.createBtn.removeAttribute('disabled');
        this.$.helpCreatePanel.style.display = 'none';
      } else {
        this.$.createBtn.setAttribute('disabled', '');
        this.$.helpCreatePanel.style.display = 'block';
      }
    },

    setLicenseList : function(resp) {
      if( resp.error ) return console.log('Error loading licenses :(');

      this.licenses = resp;
      var options = '<option></option>';
      for( var i = 0; i < resp.length; i++ ) {
        var item = resp[i];
        options += '<option value="'+item.id+'" '+(ecosis.ds.data.license_id == item.id ? 'selected' : '')+'>'+item.title+'</option>';
      }
      this.$.licenseInput.innerHTML = options;
    },

    setUsername : function() {
      if( !ecosis.user ) {
        alert("You are not logged in :(");
        window.location.href = ecosis.ckan.host + '/user/login';
      } else if( !ecosis.user.loggedIn ) {
        alert("You are not logged in :(");
        window.location.href = ecosis.ckan.host + '/user/login';
      }

      this.$.usernameLabel.innerHTML = ecosis.user.username;

      // set user orgs
      var options = '<option></option>';
      for( var i = 0; i < ecosis.user.organizations.length; i++ ) {
        var org = ecosis.user.organizations[i];
        options += '<option value="'+org.id+'">'+org.display_name+'</option>';
      }
      this.$.organizationInput.innerHTML = options;
    },

    goToAdd : function() {
      window.location = '#add-resources';
    },

    goToList : function() {
      window.location = '#current-resources';
    },

    delete : function() {
      if( confirm('Are you sure your want to remove this dataset?') ) {
        if( confirm('Are you REALLY sure your want to remove this dataset?!?') ) {
          ecosis.ckan.deletePackage(ecosis.ds.package_id,
            function(err, resp) {
              alert('dataset deleted.');
              window.location = '/dataset';
            }
          );
        }
      }
    },

    create : function() {
      this.$.createDatasetBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Creating...';
      this.$.createDatasetBtn.setAttribute('disabled', '');

      ecosis.ckan.createPackage(ecosis.ds.data,
          function(resp) {
            this.$.createDatasetBtn.innerHTML = '<i class="fa fa-plus"></i> Create Dataset';
            this.$.createDatasetBtn.removeAttribute('disabled');

            if( resp.error ) return alert('Failed to create dataset :(');
            if( !resp.id ) return alert('Failed to create dataset :(');

            // set the page
            window.location = '/import/?id='+resp.name+'#add-resources';
          }.bind(this)
      );
    },

    save : function() {
      if( this.mode == 'create' ) return;

      if( this.updateTimer != -1 ) clearTimeout(this.updateTimer);

      this.updateTimer = setTimeout(function(){
        this.updateTimer = -1;
        this._save();
      }.bind(this), 2000);
    },

    _save : function() {
      this.$.saveLabel.style.display = 'block';

      // make sure we have the correct package state
      // all resources need to be included when you make a updatePackage call
      ecosis.ckan.getPackage(ecosis.ds.package_id,
        function(resp) {
          if( resp.error ) {
            this.$.saveLabel.style.display = 'none';
            return alert('Failed to fetch for dataset update :(');
          }

          var metadata = resp.result;
          for( var key in ecosis.ds.data ) {
            metadata[key] = ecosis.ds.data[key];
          }

          ecosis.ckan.updatePackage(metadata,
            function(resp) {
              this.$.saveLabel.style.display = 'none';

              if( resp.error ) return alert('Failed to update dataset :(');
              if( !resp.result.id ) return alert('Failed to update dataset :(');

            }.bind(this)
          );
        }.bind(this)
      );
    },

    /* change handlers */
    onTitleInputChange : function() {
      this.updateCreateBtnState();
    },

    onOrganizationInputChange : function() {
      ecosis.ds.data.owner_org = this.$.organizationInput.value;
      this.updateVisibilityControl();
      this.save();
    },

    onDescriptionInputChange : function() {
      ecosis.ds.data.notes = this.$.descriptionInput.value;
      this.save();
    },

    onKeywordsChange : function() {
      var tokens = this.$.keywordInput.getTokens();
      var keywords = [];

      for( var i = 0; i < tokens.length; i++ ) {
        keywords.push({name: tokens[i].label});
      }

      ecosis.ds.data.tags = keywords;
      this.save();
    },

    onLicenseInputChange : function() {
      ecosis.ds.data.license_id = this.$.licenseInput.value;

      for( var i = 0; i < this.licenses.length; i++ ) {
        if( this.licenses[i].id == ecosis.ds.data.license_id ) {
          ecosis.ds.data.license_title = this.licenses[i].title;
          break;
        }
      }

      this.save();
    },

    onVisibilityInputChange : function() {
      ecosis.ds.data.private = this.$.visibilityInput.value == 'true' ? true : false;

      // push to search needs to know
      this.fire('visibility-change');
      this.save();
    },

    onVersionInputChange : function() {
      ecosis.ds.data.version = this.$.versionInput.value;
      this.save();
    },

    onWebsiteInputChange : function() {
      ecosis.ds.setDatasetExtra('Website', this.$.websiteInput.value);
      this.save();
    },


    toggleCat : function(e) {
      var id = e.currentTarget.getAttribute('cat');

      if( this.$[id].style.display == 'none' ) {
        e.currentTarget.querySelector('i').className = 'fa fa-arrow-down';
        this.$[id].className = 'animated fadeIn';
        this.$[id].style.display = 'block';
        if( this.$[id].onShow ) this.$[id].onShow();
      } else {
        e.currentTarget.querySelector('i').className = 'fa fa-arrow-right';
        this.$[id].style.display = 'none';
      }
    }

  })
</script>

<dom-module id="ecosis-page-current-resources">
  <style>
    :host {
      display : block;
      padding: 0 5%;
    }
    #legend {
      padding: 20px 0;
    }
  </style>

  <template>

    <h4 class="page-header">Current Resources</h4>

    <div id="resourceRoot"></div>

    <div id="noResources" style="display:none">
      Your dataset does not contain any resource files.  Click <a id="addLink">here</a> to upload resources.
    </div>

    <div id="legend">
      <div style="float:right">
        Click the <i class="fa fa-pencil"></i> icon to inspect or edit a resource.
      </div>

      <h6 style="margin-bottom:0">Resource List Legend</h6>
      <span class="label label-success">Spectral Data File</span>
      <span class="label label-primary">Metadata File</span>
      <span class="label label-info">Zip Package</span>
      <span class="label label-default">Auxiliary File (Ignored)</span>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-current-resources',

    ready : function() {
      if( ecosis.ds.loaded ) this.render();
      else ecosis.ds.on('load', this.render.bind(this));

      this.$.addLink.setAttribute('href', '#add-resources');
    },

    onShow : function() {
      this.render();
    },

    render : function() {
      if( ecosis.ds.resources.length == 0 ) {
        this.$.noResources.style.display = 'block';
        this.$.legend.style.display = 'none';
        return;
      } else {
        this.$.noResources.style.display = 'none';
        this.$.legend.style.display = 'block';
      }

      var html = '';

      for( var i = 0; i < ecosis.ds.resources.length; i++ ) {
        var resource = ecosis.ds.resources[i];
        html += '<ecosis-resource-panel resourceid="'+resource.id+'"></ecosis-resource-panel>';
      }

      this.$.resourceRoot.innerHTML = html;

      // listen for all update events
      $(this.$.resourceRoot)
        .find('ecosis-resource-panel')
        .on('update', this.onResourceUpdate.bind(this));
    },

    onResourceUpdate : function(e) {
      var id = e.originalEvent.detail;

      var panels = this.$.resourceRoot.querySelectorAll('ecosis-resource-panel');
      for( var i = 0; i < panels.length; i++ ) {
        if( panels[i].edit && panels[i].resourceid != id ) {
          var panel = panels[i]
          // hide resource
          panel.toggleEdit();
          // clear cached 'full' datasheet
          panel.$.datasheetUI.datasheet = null;
        }
      }
    }


  });
</script>

<dom-module id="ecosis-page-add-resource">
  <style>
    :host {
      display: block;
      padding: 0 5% 50px 5%;
    }
    #dropZone {
        border: 2px dashed #bbb;
        -moz-border-radius: 5px;
        -webkit-border-radius: 5px;
        border-radius: 5px;
        padding: 25px;
        font-size: 20pt;
        color: #bbb;
        background-color: white;
        margin: 15px 0 0 0;
    }
  </style>

  <template>
    <h4 class="page-header">Add Resources</h4>

    <h5 style="margin-bottom: 0">Select files to be uploaded</h5>
    <div style="font-size:12px;color:#888; margin-bottom: 30px">
        <span>Add new files below by using the file selector or drag files over the drop zone.</span>
    </div>

    <div class="well well-sm">

      <div class="form-horizontal">
        <div class="form-group">
          <label class="col-md-3 control-label">
              Default Orientation<br>
              <a on-click="toggleHelp" style="cursor: pointer">What is this?</a>
          </label>

          <div class="col-md-7">
            <div class="radio">
              <label>
                <input type="radio" name="optionsRadios" id="columnInput" value="column" checked="" on-click="onRadioChange">
                My data is laid out by column
              </label>
            </div>
            <div class="radio">
              <label>
                <input type="radio" name="optionsRadios" id="rowInput" value="row" on-click="onRadioChange">
                My data is laid out by row
              </label>
            </div>
          </div>
        </div>
      </div>

      <ecosis-dataformat-help id="formatHelp" style="display:none" class="animated fadeIn"></ecosis-dataformat-help>

    </div>
    <!-- end well -->

    <div id="processing" style="display: none">
        <h4 class="alert alert-success">Uploading &amp; Processing Files...</h4>
        <div id="uploadStatusTable"></div>
    </div>

    <div class="fileinput" id="fileInputPanel">
        <div>
            <input type="file" style="margin:30px 0 0 15px" id="file" name="file" multiple="" on-change="handleFileSelect">
            <!--<input type="file" style="display:none" id="addFileTesting" name="addFileTesting" multiple="" /> -->
        </div>

        <div class="file-select-group">
            <div id="dropZone"><b>OR</b> drag and drop files here</div>
        </div>
    </div>

    <div id="completePanel" style="display:none; margin-top:20px">
      <a id="completePanelLink" class="btn btn-default"><i class="fa fa-list"></i> Open resource list</a>
    </div>

    <div style="margin-top: 40px">
      <a on-click="toggleInfoPanel" style="cursor:pointer">Supported file types and the Ecosis Metadata Editor</a>
    </div>
    <div id="infoPanel" style="display:none" class="animated fadeInUp">
        <h6 class="page-header">Supported File Types</h6>
        <div class="well well-sm">
            <div>Currently the following tabular file types will be parsed.</div>
            <ul>
                <li>.xls</li>
                <li>.xlsx</li>
                <li>.csv</li>
                <li>.tsv (Tab Separated Value)</li>
                <li>.spectra (parsed as .tsv)</li>
                <li>.zip<span class="green">*</span></li>
            </ul>
            <div><span class="green">*</span>Zip files will be extracted on the server.
              Any files contained within the zip file that have supported extension will be parsed.</div>
            <div>Other file extensions are accepted but will not be parsed.</div>
        </div>

        <h6 class="page-header">Ecosis Metadata Editor</h6>
        <div class="well well-sm">
            <div>Need help packaging your data?  What to markup your data with EcoSIS metadata and controlled
              vocabularies so it can be easy discovered?  Use the <a href="https://github.com/CSTARS/ecosis-data-tool/releases" target="_blank">Ecosis Metadata Editor</a> to markup your metadata and create a package for your dataset to easily
              upload using this editor.</div>
        </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-add-resource',

    ready : function() {
      this.$.dropZone.addEventListener('dragover', this.handleDragOver.bind(this), false);
      this.$.dropZone.addEventListener('drop', this.handleFileSelect.bind(this), false);

      this.staggedFiles = [];
      this.newResourceIds = [];

      this.defaultType = 'column';
      this.$.formatHelp.setType('column');

      this.$.completePanelLink.setAttribute('href', '#current-resources');
    },

    onRadioChange : function() {
      if( $(this.$.columnInput).is(':checked') ) {
        this.$.formatHelp.setType('column');
        this.defaultType = 'column';
      } else {
        this.$.formatHelp.setType('row');
        this.defaultType = 'row';
      }
    },

    handleDragOver : function (evt) {
      evt.stopPropagation();
      evt.preventDefault();
      evt.dataTransfer.dropEffect = 'copy'; // Explicitly show this is a copy.
    },

    handleFileSelect : function(evt) {
      evt.stopPropagation();
      evt.preventDefault();

      this.setProcessing(true);

      var files = evt.dataTransfer ? evt.dataTransfer.files : evt.target.files; // FileList object.

      this.staggedFiles = [];
      this.newResourceIds = [];

      for( var i = 0; i < files.length; i++ ) {
          this.staggedFiles.push({
              file : files[i],
              name : files[i].name,
              aborted : false,
              xhr : null,
              progress : 0,
              type : this.defaultType,
              speed : '0Mbps'
          });
      }

      this.renderUploadStatusTable();
      this.uploadFiles(this.defaultType, 0);
    },

    setProcessing : function(processing) {
      if( processing ) {
        this.$.fileInputPanel.style.display = 'none';
        this.$.processing.style.display = 'block';
      } else {
        this.$.fileInputPanel.style.display = 'block';
        this.$.processing.style.display = 'none';
      }
    },

    onUploadComplete : function() {
        // set default layout and parse workspace
        ecosis.ckan.setDefaultLayout(
            ecosis.ds.package_id, this.newResourceIds, this.defaultType,
            function(resp) {
                if( resp.error ) return console.log('Error setting default resource layout :(');

                this.$.file.value = '';
                ecosis.ds.runAfterResourceAdd(resp);
                this.fire('resource-add');
                this.setProcessing(false);

                this.$.completePanel.style.display = 'block';
            }.bind(this)
        )
    },

    uploadFiles : function(type, index) {
        if( this.staggedFiles.length == index ) {
            // now tell server to parse resources with given type
            this.onUploadComplete();
            return;
        }

        var staggedFile = this.staggedFiles[index];

        if( staggedFile.aborted ) {
            index++;
            this._uploadFiles(type, index);
            return;
        }


        var file = this.staggedFiles[index].file;
        var reader = new FileReader();

        reader.onload = function(e) {
            staggedFile.xhr = ecosis.ckan.addResource(
                ecosis.ds.package_id,
                {
                    contents : e.target.result,
                    mimetype : file.type,
                    filename : file.name
                },
                function(resp) {
                    if( resp.error ) console.log('Error adding resource: '+file.name);

                    // save this, when we are done, we will set default parse type
                    this.newResourceIds.push(resp.result.id);

                    index++
                    this.uploadFiles(type, index);
                }.bind(this),
                function(progress, speed) {
                    this.staggedFiles[index].speed = speed;
                    this.staggedFiles[index].progress = progress;
                    this.updateStatusText(index);
                }.bind(this)
            );
        }.bind(this);
        reader.readAsArrayBuffer(file);
    },

    abort : function(e) {
        var index = parseInt(e.currentTarget.getAttribute('index'));
        e.currentTarget.style.display = 'none';

        var staggedFile = this.staggedFiles[index];

        if( staggedFile.progress == 100 ) return;

        staggedFile.aborted = true;

        this.updateStatusText(index);

        if( staggedFile.xhr ) {
            staggedFile.xhr.abort();
            index++;
            this._uploadFiles(this.defaultType, index);
        }
    },

    toggleHelp : function() {
        $(this.$.formatHelp).toggle();
    },

    toggleInfoPanel : function() {
      if( this.$.infoPanel.style.display == 'none') {
        $(this.$.infoPanel).show();
        $(window).scrollTop(254);
      } else {
        $(this.$.infoPanel).hide();
      }
    },

    renderUploadStatusTable : function() {
      var table = '<table class="table" style="text-align: left">';

      for( var i = 0; i < this.staggedFiles.length; i++ ) {
        var file = this.staggedFiles[i];

        table +=
          '<tr>'+
            '<td><b>'+file.name+'</b></td>'+
            '<td style="color:#888" index="'+i+'">'+this.getFileStatusText(file)+'</td>'+
            '<td>'+
              '<a class="btn btn-default" index="'+i+'">Abort</a>'+
            '</td>'
          '</tr>'
      }
      table += '</table>';

      this.$.uploadStatusTable.innerHTML = table;

      $(this.$.uploadStatusTable)
        .find('a')
        .on('click', this.abort.bind(this));
    },

    getFileStatusText : function(file) {
      if( file.progress != 100 && !file.aborted ) {
        return 'Uploading: '+file.progress+'% @ '+file.speed;
      } else if ( file.progress == 100 && !file.aborted ) {
        return 'Upload Complete. Processing...';
      } else if( file.aborted ) {
        return '<span class="label label-danger">Aborted</span>';
      }

      return '';
    },

    updateStatusText : function(index) {
      var td = this.$.uploadStatusTable.querySelector('td[index="'+index+'"]');
      if( td ) td.innerHTML = this.getFileStatusText(this.staggedFiles[index]);
    }


  });
</script>

<dom-module id="ecosis-attribute-mapping">
  <style>
    :host {
      display: block;
    }
    .save-label {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        text-align: center;
        z-index: 1000;
        display: none;
    }
    table.table th {
      border : none;
    }
  </style>

  <template>
    <div class="save-label" id="saveLabel">
      <span class="label label-primary"><i></i> Saving...</span>
    </div>

    <div class="well">
        If your spectra metadata attribute names do not match the EcoSIS metadata names, you can download
        the attribute map file.  Fill out the file and then upload in the box to the right.  You can
        reuse this file, so you only have to fill it out once for your data.  Just make sure to set
        the attribute map for each dataset you add.
    </div>

    <div class="well">
      <div class="panel panel-primary">
        <div class="panel-heading">
          <h3 class="panel-title">Map Spectra Attributes</h3>
        </div>
        <div class="panel-body">
          <h5 class="page-header" style="margin-top:0">By File</h5>

          <div class="horizontal layout">
              <div class="flex">
                  <a class="btn btn-default" target="_blank" href="/metadata_map">Download Map Template</a>
              </div>
              <div class="flex">
                  Upload Map: <input type="file" style="margin-top:5px" id="map" name="map" on-change="processMap">

                  <input type="file" style="display:none" id="addAttrMap" name="addAttrMap">
              </div>
          </div>
          <div class="help-block">
            Use this to bulk upload and set the attribute name mapping.  This is map file can be
            reused across your datasets.  NOTE:  This will overwrite all current attribute mappings.
          </div>

          <h5 class="page-header">Individually</h5>
          <div class="help-block">
            Use this to add individual spectra attribute mappings.
          </div>

          <table class="table">
            <tbody><tr>
              <th>EcoSIS</th>
              <th></th>
              <th id="dsTitleLabel"></th>
              <th></th>
            </tr>
            <tr>
              <td>
                <select id="newEcosis" class="form-control"></select>
              </td>
              <td>
                <i class="fa fa-arrow-right"></i>
              </td>
              <td>
                <select id="newCustom" class="form-control"></select>
              </td>
              <td>
                <a class="btn btn-primary" on-click="add" style="margin: 5px"><i class="fa fa-plus"></i> Add</a>
              </td>
            </tr>
          </tbody></table>

          <a on-click="toggleMetadata" style="cursor:pointer">EcoSIS Metadata Information</a>
  			  <ecosis-metadata-docs id="metadataDocs"></ecosis-metadata-docs>

        </div>
      </div>

      <div class="panel panel-primary" id="currentPanel">
        <div class="panel-heading">
          <h3 class="panel-title">Current Spectra Name Mappings</h3>
        </div>
        <div class="panel-body" id="currentMapRoot"></div>
      </div>
    </div>

  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-attribute-mapping',

    ready : function() {
      ecosis.ds.on('load', function(){
        this.$.dsTitleLabel.innerHTML = ecosis.ds.data.title;
        this.updateSelectList();
        this.updateMap();
      }.bind(this));
    },

    onShow : function() {
      this.updateSelectList();
      this.updateMap();
    },

    processMap : function(e) {
      e.stopPropagation();
      e.preventDefault();

      var files = e.dataTransfer ? e.dataTransfer.files : e.target.files;
      if( files.length == 0 ) return;

      var reader = new FileReader();
      var contents, parts;

      reader.onload = function(e) {
          var newMap = {};
          contents = e.target.result.split('\n');

          for( var i = 0; i < contents.length; i++ ) {
              if( contents[i].indexOf('=') > -1 ) {
                  parts = contents[i].split('=');
                  newMap[parts[0]] = parts[1];
                  //if( parts[1].length > 0 ) inverseMap[parts[1]] = parts[0];
              }
          }

          this.$.map.value = '';
          this.updateAttrMapList(newMap);
      }.bind(this);

      reader.readAsText(files[0]);
    },

    updateMap : function() {
      var c = 0, item = {};
      var map = ecosis.ds.attributeMap;
      this.attrMapList = [];

      for( var key in map ) {
          if( map[key] && map[key].length > 0 ) {
              this.attrMapList.push({
                  ecosis : key,
                  custom : map[key]
              });
          } else {
              delete map[key]
          }
      }

      this.attrMapList.sort(function(a, b){
          if( a.ecosis > b.ecosis ) return 1;
          if( a.ecosis < b.ecosis ) return -1;
          return 0;
      });

      this.renderCurrentList();
    },

    updateSelectList : function() {
      this.selectList = [];
      this.customList = [];

      var html = '<optgroup><option></option></optgroup>';
      for( var key in ecosis.ds.metadataDefinitions ) {
          html += '<optgroup label="'+key+'">';

          var attrs = ecosis.ds.metadataDefinitions[key];

          for( var i = 0; i < attrs.length; i++ ) {
              if( !ecosis.ds.attributeMap[attrs[i].name] ) {
                  html += '<option value="'+attrs[i].name+'">'+attrs[i].name+'</option>'
              }
          }
          html += '</optgroup>';
      }

      this.$.newEcosis.innerHTML = html;

      for( var i = 0; i < ecosis.ds.schema.length; i++ ) {
          var s = ecosis.ds.schema[i];
          if( s.type != "metadata" ) continue;
          if( ecosis.ds.attributeMap[s.name] ) continue;

          this.customList.push(s.name);
      }

      this.customList.sort(function(a, b){
          if( a.toLowerCase() > b.toLowerCase() ) return 1;
          if( a.toLowerCase() < b.toLowerCase() ) return -1;
          return 0;
      });

      html = '<option></option>';
      for( var i = 0; i < this.customList.length; i++ ) {
        html += '<option value="'+this.customList[i]+'">'+this.customList[i]+'</option>'
      }
      this.$.newCustom.innerHTML = html;
    },

    renderCurrentList : function() {
      if( Object.keys(ecosis.ds.attributeMap).length == 0 ) {
        this.$.currentMapRoot.innerHTML = 'No attributes currently mapped';
        return;
      }

      var table =
        '<table class="table">'+
          '<tr>'+
              '<th>EcoSIS</th>'+
              '<th>'+ecosis.ds.data.title+'</th>'+
              '<th>Remove</th>'+
          '</tr>';

      for( var i = 0; i < this.attrMapList.length; i++ ) {
        var item = this.attrMapList[i];
        table += '<tr>'+
              '<td>'+item.ecosis+'</td>'+
              '<td>'+item.custom+'</td>'+
              '<td><a class="btn btn-default" attribute="'+item.custom+'"><i class="fa fa-trash"></i></a></td>'+
          '</tr>';
      }
      table += '</table>';

      this.$.currentMapRoot.innerHTML = table;

      $(this.$.currentMapRoot)
        .find('a.btn')
        .on('click', this.remove.bind(this));

    },

    remove : function(e) {
      var custom = e.currentTarget.getAttribute('attribute');
      var ecosisAttr = ecosis.ds.inverseAttributeMap[custom];

      if( !confirm('Are you sure you want to remove the mapping: '+ecosisAttr+' = '+custom+'?') ) return;

      delete ecosis.ds.attributeMap[ecosisAttr];
      delete ecosis.ds.inverseAttributeMap[custom];

      this.save(ecosis.ds.attributeMap);
    },

    add : function() {
      var ecosisAttr = this.$.newEcosis.value;
      var custom = this.$.newCustom.value;

      if( ecosisAttr.length == 0 || custom.length == 0 ) return alert('Please select both attributes to map first');

      ecosis.ds.attributeMap[ecosisAttr] = custom;
      ecosis.ds.inverseAttributeMap[custom] = ecosisAttr;

      this.$.newEcosis.value = '';
      this.$.newCustom.value = '';

      this.save(ecosis.ds.attributeMap);
    },

    updateAttrMapList : function(newMap) {
      this.attrMapList = [];

      var c = 0, item = {};
      var map = newMap || this.map;

      if( newMap ) {
          ecosis.ds.attributeMap = newMap;
          ecosis.ds.inverseAttributeMap = {};

          for( var key in newMap ) {
              if( newMap[key] != '' ) ecosis.ds.inverseAttributeMap[newMap[key]] = key;
          }
      }

      this.save(newMap);
    },

    save : function(newMap) {
      this.$.saveLabel.style.display = 'block';

      ecosis.ckan.setAttributeMap(ecosis.ds.package_id,newMap,
        function(resp) {
          this.$.saveLabel.style.display = 'none';

          this.updateMap();
          this.updateSelectList();
          if( resp.error ) alert('Error saving attribute name mapping');
        }.bind(this)
      )
    },

    toggleMetadata : function() {
      this.$.metadataDocs.toggle();
    }

  })
</script>

<dom-module id="ecosis-dataset-order">
  <style>
    :host {
      display : block;
    }
    .save-label {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        text-align: center;
        z-index: 1000;
        display: none;
    }
  </style>

  <template>
    <div class="save-label" id="saveLabel">
      <span class="label label-primary"><i></i> Saving...</span>
    </div>

    <div class="well">
      <div>
          Is this a time series dataset or a dataset that has any other form of ordering?
          If so, select the attribute to order by as well as the type of sort that should
          be performed.  You can also provide a textual description of what this ordering is.
      </div>

      <div class="form-horizontal">
        <div class="form-group">
          <label for="orderByInput" class="col-md-2 control-label">Order By</label>
          <div class="col-md-10">
            <select id="orderByInput" class="form-control" on-change="onChange"></select>
          </div>
        </div>

        <div class="form-group" style="display:none" id="secondaryPanel">
          <label for="orderTypeInput" class="col-md-2 control-label">Order Type</label>
          <div class="col-md-10">

            <select id="orderTypeInput" class="form-control" on-change="onChange">
                <option value="string">Default (String)</option>
                <option value="datetime">Date</option>
                <option value="numeric">Numeric</option>
            </select>

            <div class="help-block" id="dateHelp" style="display:none">
                Use <a href="http://www.w3.org/TR/NOTE-datetime" target="_blank">ISO-8601</a>
                for which the format is: YYYY-MM-DDTHH:mm:ss.sssZ.
                <a href="http://xkcd.com/1179/" target="_blank">Why?</a>
            </div>


            <input type="text" id="descriptionInput" class="form-control" on-change="onChange" placeholder="Description">

          </div>
        </div>
      </div>
    </div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-dataset-order',

    ready : function() {
      ecosis.ds.on('load', this.update.bind(this));
    },

    onShow : function() {
      this.update();
    },

    update : function() {
      this.attributeArray = [];

      for( var i = 0; i < ecosis.ds.schema.length; i++ ) {
          var attr = ecosis.ds.schema[i];
          if( attr.type == 'metadata' ) this.attributeArray.push(attr);
      }

      this.attributeArray.sort(function(a, b){
          if( a.name > b.name ) return 1;
          if( a.name < b.name ) return -1;
          return 0;
      });

      var options = '<option></option>';
      for( var i = 0; i < this.attributeArray.length; i++ ) {
        options += '<option value="'+this.attributeArray[i].name+'">'+this.attributeArray[i].name+'</option>';
      }

      this.$.orderByInput.innerHTML = options;

      var sort_description = ecosis.ds.getDatasetExtra('sort_description').value || '';
      var sort_type = ecosis.ds.getDatasetExtra('sort_type').value || '';
      var sort_on = ecosis.ds.getDatasetExtra('sort_on').value || '';

      this.$.orderByInput.value = sort_on;
      this.$.orderTypeInput.value = sort_type;
      this.$.descriptionInput.value = sort_description;

      if( sort_on && sort_on != '' ) {
        this.$.secondaryPanel.style.display = 'block';
      } else {
        this.$.secondaryPanel.style.display = 'none';
      }

      if( sort_type == 'datetime' ) {
        this.$.dateHelp.style.display = 'block';
      } else {
        this.$.dateHelp.style.display = 'none';
      }
    },

    onChange : function() {
      var sort_on = this.$.orderByInput.value;
      var sort_type = this.$.orderTypeInput.value;

      ecosis.ds.setDatasetExtra('sort_description', this.$.descriptionInput.value);
      ecosis.ds.setDatasetExtra('sort_type', sort_type);
      ecosis.ds.setDatasetExtra('sort_on', sort_on);


      if( sort_on && sort_on != '' ) {
        this.$.secondaryPanel.style.display = 'block';
      } else {
        this.$.secondaryPanel.style.display = 'none';
      }

      if( sort_type == 'datetime' ) {
        this.$.dateHelp.style.display = 'block';
      } else {
        this.$.dateHelp.style.display = 'none';
      }

      if( this.timer != -1 ) clearTimeout(this.timer);

      this.timer = setTimeout(function() {
          this.timer = -1;
          this.save();
      }.bind(this), 2000);
    },

    save : function() {
        this.$.saveLabel.style.display = 'block';

        // make sure we have the correct package state
        // all resources need to be included when you make a updatePackage call
        ecosis.ckan.getPackage(ecosis.ds.package_id,
          function(resp) {
            if( resp.error ) {
              this.$.saveLabel.style.display = 'none';
              return alert('Failed to fetch for dataset update :(');
            }

            var metadata = resp.result;
            for( var key in ecosis.ds.data ) {
              metadata[key] = ecosis.ds.data[key];
            }

            ecosis.ckan.updatePackage(metadata,
              function(resp) {
                this.$.saveLabel.style.display = 'none';

                if( resp.error ) return alert('Failed to update dataset :(');
                if( !resp.result.id ) return alert('Failed to update dataset :(');

              }.bind(this)
            );
          }.bind(this)
        );
    }
  });
</script>
<dom-module id="ecosis-page-advanced">
  <style>
    :host {
      display: block;
      padding: 0 5%;
    }
  </style>

  <template>

    <h4 class="page-header">Map Dataset Attribute Names</h4>
    <ecosis-attribute-mapping id="mapping"></ecosis-attribute-mapping>

    <h4 class="page-header">Dataset Ordering</h4>
    <ecosis-dataset-order style="margin-bottom: 50px" id="order"></ecosis-dataset-order>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-advanced',

    onShow : function() {
      this.$.mapping.onShow();
      this.$.order.onShow();
    }
  })
</script>

<dom-module id="ecosis-page-push">
  <style>
    :host {
      display: block;
      padding: 0 5%;
    }
    #main {
      margin-bottom: 50px;
    }
  </style>

  <template>
    <h4 class="page-header">Push to Search</h4>


		<div class="alert alert-danger" style="display:none" id="privateAlertPanel">
			You have marked this dataset as private. Your results cannot be pushed to PUBLIC search.
		</div>

		<div id="main">
			<div class="help-block">
				Please verify all information looks correct.  Once everything looks correct, click 'Push'
        below and your changes will be represented at <a href="http://ecospectra.org" target="_blank">ecospectra.org</a>.
         Please note, a minimum of 3 EcoSIS metadata attributes are required to push your dataset.
			</div>

			<div class="well">
				<h4>Basic Information</h4>
				<table class="table">
					<tbody><tr><td>Title</td><td id="title"></td></tr>
					<tr><td>Name</td><td id="name"></td></tr>
					<tr><td>Description</td><td id="notes"></td></tr>
					<tr><td>Organization</td><td id="owner_org_name"></td></tr>
					<tr><td>Visibility</td><td>Public</td></tr>
				</tbody></table>
			</div>

			<div class="well">
				<h4>Resource Information</h4>
				<table class="table">
					<tbody><tr><td>Total Resources</td><td id="tResources"></td></tr>
					<tr><td>Metadata Sheets</td><td id="tMeta"></td></tr>
					<tr><td>Spectra Sheets</td><td id="tData"></td></tr>
					<tr><td># Parsed Spectra</td><td id="tSpectra"></td></tr>
				</tbody></table>
			</div>

			<div class="well">
				<h4>EcoSIS Metadata Information</h4>
				<div id="ecosisInfo"></div>


        <a on-click="toggleMetadata" style="cursor:pointer">EcoSIS Metadata Information</a>
			  <ecosis-metadata-docs id="metadataDocs"></ecosis-metadata-docs>
      </div>

      <div>
        <a class="btn btn-primary" id="pushBtn" on-click="push">Push</a>
      </div>

      <div style="padding: 15px 0">
        <div class="checkbox">
          <label>
            <input type="checkbox" id="responseEmailInput" checked=""> Email me when the dataset is available in search.
            <div class="help-block">Datasets can take several minutes to show up in search.  We can send you and email when
              the dataset is ready.
            </div>
          </label>
        </div>
      </div>


      <div class="help-block" id="pushMessage" style="display:none">Queuing push to search...</div>
		</div>
  </template>
</dom-module>

<script>
  Polymer({
    is : 'ecosis-page-push',

    ready : function() {
      this.requireEcosisAttrs = 3;
      this.warnEcosisAttrs = 8;

      ecosis.ds.on('load', this.update.bind(this));
    },

    onShow : function() {
      this.update();
    },

    update : function() {

      if( ecosis.ds.data.private ) {
        this.$.privateAlertPanel.style.display = 'block';
        this.$.main.style.display = 'none';
      } else {
        this.$.privateAlertPanel.style.display = 'none';
        this.$.main.style.display = 'block';

        this.updateLabels();
        this.updateCounts();
      }
    },

    updateLabels : function() {
      for( var key in ecosis.ds.data ) {
        if( key == 'owner_org' ) {
          for( var i = 0; i < ecosis.user.organizations.length; i++ ) {
            if( ecosis.user.organizations[i].id == ecosis.ds.data.owner_org ) {
              this.$.owner_org_name.innerHTML = ecosis.user.organizations[i].display_name;
              break;
            }
          }

        } else if( this.$[key] ) {
          this.$[key].innerHTML = ecosis.ds.data[key];
        }


      }
    },

    updateCounts : function() {
			this.counts = {
				metadataResources : 0,
				measurementResources : 0,
				measurements : 0
			}

			for( var i = 0; i < ecosis.ds.resources.length; i++ ) {
				var resource = ecosis.ds.resources[i];
				if( !resource.datasheets || resource.ignore ) continue;

				for( var j = 0; j < resource.datasheets.length; j++ ) {
					var datasheet = resource.datasheets[j];
					if( datasheet.ignore ) continue;

					if( datasheet.metadata ) {
						this.counts.metadataResources++;
					} else if ( datasheet.spectra_count ) {
						this.counts.measurementResources++;
						this.counts.measurements += datasheet.spectra_count;
					}
				}
			}

      this.$.tResources.innerHTML = ecosis.ds.resources.length;
      this.$.tMeta.innerHTML = this.counts.metadataResources;
      this.$.tData.innerHTML = this.counts.measurementResources;
      this.$.tSpectra.innerHTML = this.counts.measurements;

			this.updatePushStatus();
		},

		updatePushStatus : function() {
			var attrs = [];
			var count = 0;

      // check for spectra level ecosis metadata
			ecosis.ds.schema.forEach(function(item){
				if( ecosis.ds.isEcosisMetadata(item.name) ) {
          count++;
        } else if( ecosis.ds.inverseAttributeMap[item.name] &&
                  ecosis.ds.isEcosisMetadata(ecosis.ds.inverseAttributeMap[item.name]) ) {

          count++;
        }
			}.bind(this));

      var map = {
        'Keywords' : 'tags',
        'Author' : 'author',
        'Author Email' : 'author_email',
        'Maintainer' : 'maintainer',
        'Maintainer Email' : 'maintainer_email'
      }

      // check dataset level ecosis metadata
      for( var key in ecosis.ds.metadataLookup ) {
        if( map[key] && ecosis.ds.data[map[key]] ) {
          count++;
        } else if( ecosis.ds.getDatasetExtra(key).value ) {
          count++;
        }
      }


			if( count < this.requireEcosisAttrs ) {
				this.$.pushBtn.style.display = 'none';
				this.$.ecosisInfo.innerHTML =
					'<span class="label label-danger" style="font-size:14px">' +
						'You have '+count+' <i class="fa fa-star"></i> EcoSIS metadata attributes. ' +
						this.requireEcosisAttrs + ' are required to push to search.' +
					'</span>';
				return;
			}

			this.$.pushBtn.style.display = 'inline-block';
			if( count < this.warnEcosisAttrs ) {
				this.$.ecosisInfo.innerHTML =
					'<span class="label label-warning" style="font-size:14px">' +
						'You have '+count+' <i class="fa fa-star"></i> EcoSIS metadata attributes. ' +
						this.warnEcosisAttrs + ' are recommended.' +
					'</span>';
				return;
			}

			this.$.ecosisInfo.innerHTML =
				'<span class="label label-success" style="font-size:14px">' +
					'You have '+count+' <i class="fa fa-star"></i> EcoSIS metadata attributes. ' +
				'</span>';

		},

    push : function() {
      this.$.pushBtn.setAttribute('disabled', '');
      this.$.pushBtn.innerHTML = '<i class="fa fa-spinner fa-spin"></i> Queuing...';
      this.$.pushMessage.style.display = 'block';

      var includeEmail = $(this.$.responseEmailInput).is(':checked');

      ecosis.ckan.pushToSearch(ecosis.ds.package_id, includeEmail,
          function(resp){
            this.$.pushBtn.removeAttribute('disabled');
            this.$.pushBtn.innerHTML = 'Push';
            this.$.pushMessage.style.display = 'none';

            if( resp.error ) {
                alert('Error pushing dataset to search :(');
            } else {
                var msg = 'Success.  Your dataset is processing.';
                if( resp.emailingResult && resp.email ) {
                  msg += '  You will be emailed at '+resp.email+' when the dataset is ready.';
                } else {
                  msg += '  Please give some time for your dataset to show in search.  No email will be sent.';
                }

                alert(msg);
                window.location = ecosis.ckan.host + '/dataset/' + ecosis.ds.package_id;
            }
          }.bind(this)
      );
    },

    toggleMetadata : function() {
      this.$.metadataDocs.toggle();
    }
  })
</script>
</div></body></html>