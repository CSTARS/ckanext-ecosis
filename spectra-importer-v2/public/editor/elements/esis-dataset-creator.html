<link rel="import" href="../components/paper-fab/paper-fab.html">
<link rel="import" href="../components/paper-dialog/paper-dialog.html">
<link rel="import" href="panels/esis-verify-dataset.html" />

<polymer-element name="esis-dataset-creator">
	<template>
		<link rel="stylesheet" href="../components/animate-css/animate.min.css">
		<style>
			paper-fab {
				color: #2f9b45;
				background-color: white;
				position: absolute;
				right: 10px;
				top: -55px;
				cursor: pointer;
			}
			paper-fab:hover {
				background-color: #eee;
			}
		</style>

		<paper-fab icon="check-circle-outline" on-tap="{{show}}" hidden?="{{hide}}" class="animated rollIn"></paper-fab>
		
		<paper-dialog id="dialog" layered backdrop transition="paper-transition-bottom">
			<div hidden?="{{uploading}}">
				<esis-verify-dataset ds="{{ds}}" counts="{{counts}}" on-finalize="{{create}}" on-cancel="{{_cancel}}"></esis-verify-dataset>
			</div>
			<div hidden?="{{!uploading}}">
				<h4>{{ds.editMode ? 'Updating' : 'Creating'}} Dataset...</h4>
				<div>{{statusText}}</div>
			</div>
		</paper-dialog>
	</template>
	<script>
		Polymer('esis-dataset-creator', {
			hide : true,
			ds : {},
			ckan : {},

			counts : {
				spectraResources : 0,
				metadataResources : 0,
				spectra : 0
			},

			observe : {
				'ds.data.name' : '_updateVisibility',
				'ds.deleted' : '_updateVisibility',
				'ds.datasheets' : '_filesUpdated'
			},

			uploading : false,
			statusText : '',

			ready : function() {
				this.ds = document.querySelector('esis-datastore');
				this.ckan = document.querySelector('esis-ckan');
			},

			show : function() {
				this.$.dialog.toggle();
			},

			_filesUpdated : function() {
				this.async(function(){
					this.counts = {
						spectraResources : 0,
						metadataResources : 0,
						spectra : 0
					};

					for( var i = 0; i < this.ds.datasheets.length; i++ ) {
						if( this.ds.datasheets[i].isMetadata ) {
							this.counts.metadataResources++;
						} else if ( this.ds.datasheets[i].spectra.length > 0 ) {
							this.counts.spectraResources++;
							this.counts.spectra += this.ds.datasheets[i].spectra.length;
						}
						
					}
				});
				

				this._updateVisibility();
			},

			_updateVisibility : function() {
				if( (this.ds.data.name != '' && this.ds.files.length > 0) || this.ds.editMode ) {
					this.hide = false;
				} else {
					this.hide = true;
				}
			},

			_cancel : function() {
				this.$.dialog.toggle();
			},

			// create a new ckan package
			create : function() {
				var pkg = $.extend(true, {}, this.ds.data);
				
				this.uploading = true,
				this.statusText = (this.ds.editMode ? 'Updating' : 'Creating initial') + ' dataset package...';

				var pkg = document.querySelector('esis-dataset-loader').data;
				for( var key in this.ds.data ) {
					pkg[key] = this.ds.data[key];
				}

				var action = this.ds.editMode ? this.ckan.updatePackage : this.ckan.createPackage;
				action(pkg, function(err, resp){
					if( err ) {
						alert('Error '+(this.ds.editMode ? 'updating' : 'creating')+' dataset');
						this.uploading = false;
						return;
					}

					this._addResources(resp);
				}.bind(this));
			},

			_addResources : function(pkg) {
				this.statusText = 'Preparing Resources...';				

				// verify verify everything is ok
				// if not, quit
				// you can't use this for upload though! it will not have the resource id assign
				// since the resources have to be uploaded first!
				if( !this._isDataUnique() ) {
					alert('Your spectra signatures are not inherently unique.  Please provide a metadata '+
						'field that can serve as a unique identifier.');
					//_createUidSelector(data);
					//btn.removeClass('disabled').html('Add Resources');
					this.uploading = false;
					return;
				}

				this.statusText = 'Adding...';

				this._addResourceToCkan(0, pkg.name);
			},

			_addResourceToCkan: function(index, pkgid) {
				if( this.ds.resources.length == index ) {
					this._removeDeletedResources(0, function(){
						this._uploadSpectraResource(pkgid, function(){
							this.statusText = 'Complete';
							setTimeout(function(){
								window.location = esis.host+'/dataset/'+pkgid;
							}, 500);
						}.bind(this));
					}.bind(this));
				} else {
					this.statusText = 'Uploading '+this.ds.resources[index].filename+'...';
					this.ckan.addResource(
						pkgid, 
						this.ds.resources[index], 
						false, 
						function(err, resp){
							if( err ) {
								this.uploading = false;
								return alert('Error creating ckan resource');
							}

							index++;
							this._addResourceToCkan(index, pkgid);
						}.bind(this), 
						function(progress){
							this.statusText = 'Uploading '+this.ds.resources[index].filename+' ('+(progress*100)+'%)...';
						}.bind(this)
					);
				}
			},

			_removeDeletedResources : function(index, callback) {
				if( !this.ds.editMode || this.ds.deleted.length == 0 || this.ds.deleted.length == index ) return callback();

				this.statusText = 'Removing deleted resources '+(index+1)+'/'+this.ds.deleted.length;
				this.ckan.removeResource(this.ds.deleted[index], function(err, resp){
					// TODO: add error checking

					index++;
					this._removeDeletedResources(index, callback);
				}.bind(this));
			},

			_isDataUnique: function() {
				var spectra = [];
				var ids = [];

				for( var i = 0; i < this.ds.datasheets.length; i++ ) {
					var f = this.ds.datasheets[i];
					for( var j = 0; j < f.spectra.length; j++ ) {
						// make sure the latest uid for the spectra is generated
						f.spectra[j].updateUid();

						if( ids.indexOf( f.spectra[j].spectra_id ) != -1 ) return false;
						else ids.push( f.spectra[j].spectra_id );
					}
				}

				return true;
			},

			_createSpectraJsonResource : function() {
				var spectra = [];

				for( var i = 0; i < this.ds.datasheets.length; i++ ) {
					var f = this.ds.datasheets[i];
					for( var j = 0; j < f.spectra.length; j++ ) {
						spectra.push(f.spectra[j]);
					}
				}

				var uid = $('#unique-id-input').val();
				var uidType = '';
				if( !uid ) {
					uid = '';
				} else {
					var parts = uid.split('.');
					uidType = parts[0];
					uid = parts[1];
				}

				var data = [];
				for( var i = 0; i < spectra.length; i++ ) {
					var d = {
						metadata : spectra[i].mergeMetadata(),
						spectra : spectra[i].data,
						filename : spectra[i].filename,
						sheetname : spectra[i].sheetname,
						resource_id : spectra[i].resourceId,
						spectra_id : spectra[i].spectra_id,
						ecosis : {}
					};

					// now set the ecosis attributes
					for( var key in d.metadata ) {
						if( this._isEcosisMetadata(key) ) {
							d.ecosis[key] = d.metadata[key];
							// in this case their value is our value, so delete their value
							delete d.metadata[key];
						} else if( this.ds.inverseAttributeMap[key] ) {
							var ecosisKey = this.ds.inverseAttributeMap[key];
							d.ecosis[ecosisKey] = d.metadata[key];
						}
					}

					data.push(d);
				}

				var dataset;
				if( this.ds.editMode ) {
					dataset = this.ds.existing.dataset;

					if( !dataset.data ) dataset.data = [];
					if( !dataset.join ) dataset.join = [];
					if( !dataset.group_by ) dataset.group_by = this.ds.group;
					if( !dataset.map ) dataset.map = this.ds.inverseAttributeMap;

					// move all newly joined data
					for( var i = 0; i < dataset.data.length; i++ ){
						var d = dataset.data[i];
						if( !d.metadata.joined ) continue;

						for( var key in d.metadata.joined ) {
							if( this._isEcosisMetadata(key) ) {
								d.ecosis[key] = d.metadata.joined[key];
							} else if( this.ds.inverseAttributeMap[key] ) {
								var ecosisKey = this.ds.inverseAttributeMap[key];
								d.ecosis[ecosisKey] = d.metadata.joined[key];
								// still keep old reference
								d.metadata[key] = d.metadata.joined[key];
							} else {
								d.metadata[key] = d.metadata.joined[key];
							}
						}
						delete d.metadata.joined;
					}

					for( var i = 0; i < data.length; i++ ) dataset.data.push(data[i]);

					var joindata = this._getJoinableData();
					for( var i = 0; i < joindata.length; i++ ) dataset.join.push(joindata[i]);

					//dataset.group_by = esis.app.groupBy.get();
				} else {
					dataset = {
						data : data,
						map  : this.ds.inverseAttributeMap,
						join : this._getJoinableData(),
						group_by : this.ds.group
					}
				};

				// we need to clean all of the attribute here ...
				for( var i = 0; i < dataset.data.length; i++ ) {
					var metadata = dataset.data[i].metadata;
					for( var key in metadata ) {
						var tmp = key.replace(/[^A-Za-z0-9\s_-]/g, '');
						if( tmp != key ) {
							if( metadata[tmp] ) {
								alert('Metadata Error: the attribute "'+key+'" has illegal characters.  Attempted to clean up key to "'+
									tmp+'" but this key already exists.');
								return;
							}

							metadata[tmp] = metadata[key];
							delete metadata[key];
						}
					}
				}

				var resource = document.createElement('esis-resource');
				resource.contents = JSON.stringify(dataset);
				resource.filename = 'esis_spectral_data.json';
				resource.mimetype ='application/json';

				// if we are editing make sure we set the resource id so this performs and update if spectra
				// resource already exists
				if( this.ds.editMode ) {
					var resources = document.querySelector('esis-dataset-loader').data.resources;
					for( var i = 0; i < resources.length; i++ ) {
						if( resources[i].name == 'esis_spectral_data.') {
							resource.resourceId = resources[i].id;
							break;
						}
					}					
				}

				return resource;
			},

			_getJoinableData: function() {
				var arr = [];

				for( var i = 0; i < this.ds.datasheets.length; i++ ) {
					var jd = this.ds.datasheets[i];
					if( !jd.isMetadata ) continue;
					jd = jd.metadata;

					arr.push({
						metadata : jd.metadata,
						join_id : jd.joinId,
						join_on : jd.getJoinType(),
						resource_id : jd.resourceId
					});
				}
				
				return arr;
			},

	    	_uploadSpectraResource : function(pkgId, callback) {
		        //this._cleanOldSpectralResource(pkgId, function(){
		        	this.statusText = 'Uploading spectral data resource...';

			        this.ckan.addResource(
						pkgId, 
						this._createSpectraJsonResource(), 
						true, 
						function(err, resp){
							if( err ) {
								this.uploading = false;
								return alert('Error creating ckan resource');
							}

							callback();
						}.bind(this), 
						function(progress){
							this.statusText = 'Uploading spectral data resource ('+(progress*100)+'%)...';
						}.bind(this)
					);
		        //}.bind(this));
		    },

		    /*_cleanOldSpectralResource : function(pkgid, callback) {
		    	this.statusText = 'Cleaning old spectral data';

		    	this.ckan.getPackage(pkgid, function(err, pkg){
		    		if( err ) return callback(err);

		    		if( !pkg.resources ) return callback();
		    		for( var i = 0; i < pkg.resources.length; i++ ) {
		    			if( pkg.resources[i].name == 'esis_spectral_data.zip' ) {

		    				this.ckan.removeResource(pkg.resources[i].id, function(err, resp){
		    					if( err ) return callback(err);
		    					callback();
		    				});
		    				return;
		    			}
		    		}
		    		callback();
		    	}.bind(this));
		    },*/

		    _isEcosisMetadata : function(key) {
		    	if( esis.metadata[key] != null ) return true;
				return false;
		    }


		    
		});
	</script>
</polymer-element>